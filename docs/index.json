{
  "api/CSF.Screenplay.Abilities.UseAStopwatch.html": {
    "href": "api/CSF.Screenplay.Abilities.UseAStopwatch.html",
    "title": "Class UseAStopwatch | Screenplay docs",
    "keywords": "Class UseAStopwatch Namespace CSF.Screenplay.Abilities Assembly CSF.Screenplay.Abstractions.dll An ability that enables an actor to make use of a Stopwatch to accurately measure the passage of time. public class UseAStopwatch : ICanReport Inheritance object UseAStopwatch Implements ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Use this ability with the actions which exposed by StopwatchBuilder. This ability wraps a Stopwatch instance, allowing the actor to control & read it from the related actions. Properties Stopwatch Gets the stopwatch granted to the actor by this ability. public Stopwatch Stopwatch { get; } Property Value Stopwatch Methods GetReportFragment(IHasName, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(IHasName actor, IFormatsReportFragment formatter) Parameters actor IHasName An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose."
  },
  "api/CSF.Screenplay.Abilities.html": {
    "href": "api/CSF.Screenplay.Abilities.html",
    "title": "Namespace CSF.Screenplay.Abilities | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.Abilities Classes UseAStopwatch An ability that enables an actor to make use of a Stopwatch to accurately measure the passage of time."
  },
  "api/CSF.Screenplay.Actor.html": {
    "href": "api/CSF.Screenplay.Actor.html",
    "title": "Class Actor | Screenplay docs",
    "keywords": "Class Actor Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A representation of an autonomous, or at least seemingly-autonomous, person or system which directs the events of a IPerformance. public class Actor : IHasAbilities, IHasName, IHasPerformanceIdentity, IDisposable, IHasPerformableEvents, ICanPerform, ICanPerformGiven, ICanPerformWhen, ICanPerformThen Inheritance object Actor Implements IHasAbilities IHasName IHasPerformanceIdentity IDisposable IHasPerformableEvents ICanPerform ICanPerformGiven ICanPerformWhen ICanPerformThen Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods ActorExtensions.WasAbleTo(ICanPerformGiven, IGetsPerformable, CancellationToken) ActorExtensions.WasAbleTo(ICanPerformGiven, IGetsPerformableWithResult, CancellationToken) ActorExtensions.WasAbleTo<T>(ICanPerformGiven, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.Should(ICanPerformThen, IGetsPerformable, CancellationToken) ActorExtensions.Should(ICanPerformThen, IGetsPerformableWithResult, CancellationToken) ActorExtensions.Should<T>(ICanPerformThen, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.AttemptsTo(ICanPerformWhen, IGetsPerformable, CancellationToken) ActorExtensions.AttemptsTo(ICanPerformWhen, IGetsPerformableWithResult, CancellationToken) ActorExtensions.AttemptsTo<T>(ICanPerformWhen, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.GetAbility(ICanPerform, Type) ActorExtensions.GetAbility<T>(ICanPerform) ActorExtensions.HasAbility(ICanPerform, Type) ActorExtensions.HasAbility<T>(ICanPerform) ActorExtensions.IsAbleTo(ICanPerform, object) ActorExtensions.IsAbleTo<TAbility>(ICanPerform) ActorExtensions.PerformAsync(ICanPerform, IGetsPerformable, CancellationToken) ActorExtensions.PerformAsync(ICanPerform, IGetsPerformableWithResult, CancellationToken) ActorExtensions.PerformAsync<T>(ICanPerform, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.HasAbility(IHasAbilities, Type) ActorExtensions.HasAbility<T>(IHasAbilities) Examples A good example of an actor, aside from a person, could be task scheduling software which executes logic at specific times of day. That is - provided that the task scheduling software itself is not a part of the Screenplay Performance. Within the context of such a performance, the task scheduler executing its logic at the configured time would appear to be an autonomous action because nothing else within the scope of the performance prompted it. Conversely, a mouse trap would be a poor example of an actor; a mouse trap acts only reactively. The creature entering the trap would be the actor in such a performance. Remarks An actor should represent an autonomous or semi-autonomous system. Most commonly is a human being using a piece of software. An actor might also represent an automated system which acts according to policy, so long as configuring/initating that system is not a part of the IPerformance. Within a performance, each performable item is executed in the context of the actor which performed it. Actors have abilities which provide them the means by which to interact with the software. A single conceptual actor must be represented by a single instance of this type; two actors of the same name are not considered to be the same actor, nor will they behave as such. Instances of actor should have an object lifetime which lasts for the remainder of the performance in which they were created. Instances of actor must not be shared across performances. In other words, they should be scoped to only a single performance. A single performance might involve only one actor or it might involve many. If a performance makes use of multiple actors, the developer should consider making use of either or both of the ICast and/or IStage, which assist in the management of multiple actors. Constructors Actor(string, Guid) Initialises a new instance of Actor public Actor(string name, Guid performanceIdentity) Parameters name string The actor's name performanceIdentity Guid A unique identity for the performance Remarks In line with IHasName, it is strongly recommended that name is not null. Properties Abilities Gets a collection of the actor's abilities protected virtual HashSet<object> Abilities { get; } Property Value HashSet<object> Name Gets the actor's name public virtual string Name { get; } Property Value string See Also IHasName PerformanceIdentity Gets the unique identity for the performance in which this actor is participating protected virtual Guid PerformanceIdentity { get; } Property Value Guid Methods Dispose() public void Dispose() Dispose(bool) Disposes the current instance, via the Dispose Pattern. protected virtual void Dispose(bool disposing) Parameters disposing bool A value indicating wherher or not disposal should occur. InvokeBeginPerformable(object, PerformancePhase) Invokes the BeginPerformable event. protected virtual void InvokeBeginPerformable(object performable, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item phase PerformancePhase The performance phase to which this event relates InvokeEndPerformable(object, PerformancePhase) Invokes the EndPerformable event. protected virtual void InvokeEndPerformable(object performable, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item phase PerformancePhase The performance phase to which this event relates InvokeGainedAbility(object) Invokes the GainedAbility event. protected virtual void InvokeGainedAbility(object ability) Parameters ability object The ability which this actor gained InvokePerformableFailed(object, Exception, PerformancePhase) Invokes the PerformableFailed event. protected virtual void InvokePerformableFailed(object performable, Exception exception, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item exception Exception The exception which halted the performable phase PerformancePhase The performance phase to which this event relates InvokePerformableResult(object, object, PerformancePhase) Invokes the PerformableResult event. protected virtual void InvokePerformableResult(object performable, object result, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item result object The result value from the performable phase PerformancePhase The performance phase to which this event relates InvokeRecordsAsset(object, string, string, PerformancePhase) Invokes the RecordsAsset event. protected virtual void InvokeRecordsAsset(object performable, string filePath, string fileSummary = null, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item filePath string The full absolute path to the asset file fileSummary string An optional human-readable summary of the asset file phase PerformancePhase The performance phase to which this event relates IsAbleTo(object) Adds a new ability to the actor protected virtual void IsAbleTo(object ability) Parameters ability object The ability to add Exceptions ArgumentNullException If the ability is null InvalidOperationException If the actor already has an ability of this type or a derived type PerformAsync(IPerformable, PerformancePhase, CancellationToken) Performs an action or task which returns no result. protected virtual ValueTask PerformAsync(IPerformable performable, PerformancePhase phase = PerformancePhase.Unspecified, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item phase PerformancePhase The performance phase to which the performable belongs cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete Exceptions ArgumentNullException If the performable is null PerformAsync(IPerformableWithResult, PerformancePhase, CancellationToken) Performs a question or question-like task which returns an untyped result. protected virtual ValueTask<object> PerformAsync(IPerformableWithResult performable, PerformancePhase phase = PerformancePhase.Unspecified, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item phase PerformancePhase The performance phase to which the performable belongs cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which completes when the performable is complete Exceptions ArgumentNullException If the performable is null PerformAsync<T>(IPerformableWithResult<T>, PerformancePhase, CancellationToken) Performs a question or question-like task which returns a strongly typed result. protected virtual ValueTask<T> PerformAsync<T>(IPerformableWithResult<T> performable, PerformancePhase phase = PerformancePhase.Unspecified, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item phase PerformancePhase The performance phase to which the performable belongs cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which completes when the performable is complete Type Parameters T Exceptions ArgumentNullException If the performable is null Events BeginPerformable Occurs when the actor begins the execution of a performable object. public event EventHandler<PerformableEventArgs> BeginPerformable Event Type EventHandler<PerformableEventArgs> EndPerformable Occurs when an actor ends the execution of a performable object. public event EventHandler<PerformableEventArgs> EndPerformable Event Type EventHandler<PerformableEventArgs> GainedAbility Occurs when an actor gains a new ability. public event EventHandler<GainAbilityEventArgs> GainedAbility Event Type EventHandler<GainAbilityEventArgs> PerformableFailed Occurs when a performable object fails with an exception. public event EventHandler<PerformableFailureEventArgs> PerformableFailed Event Type EventHandler<PerformableFailureEventArgs> PerformableResult Occurs when an actor receives a result from a perfperformable objectrmance. public event EventHandler<PerformableResultEventArgs> PerformableResult Event Type EventHandler<PerformableResultEventArgs> RecordsAsset Occurs when an actor records the presence of a new file asset. public event EventHandler<PerformableAssetEventArgs> RecordsAsset Event Type EventHandler<PerformableAssetEventArgs> See Also IPerformance ICast IStage"
  },
  "api/CSF.Screenplay.ActorExtensions.html": {
    "href": "api/CSF.Screenplay.ActorExtensions.html",
    "title": "Class ActorExtensions | Screenplay docs",
    "keywords": "Class ActorExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Extension methods for actor types public static class ActorExtensions Inheritance object ActorExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AttemptsTo(ICanPerformWhen, IGetsPerformable, CancellationToken) Performs an action or task which returns no result. public static ValueTask AttemptsTo(this ICanPerformWhen actor, IGetsPerformable performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformWhen An actor performableBuilder IGetsPerformable The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete AttemptsTo(ICanPerformWhen, IGetsPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. public static ValueTask<object> AttemptsTo(this ICanPerformWhen actor, IGetsPerformableWithResult performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformWhen An actor performableBuilder IGetsPerformableWithResult The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete AttemptsTo<T>(ICanPerformWhen, IGetsPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. public static ValueTask<T> AttemptsTo<T>(this ICanPerformWhen actor, IGetsPerformableWithResult<T> performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformWhen An actor performableBuilder IGetsPerformableWithResult<T> The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type GetAbility(ICanPerform, Type) Gets the first ability which the actor has of the specified type public static object GetAbility(this ICanPerform actor, Type abilityType) Parameters actor ICanPerform The actor from whom to get the ability abilityType Type The type of ability desired Returns object The ability instance Exceptions ArgumentNullException If any parameter is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor does not have an ability which is or derives from abilityType GetAbility<T>(ICanPerform) Gets the first ability which the actor has of the specified type public static T GetAbility<T>(this ICanPerform actor) Parameters actor ICanPerform The actor from whom to get the ability Returns T The ability instance Type Parameters T The type of ability desired Exceptions ArgumentNullException If the actor is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor does not have an ability which is or derives from T HasAbility(ICanPerform, Type) Gets a value which indicates if the actor has an ability of the specified type. public static bool HasAbility(this ICanPerform actor, Type abilityType) Parameters actor ICanPerform An actor abilityType Type The ability type for which to test Returns bool true if the actor has an ability of the specified abilityType; false if not. Remarks This method will also return false if the actor does not implement IHasAbilities. HasAbility(IHasAbilities, Type) Gets a value which indicates if the actor has an ability of the specified type. public static bool HasAbility(this IHasAbilities actor, Type abilityType) Parameters actor IHasAbilities An actor abilityType Type The ability type for which to test Returns bool true if the actor has an ability of the specified abilityType; false if not. HasAbility<T>(ICanPerform) Gets a value which indicates if the actor has an ability of the specified type. public static bool HasAbility<T>(this ICanPerform actor) Parameters actor ICanPerform An actor Returns bool true if the actor has an ability of the specified T; false if not. Type Parameters T The ability type for which to test Remarks This method will also return false if the actor does not implement IHasAbilities. HasAbility<T>(IHasAbilities) Gets a value which indicates if the actor has an ability of the specified type. public static bool HasAbility<T>(this IHasAbilities actor) Parameters actor IHasAbilities An actor Returns bool true if the actor has an ability of the specified T; false if not. Type Parameters T The ability type for which to test IsAbleTo(ICanPerform, object) Adds an ability to the specified actor public static void IsAbleTo(this ICanPerform actor, object ability) Parameters actor ICanPerform The actor from whom to get the ability ability object The ability to add to the actor Exceptions ArgumentNullException If any parameter is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor already has an ability of the same type as the ability to add, or which derives from the same type IsAbleTo<TAbility>(ICanPerform) Adds an ability to the specified actor, where the ability has a public parameterless constructor public static void IsAbleTo<TAbility>(this ICanPerform actor) where TAbility : new() Parameters actor ICanPerform The actor from whom to get the ability Type Parameters TAbility The type of the ability to add to the actor Remarks This method is a convenience for manually instantiating the ability instance and adding it to the actor in that manner. For abilities which do not have a public parameterless constructor, consider adding them to the actor via dependency injection. The recommended technique for accomplishing this is by implementing IPersona in a class of your own. Implementations of persona are eligible for dependency injection when the actor is retrieved from the persona type via the ICast: GetActor<TPersona>(ICast). Exceptions ArgumentNullException If any parameter is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor already has an ability of the same type as the TAbility to add, or which derives from the same type PerformAsync(ICanPerform, IGetsPerformable, CancellationToken) Performs an action or task which returns no result from the performable which is exposed by the specified builder object. public static ValueTask PerformAsync(this ICanPerform actor, IGetsPerformable performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerform An actor performableBuilder IGetsPerformable The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete PerformAsync(ICanPerform, IGetsPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result from the performable which is exposed by the specified builder object. public static ValueTask<object> PerformAsync(this ICanPerform actor, IGetsPerformableWithResult performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerform An actor performableBuilder IGetsPerformableWithResult The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete PerformAsync<T>(ICanPerform, IGetsPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result from the performable which is exposed by the specified builder object. public static ValueTask<T> PerformAsync<T>(this ICanPerform actor, IGetsPerformableWithResult<T> performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerform An actor performableBuilder IGetsPerformableWithResult<T> The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type Should(ICanPerformThen, IGetsPerformable, CancellationToken) Performs an action or task which returns no result. public static ValueTask Should(this ICanPerformThen actor, IGetsPerformable performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformThen An actor performableBuilder IGetsPerformable The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete Should(ICanPerformThen, IGetsPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. public static ValueTask<object> Should(this ICanPerformThen actor, IGetsPerformableWithResult performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformThen An actor performableBuilder IGetsPerformableWithResult The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete Should<T>(ICanPerformThen, IGetsPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. public static ValueTask<T> Should<T>(this ICanPerformThen actor, IGetsPerformableWithResult<T> performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformThen An actor performableBuilder IGetsPerformableWithResult<T> The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type WasAbleTo(ICanPerformGiven, IGetsPerformable, CancellationToken) Performs an action or task which returns no result. public static ValueTask WasAbleTo(this ICanPerformGiven actor, IGetsPerformable performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformGiven An actor performableBuilder IGetsPerformable The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete WasAbleTo(ICanPerformGiven, IGetsPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. public static ValueTask<object> WasAbleTo(this ICanPerformGiven actor, IGetsPerformableWithResult performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformGiven An actor performableBuilder IGetsPerformableWithResult The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete WasAbleTo<T>(ICanPerformGiven, IGetsPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. public static ValueTask<T> WasAbleTo<T>(this ICanPerformGiven actor, IGetsPerformableWithResult<T> performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformGiven An actor performableBuilder IGetsPerformableWithResult<T> The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type"
  },
  "api/CSF.Screenplay.Actors.ActorEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.ActorEventArgs.html",
    "title": "Class ActorEventArgs | Screenplay docs",
    "keywords": "Class ActorEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to an Actor. public class ActorEventArgs : PerformanceScopeEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs Implements IHasPerformanceIdentity Derived GainAbilityEventArgs PerformableEventArgs Inherited Members PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ActorEventArgs(Actor) Initializes a new instance of ActorEventArgs public ActorEventArgs(Actor actor) Parameters actor Actor The actor Properties Actor Gets the name of the actor to which these event arguments relate public Actor Actor { get; } Property Value Actor See Also Actor"
  },
  "api/CSF.Screenplay.Actors.Cast.html": {
    "href": "api/CSF.Screenplay.Actors.Cast.html",
    "title": "Class Cast | Screenplay docs",
    "keywords": "Class Cast Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.dll The default implementation of ICast which serves as a registry/factory for Actor instances. public sealed class Cast : ICast, IHasServiceProvider, IHasPerformanceIdentity Inheritance object Cast Implements ICast IHasServiceProvider IHasPerformanceIdentity Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Cast(IServiceProvider, Guid) Initialises a new instance of Cast. public Cast(IServiceProvider serviceProvider, Guid performanceIdentity) Parameters serviceProvider IServiceProvider A service provider performanceIdentity Guid The identity of the current performance Exceptions ArgumentNullException If serviceProvider is null. Properties PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. ServiceProvider Gets a service provider/resolver instance associated with this object. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods GetActor(IPersona) Gets a single Actor based upon a persona, creating them if they do not already exist in the cast. public Actor GetActor(IPersona persona) Parameters persona IPersona The persona from which to get an actor Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, using the persona as a factory, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast, matched using the IPersona's Name. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified persona name differs only in case. Consider using GetActor<TPersona>(ICast) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. See Also IPersona GetActor(string) Gets a single Actor by their name, creating them if they do not already exist in the cast. public Actor GetActor(string name) Parameters name string The name of the actor to get Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified name differs only in case. If you make use of a same-named actor across multiple performances then it is highly recommended to use personas in order to consistently define the actor's attributes and abilities. You would then use the overload of this method which uses that persona to define the actor. See Also IPersona"
  },
  "api/CSF.Screenplay.Actors.GainAbilityEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.GainAbilityEventArgs.html",
    "title": "Class GainAbilityEventArgs | Screenplay docs",
    "keywords": "Class GainAbilityEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to an actor gaining a new ability. public class GainAbilityEventArgs : ActorEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs GainAbilityEventArgs Implements IHasPerformanceIdentity Inherited Members ActorEventArgs.Actor PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GainAbilityEventArgs(Actor, object) Initializes a new instance of GainAbilityEventArgs. public GainAbilityEventArgs(Actor actor, object ability) Parameters actor Actor The actor ability object The ability Properties Ability Gets the ability which the actor has gained public object Ability { get; } Property Value object"
  },
  "api/CSF.Screenplay.Actors.ICanPerformGiven.html": {
    "href": "api/CSF.Screenplay.Actors.ICanPerformGiven.html",
    "title": "Interface ICanPerformGiven | Screenplay docs",
    "keywords": "Interface ICanPerformGiven Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll An actor which is able to perform in the Given phase of a IPerformance. public interface ICanPerformGiven Extension Methods ActorExtensions.WasAbleTo(ICanPerformGiven, IGetsPerformable, CancellationToken) ActorExtensions.WasAbleTo(ICanPerformGiven, IGetsPerformableWithResult, CancellationToken) ActorExtensions.WasAbleTo<T>(ICanPerformGiven, IGetsPerformableWithResult<T>, CancellationToken) Remarks This interface is conceptually identical to ICanPerform, except that the nomenclature of its methods is written in the past tense, as is best pratice for the Given phase of a performance. Methods WasAbleTo(IPerformable, CancellationToken) Performs an action or task which returns no result. ValueTask WasAbleTo(IPerformable performable, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete WasAbleTo(IPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. ValueTask<object> WasAbleTo(IPerformableWithResult performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete WasAbleTo<T>(IPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. ValueTask<T> WasAbleTo<T>(IPerformableWithResult<T> performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type See Also ICanPerform"
  },
  "api/CSF.Screenplay.Actors.ICanPerformThen.html": {
    "href": "api/CSF.Screenplay.Actors.ICanPerformThen.html",
    "title": "Interface ICanPerformThen | Screenplay docs",
    "keywords": "Interface ICanPerformThen Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll An actor which is able to perform in the Then phase of a IPerformance. public interface ICanPerformThen Extension Methods ActorExtensions.Should(ICanPerformThen, IGetsPerformable, CancellationToken) ActorExtensions.Should(ICanPerformThen, IGetsPerformableWithResult, CancellationToken) ActorExtensions.Should<T>(ICanPerformThen, IGetsPerformableWithResult<T>, CancellationToken) Remarks This interface is conceptually identical to ICanPerform, except that the nomenclature of its methods is written in the future tense, as is best pratice for the Then phase of a performance. Methods Should(IPerformable, CancellationToken) Performs an action or task which returns no result. ValueTask Should(IPerformable performable, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete Should(IPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. ValueTask<object> Should(IPerformableWithResult performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete Should<T>(IPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. ValueTask<T> Should<T>(IPerformableWithResult<T> performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type See Also ICanPerform"
  },
  "api/CSF.Screenplay.Actors.ICanPerformWhen.html": {
    "href": "api/CSF.Screenplay.Actors.ICanPerformWhen.html",
    "title": "Interface ICanPerformWhen | Screenplay docs",
    "keywords": "Interface ICanPerformWhen Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll An actor which is able to perform in the When phase of a IPerformance. public interface ICanPerformWhen Extension Methods ActorExtensions.AttemptsTo(ICanPerformWhen, IGetsPerformable, CancellationToken) ActorExtensions.AttemptsTo(ICanPerformWhen, IGetsPerformableWithResult, CancellationToken) ActorExtensions.AttemptsTo<T>(ICanPerformWhen, IGetsPerformableWithResult<T>, CancellationToken) Remarks This interface is conceptually identical to ICanPerform, except that the nomenclature of its methods is written in the present tense, as is best pratice for the When phase of a performance. In addition, the wording of these methods indicates that the actor is attempting something, which might fail. Methods AttemptsTo(IPerformable, CancellationToken) Performs an action or task which returns no result. ValueTask AttemptsTo(IPerformable performable, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete AttemptsTo(IPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. ValueTask<object> AttemptsTo(IPerformableWithResult performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete AttemptsTo<T>(IPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. ValueTask<T> AttemptsTo<T>(IPerformableWithResult<T> performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type See Also ICanPerform"
  },
  "api/CSF.Screenplay.Actors.IHasPerformableEvents.html": {
    "href": "api/CSF.Screenplay.Actors.IHasPerformableEvents.html",
    "title": "Interface IHasPerformableEvents | Screenplay docs",
    "keywords": "Interface IHasPerformableEvents Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll An actor which may emit events as they participate in a IPerformance public interface IHasPerformableEvents Events BeginPerformable Occurs when the actor begins the execution of a performable object. event EventHandler<PerformableEventArgs> BeginPerformable Event Type EventHandler<PerformableEventArgs> EndPerformable Occurs when an actor ends the execution of a performable object. event EventHandler<PerformableEventArgs> EndPerformable Event Type EventHandler<PerformableEventArgs> GainedAbility Occurs when an actor gains a new ability. event EventHandler<GainAbilityEventArgs> GainedAbility Event Type EventHandler<GainAbilityEventArgs> PerformableFailed Occurs when a performable object fails with an exception. event EventHandler<PerformableFailureEventArgs> PerformableFailed Event Type EventHandler<PerformableFailureEventArgs> PerformableResult Occurs when an actor receives a result from a perfperformable objectrmance. event EventHandler<PerformableResultEventArgs> PerformableResult Event Type EventHandler<PerformableResultEventArgs> RecordsAsset Occurs when an actor records the presence of a new file asset. event EventHandler<PerformableAssetEventArgs> RecordsAsset Event Type EventHandler<PerformableAssetEventArgs>"
  },
  "api/CSF.Screenplay.Actors.PerformableAssetEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.PerformableAssetEventArgs.html",
    "title": "Class PerformableAssetEventArgs | Screenplay docs",
    "keywords": "Class PerformableAssetEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll Event arguments which represent the revealing of a file asset which relates to a performable. public class PerformableAssetEventArgs : PerformableEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs PerformableEventArgs PerformableAssetEventArgs Implements IHasPerformanceIdentity Inherited Members PerformableEventArgs.Performable PerformableEventArgs.Phase ActorEventArgs.Actor PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformableAssetEventArgs(Actor, object, string, string, PerformancePhase) Initializes a new instance of PerformableAssetEventArgs. public PerformableAssetEventArgs(Actor actor, object performable, string filePath, string fileSummary = null, PerformancePhase phase = PerformancePhase.Unspecified) Parameters actor Actor The actor performable object The performable item filePath string The full absolute path to the asset file fileSummary string An optional human-readable summary of the asset file phase PerformancePhase The phase of performance Properties FilePath Gets a full/absolute path to the asset file. public string FilePath { get; } Property Value string FileSummary Gets an optional human-readable summary of what this asset represents. This should be one sentence at most, suitable for display in a UI tool-tip. public string FileSummary { get; } Property Value string See Also RecordAsset(object, string, string)"
  },
  "api/CSF.Screenplay.Actors.PerformableEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.PerformableEventArgs.html",
    "title": "Class PerformableEventArgs | Screenplay docs",
    "keywords": "Class PerformableEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to an actor's use of a performable. public class PerformableEventArgs : ActorEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs PerformableEventArgs Implements IHasPerformanceIdentity Derived PerformableAssetEventArgs PerformableFailureEventArgs PerformableResultEventArgs Inherited Members ActorEventArgs.Actor PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformableEventArgs(Actor, object, PerformancePhase) Initializes a new instance of PerformableEventArgs. public PerformableEventArgs(Actor actor, object performable, PerformancePhase phase = PerformancePhase.Unspecified) Parameters actor Actor The actor performable object The performable item phase PerformancePhase The phase of performance Properties Performable Gets the performable item to which these event arguments relate. public object Performable { get; } Property Value object Phase Gets the performance phase to which these event arguments relate. public PerformancePhase Phase { get; } Property Value PerformancePhase"
  },
  "api/CSF.Screenplay.Actors.PerformableFailureEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.PerformableFailureEventArgs.html",
    "title": "Class PerformableFailureEventArgs | Screenplay docs",
    "keywords": "Class PerformableFailureEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A specialisation of PerformableEventArgs which describe the situation where an exception halted the execution of the performable item. public class PerformableFailureEventArgs : PerformableEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs PerformableEventArgs PerformableFailureEventArgs Implements IHasPerformanceIdentity Inherited Members PerformableEventArgs.Performable PerformableEventArgs.Phase ActorEventArgs.Actor PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformableFailureEventArgs(Actor, object, Exception, PerformancePhase) Initializes a new instance of PerformableFailureEventArgs. public PerformableFailureEventArgs(Actor actor, object performable, Exception exception, PerformancePhase phase = PerformancePhase.Unspecified) Parameters actor Actor The actor performable object The performable item which raised the exception exception Exception The exception which occurred phase PerformancePhase The phase of performance which was underway when the exception occurred Properties Exception Gets the exception which halted the performable item. public Exception Exception { get; } Property Value Exception"
  },
  "api/CSF.Screenplay.Actors.PerformableResultEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.PerformableResultEventArgs.html",
    "title": "Class PerformableResultEventArgs | Screenplay docs",
    "keywords": "Class PerformableResultEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A specialisation of PerformableEventArgs which describe a scenario in which the performable completed and has returned a result value. public class PerformableResultEventArgs : PerformableEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs PerformableEventArgs PerformableResultEventArgs Implements IHasPerformanceIdentity Inherited Members PerformableEventArgs.Performable PerformableEventArgs.Phase ActorEventArgs.Actor PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformableResultEventArgs(Actor, object, object, PerformancePhase) Initializes a new instance of PerformableResultEventArgs. public PerformableResultEventArgs(Actor actor, object performable, object result, PerformancePhase phase = PerformancePhase.Unspecified) Parameters actor Actor The actor performable object The performable item result object The result from the performable phase PerformancePhase The phase of performance Properties Result Gets the result value which was returned by the performable public object Result { get; } Property Value object"
  },
  "api/CSF.Screenplay.Actors.PerformancePhase.html": {
    "href": "api/CSF.Screenplay.Actors.PerformancePhase.html",
    "title": "Enum PerformancePhase | Screenplay docs",
    "keywords": "Enum PerformancePhase Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll Enumerates the phases of a performance public enum PerformancePhase Fields Given = 1 The 'Given' phase of a performance is for set-up and fulfilling preconditions Then = 3 The 'Then' phase of a performance is where the results of the When phase are as expected; is it a pass or a fail? Unspecified = 0 Indicates that no phase has been specified When = 2 The 'When' phase of a performance describes the activity which is under test Remarks It is common for a IPerformance to occur in phases. This is especially true when Screenplay is being used as a testing tool. This type enumerates the possible phases. If phases are irrelevant to your usage of Screenplay then feel free to use Unspecified, which is the default phase when no phase has been specified."
  },
  "api/CSF.Screenplay.Actors.Stage.html": {
    "href": "api/CSF.Screenplay.Actors.Stage.html",
    "title": "Class Stage | Screenplay docs",
    "keywords": "Class Stage Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.dll The default implementation of IStage which provides a context for which actor is currently active. public sealed class Stage : IStage, IHasPerformanceIdentity Inheritance object Stage Implements IStage IHasPerformanceIdentity Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Stage(ICast, IRelaysPerformanceEvents) Initialises a new instance of Stage public Stage(ICast cast, IRelaysPerformanceEvents performanceEventBus) Parameters cast ICast The cast performanceEventBus IRelaysPerformanceEvents An event bus for collecting stage-related events Exceptions ArgumentNullException If any parameter value is null Properties Cast Gets the cast to which the current stage is linked. public ICast Cast { get; } Property Value ICast PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. Methods GetSpotlitActor() Gets the actor which is currently in the spotlight. public Actor GetSpotlitActor() Returns Actor The actor who has previously been placed in the spotlight, or a null reference if there is presently no actor in the spotlight. Spotlight(Actor) Places the specified actor into the spotlight, making them 'the current actor' on this stage. public void Spotlight(Actor actor) Parameters actor Actor Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the specified actor. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If the specified actor is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Exceptions ArgumentNullException If the actor is null. Spotlight(IPersona) Places an actor matching the specified persona into the spotlight, making them 'the current actor' on this stage. public Actor Spotlight(IPersona persona) Parameters persona IPersona Returns Actor The actor instance which was placed into the spotlight. Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the actor derived from the persona. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If actor indicated by the persona is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. When spotlighting a persona, the actor instance is retrieved from an ICast based upon that same persona. See GetActor(IPersona) for more information. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Consider using Spotlight<TPersona>(IStage) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. Exceptions ArgumentNullException If the actor is null. TurnSpotlightOff() Removes any existing actor from the spotlight, ensuring that no actor is in the spotlight. public Actor TurnSpotlightOff() Returns Actor If an actor was previously in the spotlight, and has now been removed, then this method returns that actor; otherwise it will return a null reference. Remarks If there was already no actor in the spotlight when this method is executed then it will have no effect, the spotlight will remain empty and this method will return null."
  },
  "api/CSF.Screenplay.Actors.html": {
    "href": "api/CSF.Screenplay.Actors.html",
    "title": "Namespace CSF.Screenplay.Actors | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.Actors Classes ActorEventArgs A model for event arguments which relate to an Actor. Cast The default implementation of ICast which serves as a registry/factory for Actor instances. GainAbilityEventArgs A model for event arguments which relate to an actor gaining a new ability. PerformableAssetEventArgs Event arguments which represent the revealing of a file asset which relates to a performable. PerformableEventArgs A model for event arguments which relate to an actor's use of a performable. PerformableFailureEventArgs A specialisation of PerformableEventArgs which describe the situation where an exception halted the execution of the performable item. PerformableResultEventArgs A specialisation of PerformableEventArgs which describe a scenario in which the performable completed and has returned a result value. Stage The default implementation of IStage which provides a context for which actor is currently active. Interfaces ICanPerformGiven An actor which is able to perform in the Given phase of a IPerformance. ICanPerformThen An actor which is able to perform in the Then phase of a IPerformance. ICanPerformWhen An actor which is able to perform in the When phase of a IPerformance. IHasPerformableEvents An actor which may emit events as they participate in a IPerformance Enums PerformancePhase Enumerates the phases of a performance"
  },
  "api/CSF.Screenplay.CastExtensions.html": {
    "href": "api/CSF.Screenplay.CastExtensions.html",
    "title": "Class CastExtensions | Screenplay docs",
    "keywords": "Class CastExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Extension methods for ICast. public static class CastExtensions Inheritance object CastExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetActor<TPersona>(ICast) Gets a single Actor based upon a persona, creating them if they do not already exist in the cast. public static Actor GetActor<TPersona>(this ICast cast) where TPersona : class, IPersona Parameters cast ICast The cast from which to get an actor Returns Actor An actor based on the specified persona, either an existing instance or a newly-created actor. Type Parameters TPersona A concrete type of IPersona from which to get an actor. Remarks This method will create the actor within the current cast, using a resolved instance of the persona as a factory, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast, matched using the IPersona's Name. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified persona name differs only in case. This method is the recommended way of getting an actor from a persona, as it takes care of resolving the persona from dependency injection automatically. See Also IPersona"
  },
  "api/CSF.Screenplay.ICanPerform.html": {
    "href": "api/CSF.Screenplay.ICanPerform.html",
    "title": "Interface ICanPerform | Screenplay docs",
    "keywords": "Interface ICanPerform Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An actor which may perform in the Screenplay. public interface ICanPerform Extension Methods ActorExtensions.GetAbility(ICanPerform, Type) ActorExtensions.GetAbility<T>(ICanPerform) ActorExtensions.HasAbility(ICanPerform, Type) ActorExtensions.HasAbility<T>(ICanPerform) ActorExtensions.IsAbleTo(ICanPerform, object) ActorExtensions.IsAbleTo<TAbility>(ICanPerform) ActorExtensions.PerformAsync(ICanPerform, IGetsPerformable, CancellationToken) ActorExtensions.PerformAsync(ICanPerform, IGetsPerformableWithResult, CancellationToken) ActorExtensions.PerformAsync<T>(ICanPerform, IGetsPerformableWithResult<T>, CancellationToken) Methods PerformAsync(IPerformable, CancellationToken) Performs an action or task which returns no result. ValueTask PerformAsync(IPerformable performable, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete PerformAsync(IPerformableWithResult, CancellationToken) Performs a question or question-like task which returns an untyped result. ValueTask<object> PerformAsync(IPerformableWithResult performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete PerformAsync<T>(IPerformableWithResult<T>, CancellationToken) Performs a question or question-like task which returns a strongly typed result. ValueTask<T> PerformAsync<T>(IPerformableWithResult<T> performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type RecordAsset(object, string, string) Records the existence of a new performable asset file at the specified path. void RecordAsset(object performable, string filePath, string fileSummary = null) Parameters performable object The performable item filePath string The full absolute path to the asset file fileSummary string An optional human-readable summary of the asset file Remarks File assets are sometimes created during a performance as a reporting/verification mechanism. For example a performable which controls the user interface of an application might take and save a screenshot of that UI so that a human may later verify that everything looked as it should. Alternatively, file assets might constitute part of the output of a performance. Imagine an application of Screenplay which captures video from a security camera; that video file would be an asset. This method may be used from performables which generate and save asset files. They ensure that appropriate events are called and passed 'upward' through the Screenplay architecture, such that subscribers may be notified. This will allow the presence and details of assets to be included in Screenplay artifacts such as reports. See Also IPerformable IPerformableWithResult IPerformableWithResult<TResult> IHasAbilities"
  },
  "api/CSF.Screenplay.ICanReport.html": {
    "href": "api/CSF.Screenplay.ICanReport.html",
    "title": "Interface ICanReport | Screenplay docs",
    "keywords": "Interface ICanReport Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A type which can provide a human-readable report fragment when it is used in a IPerformance. public interface ICanReport Remarks It is recommended for all types for Actions, Questions, Tasks (broadly \"Performables\") as well as Abilities to implement this interface. Implementing this interface permits the type to emit a human-readable value for when the type is used in a Performance. For Performables implementing this interface, the report fragment indicates that the performable has been executed in the Performance. For abilities which implement this interface, the report fragment is used when an Actor gains/is granted the ability. Methods GetReportFragment(IHasName, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. ReportFragment GetReportFragment(IHasName actor, IFormatsReportFragment formatter) Parameters actor IHasName An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. See Also IPerformable IPerformableWithResult IPerformableWithResult<TResult>"
  },
  "api/CSF.Screenplay.ICast.html": {
    "href": "api/CSF.Screenplay.ICast.html",
    "title": "Interface ICast | Screenplay docs",
    "keywords": "Interface ICast Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A combined registry and factory for Actor instances, useful when coordinating multiple actors across a IPerformance public interface ICast : IHasServiceProvider, IHasPerformanceIdentity Inherited Members IHasServiceProvider.ServiceProvider IHasPerformanceIdentity.PerformanceIdentity Extension Methods CastExtensions.GetActor<TPersona>(ICast) Remarks The cast is a strongly recommended component of Screenplay logic. It is used to manage Actor objects for the duration of a IPerformance. Cast objects are always scoped to a IPerformance and have the same lifetime. Any actors created or tracked by a cast will also automatically share this lifetime. In terms of design patterns, the cast operates as both a registry: https://martinfowler.com/eaaCatalog/registry.html and as a factory: https://en.wikipedia.org/wiki/Factory_method_pattern for actors. During the cast's lifetime, subsequent calls to an overload of GetActor using the same actor/persona name will return the instance of Actor as was created the first time the method was called with that name. A cast, and the actors managed by a cast, are independent per IPerformance, though. Developers are strongly advised to configure their actors via classes which derive from IPersona. This allows for sharing of common actor-setup logic such as abilities. In a Screenplay the cast is a dependency-injectable service which may be used within your performances. Methods GetActor(IPersona) Gets a single Actor based upon a persona, creating them if they do not already exist in the cast. Actor GetActor(IPersona persona) Parameters persona IPersona The persona from which to get an actor Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, using the persona as a factory, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast, matched using the IPersona's Name. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified persona name differs only in case. Consider using GetActor<TPersona>(ICast) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. See Also IPersona GetActor(string) Gets a single Actor by their name, creating them if they do not already exist in the cast. Actor GetActor(string name) Parameters name string The name of the actor to get Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified name differs only in case. If you make use of a same-named actor across multiple performances then it is highly recommended to use personas in order to consistently define the actor's attributes and abilities. You would then use the overload of this method which uses that persona to define the actor. See Also IPersona See Also IStage Actor IPerformance IPersona"
  },
  "api/CSF.Screenplay.IFormatsReportFragment.html": {
    "href": "api/CSF.Screenplay.IFormatsReportFragment.html",
    "title": "Interface IFormatsReportFragment | Screenplay docs",
    "keywords": "Interface IFormatsReportFragment Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A service which produces formatted report fragments from a template and a collection of parameter values. public interface IFormatsReportFragment Methods Format(string, params object[]) Gets the formatted report fragment from the specified template and values. ReportFragment Format(string template, params object[] values) Parameters template string A string template for the report fragment values object[] A collection of values associated with the report fragment Returns ReportFragment A formatted report fragment Examples The following code will produce the final formatted string as noted below. var p1 = \"first\"; var p2 = \"second\"; formatter.Format(\"The values are {p2} and {p1}\", p1, p2); // This will yield the result \"The values are first and second\" Remarks The template should be a human-readable string (localized if you wish) which would be recorded in a Screenplay report. This string may contain any number of placeholder markers which are indicated by some text enclosed within braces, such as {Name}. This functions in a slightly similar fashion to .NET logging: https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-message-template or the Format(string, params object[]) method. Importantly, the placeholders are identified by names, rather than numeric index, in the same way that logging template strings work. Placeholders do not support any kind of format or alignment syntax. Developers are encouraged to choose meaningful names for their placeholders. The ReportFragment which is produced by this method will include the values associated with those placeholder names. This allows reporting infrastructure to work in a similar manner to the way in which structured logging is described in the article linked above. This provides a richer data model than simply a plain string. See Also ReportFragment"
  },
  "api/CSF.Screenplay.IGetsScreenplay.html": {
    "href": "api/CSF.Screenplay.IGetsScreenplay.html",
    "title": "Interface IGetsScreenplay | Screenplay docs",
    "keywords": "Interface IGetsScreenplay Namespace CSF.Screenplay Assembly CSF.Screenplay.dll An object which can fully configure and get a Screenplay instance. public interface IGetsScreenplay Examples The smallest example of a valid implementation of this class, which just gets a default Screenplay with no customizations is: public class ScreenplayFactory : IGetsScreenplay { public Screenplay GetScreenplay() => Screenplay.Create(); } Feel free to customize this example to add a parameter to the Create method, which adds other services to the DI service collection which will be used with the Screenplay. Such services could be those Remarks This interface is particularly important when using Screenplay as a testing tool. Some test integrations do not have any inherent extension points for the placement of 'configuration' or startup logic which affects the entire test run. In those cases, a developer will need to implement this interface with a class of their own, in order to configure and get the Screenplay instance. Types which implement this interface need only implement the GetScreenplay() method, which should build and return a Screenplay instance. Developers are advised to use Create(Action<IServiceCollection>, Action<ScreenplayOptions>) to create and return the Screenplay. Note that implementations of this type must have a public parameterless constructor, because they will be instantiated via CreateInstance(Type) and not resolved from dependency injection. Methods GetScreenplay() Gets the configured Screenplay instance provided by the current type. Screenplay GetScreenplay() Returns Screenplay A Screenplay instance Remarks Implementors should create and return a new Screenplay instance from this method; they are strongly urged to consider the use of Create(Action<IServiceCollection>, Action<ScreenplayOptions>) for this purpose. As well as the creation of the Screenplay instance itself, they should also add to the service collection any services which relate to abilities which could be used in the Screenplay. It is recommended to use the parameter to the Create method (above) to configure such services into the DI container."
  },
  "api/CSF.Screenplay.IHasAbilities.html": {
    "href": "api/CSF.Screenplay.IHasAbilities.html",
    "title": "Interface IHasAbilities | Screenplay docs",
    "keywords": "Interface IHasAbilities Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which has & is able to gain abilities. public interface IHasAbilities Extension Methods ActorExtensions.HasAbility(IHasAbilities, Type) ActorExtensions.HasAbility<T>(IHasAbilities) Remarks Abilities are the mechanism by which actors: ICanPerform interact with the application and system. They are arbitrary objects which provide functionality. Properties Abilities Gets the collection of the actor's abilities. IReadOnlyCollection<object> Abilities { get; } Property Value IReadOnlyCollection<object> Methods IsAbleTo(object) Adds an ability to the specified actor void IsAbleTo(object ability) Parameters ability object The ability to add to the actor Exceptions ArgumentNullException If ability is null InvalidOperationException If the actor already has an ability of the same type as ability, or which derives from the same type"
  },
  "api/CSF.Screenplay.IHasName.html": {
    "href": "api/CSF.Screenplay.IHasName.html",
    "title": "Interface IHasName | Screenplay docs",
    "keywords": "Interface IHasName Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A part of a Screenplay performance which has a human-readable name. public interface IHasName Remarks Use this interface for any object within an IPerformance which could benefit from having a human-readable name. For example, static parameter values like Web API endpoints, web page URLs or elements on a web UI. By referring to an object by its name, and using that name in report-generating logic, reports generated from a Screenplay can become much easier to read and comprehend. The Name property is used to provide a human-readable string which represents the object in the report text. This interface is a part of the mechanism for formatting values in reports in Screenplay. Properties Name Gets the human-readable name of the current object. string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. See Also IFormattableValue IValueFormatter"
  },
  "api/CSF.Screenplay.IHasPerformanceIdentity.html": {
    "href": "api/CSF.Screenplay.IHasPerformanceIdentity.html",
    "title": "Interface IHasPerformanceIdentity | Screenplay docs",
    "keywords": "Interface IHasPerformanceIdentity Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which provides a value which uniquely identifies the currently-executing IPerformance. public interface IHasPerformanceIdentity Properties PerformanceIdentity Gets the unique IPerformance identifier Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay."
  },
  "api/CSF.Screenplay.IHasServiceProvider.html": {
    "href": "api/CSF.Screenplay.IHasServiceProvider.html",
    "title": "Interface IHasServiceProvider | Screenplay docs",
    "keywords": "Interface IHasServiceProvider Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which has an associated IServiceProvider, which resolves services from dependency injection. public interface IHasServiceProvider Properties ServiceProvider Gets a service provider/resolver instance associated with this object. IServiceProvider ServiceProvider { get; } Property Value IServiceProvider"
  },
  "api/CSF.Screenplay.IHostsPerformance.html": {
    "href": "api/CSF.Screenplay.IHostsPerformance.html",
    "title": "Interface IHostsPerformance | Screenplay docs",
    "keywords": "Interface IHostsPerformance Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which encapsulates the logic of an IPerformance in a standalone Screenplay. public interface IHostsPerformance Remarks Implementors should inject any dependencies they require into their constructors. The ExecutePerformanceAsync(CancellationToken) method is used to execute the logic of an IPerformance, returning its result. Methods ExecutePerformanceAsync(CancellationToken) Executes the logic of a performance, returning the result. Task<bool?> ExecutePerformanceAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A cancellation token Returns Task<bool?> A task which exposes the result of the performance. Remarks The result of the performance has the same semantics as FinishPerformance(bool?). Implementors should use this method to execute the logic of the performance."
  },
  "api/CSF.Screenplay.IPerformable.html": {
    "href": "api/CSF.Screenplay.IPerformable.html",
    "title": "Interface IPerformable | Screenplay docs",
    "keywords": "Interface IPerformable Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which represents something that a performer (typically an actor) may perform. public interface IPerformable Remarks Performable objects generally fall into one of three categories in Screenplay: An action, which is the most fine-grained type of performable, typically \"doing something which alters the state of the application\" A question, which is fine-grained like an action but instead reads state without changing it A task, which may be composed of actions, questions or even other tasks Objects which implement only this interface are the simplest types of performables; they simply 'do something' and then finish. In the list given above these are typically actions. They do not return any form of result except completion. If you wish to get a result from the performable then consider implementing an interface derived from this one, such as IPerformableWithResult or its strongly-typed counterpart IPerformableWithResult<TResult>. When implementing this interface, consider also implementing ICanReport. If a performable does not implement ICanReport then it will receive default text when the IPerformance report is generated. Implementing ICanReport allows a performable to provide a customised human-readable report fragment. Methods PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also IPerformableWithResult IPerformableWithResult<TResult>"
  },
  "api/CSF.Screenplay.IPerformableWithResult-1.html": {
    "href": "api/CSF.Screenplay.IPerformableWithResult-1.html",
    "title": "Interface IPerformableWithResult<TResult> | Screenplay docs",
    "keywords": "Interface IPerformableWithResult<TResult> Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which represents something that a performer (typically an actor) may perform and which returns a strongly-typed result when it completes. public interface IPerformableWithResult<TResult> Type Parameters TResult Remarks Performable objects generally fall into one of three categories in Screenplay: An action, which is the most fine-grained type of performable, typically \"doing something which alters the state of the application\" A question, which is fine-grained like an action but instead reads state without changing it A task, which may be composed of actions, questions or even other tasks Objects which implement this interface are questions or tasks which are composed (at least in-part) from one or more questions. If you do not wish to get a result from the performable then implement only IPerformable instead. When implementing this interface, consider also implementing ICanReport. If a performable does not implement ICanReport then it will receive default text when the IPerformance report is generated. Implementing ICanReport allows a performable to provide a customised human-readable report fragment. Methods PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. ValueTask<TResult> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TResult> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete. See Also IPerformable IPerformableWithResult"
  },
  "api/CSF.Screenplay.IPerformableWithResult.html": {
    "href": "api/CSF.Screenplay.IPerformableWithResult.html",
    "title": "Interface IPerformableWithResult | Screenplay docs",
    "keywords": "Interface IPerformableWithResult Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which represents something that a performer (typically an actor) may perform and which returns a result when it completes. public interface IPerformableWithResult Remarks Performable objects generally fall into one of three categories in Screenplay: An action, which is the most fine-grained type of performable, typically \"doing something which alters the state of the application\" A question, which is fine-grained like an action but instead reads state without changing it A task, which may be composed of actions, questions or even other tasks Objects which implement this interface are questions or tasks which are composed (at least in-part) from one or more questions. If you do not wish to get a result from the performable then implement only IPerformable instead. Alternatively, if you wish to return a strongly-typed result then instead consider implementing IPerformableWithResult<TResult>. When implementing this interface, consider also implementing ICanReport. If a performable does not implement ICanReport then it will receive default text when the IPerformance report is generated. Implementing ICanReport allows a performable to provide a customised human-readable report fragment. Methods PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a value. ValueTask<object> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<object> A task which exposes a 'result' value when the performable represented by the current instance is complete. See Also IPerformable IPerformableWithResult<TResult>"
  },
  "api/CSF.Screenplay.IPerformance.html": {
    "href": "api/CSF.Screenplay.IPerformance.html",
    "title": "Interface IPerformance | Screenplay docs",
    "keywords": "Interface IPerformance Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A performance represents a self-contained scope of performables which typically results in overall success or failure. public interface IPerformance : IHasPerformanceIdentity, IHasServiceProvider, IDisposable, IBeginsAndEndsPerformance Inherited Members IHasPerformanceIdentity.PerformanceIdentity IHasServiceProvider.ServiceProvider IDisposable.Dispose() IBeginsAndEndsPerformance.BeginPerformance() IBeginsAndEndsPerformance.FinishPerformance(bool?) Remarks In .NET code which uses Screenplay, a performance is .NET logic involving one or more Actor instances, executing one or more performable items. A Screenplay will be comprised of one or more performances. In practice this means that a performance is a method which would match the delegate Func<IServiceProvider, CancellationToken, Task<bool?>>, such as the following. public Task<bool?> SamplePerformance(IServiceProvider services, CancellationToken cancellationToken) { // Performance logic goes here ... } The performance method is comprised of a series of of performables, performed by one or more actors. Particularly when using Screenplay for automated testing, these performables are organised into a beginning, middle and end, corresponding with the phases declared in PerformancePhase. A performance should complete in either success or failure, as indicated by a true or false return value. Where Screenplay is being used for automated testing, a performance corresponds to a single test. In the testing framework that might be called a \"scenario\", a \"test\", a \"test case\", or a \"theory\". When using Screenplay within a testing integration, the performance corresponds very closely to the current Scenario. This interface is the representation of the scope of such a performance method in the Screenplay architecture. One instance of an object implementing this interface - \"the performance object\" - corresponds to one execution of such a method. The performance object also corresponds to the lifetime of the dependency injection scope; a new scope is created for each performance. Within a DI scope, the performance object is an injectable service. You may wish to read a diagram showing how screenplays, performances, actors and performables relate to one another. Properties NamingHierarchy Gets an ordered list of identifiers which indicate the current performance's name within an organisational hierarchy. List<IdentifierAndName> NamingHierarchy { get; } Property Value List<IdentifierAndName> Examples If the current performance is to be named Joe can take out the Trash, and it is part of a parent name, named Joe can do his chores then the first identifier in the list will be named Joe can do his chores and the second will be named Joe can take out the Trash. Remarks A Screenplay typically contains more than one performance and may contain many. It is normal to organise performances into a hierarchical structure based upon their purpose, role or relationship. The position of the current performance in that naming structure is represented by the value of this property. The ordered list of IdentifierAndName instances indicate a path from the 'root' of the hierarchy (which has no inherent name) to the current performance. Identifier/name pairs which are earlier in the collection are considered to be closer to the root, whereas latter identifier/names are branch & leaf names. In this manner, they work very similarly to .NET namespaces. The earlier in the list that a name appears, the more general it should be, representing a wider category. When using Screenplay with Integration, this hierarchy of names would typically correspond to the naming convention used by the testing framework. That might be based upon .NET namespaces, classes and test methods for a more traditional unit testing framework. Alternatively, for a BDD-style testing framework, it could be named based upon human-readable feature & scenario names. Ideally this property would be immutable after a Performance is created. Unfortunately, some testing frameworks do not expose relevant naming information about a test until after the point of execution where the Performance must be created. Thus, this property is mutable, so that it is possible to 'backfill' missing naming information after the performance has been created. Wherever possible, it is recommended to avoid updating this list of identifier/names and to only set them up when creating the performance, via ICreatesPerformance. PerformanceState Gets a value which indicates the state of the current performance. PerformanceState PerformanceState { get; } Property Value PerformanceState See Also PerformanceState"
  },
  "api/CSF.Screenplay.IPersona.html": {
    "href": "api/CSF.Screenplay.IPersona.html",
    "title": "Interface IPersona | Screenplay docs",
    "keywords": "Interface IPersona Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A persona is a factory for a commonly-used actor public interface IPersona : IHasName Inherited Members IHasName.Name Remarks In Screenplay is is recommended to use memorable actors which are widely understood and recognisable by the team. This is easier if the composition of an actor is the same across every IPerformance in which they participate. By using a separate persona implementation for each named actor, the developer can ensure consistent creation for instances of those actors. Methods GetActor(Guid) Gets the actor which is associated with the current persona Actor GetActor(Guid performanceIdentity) Parameters performanceIdentity Guid A unique identity for the currently-executing performance Returns Actor Remarks Implementors should not only create and return the actor from this method, but also configure the actor with the standard abilities associated with this persona."
  },
  "api/CSF.Screenplay.IStage.html": {
    "href": "api/CSF.Screenplay.IStage.html",
    "title": "Interface IStage | Screenplay docs",
    "keywords": "Interface IStage Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll The stage facilitates a contextual Actor who is 'in the spotlight' - a currently-active actor public interface IStage Extension Methods StageExtensions.Spotlight<TPersona>(IStage) Examples Consider a IPerformance which is based upon the following, which is described in Gherkin BDD syntax: https://cucumber.io/docs/gherkin/. Given Jack can wash dishes And Jack has filled a basin with hot water When Jack washes a dinner plate Then Jack should have one clean dinner plate This format of test is perfectly functional, but each performable item needed to be qualified with the actor's name: \"Jack\". This could be more human-readable but also more reusable from a code perspective if we had a context of a 'current' actor, who we could refer to with a pronoun. With such a concept, our gherkin could read \"he has\" or \"he washes\" and could accept any one of a variety of pronouns. Remarks The Stage is an optional but recommended component of Screenplay, useful when a IPerformance involves repeated use of an Actor. It facilitates the use of passive voice and the use of pronouns within the logic of performances without needing to frequently repeat the Name of the actor. It is often more consise and easier to understand performances when some of the steps use the passive voice. In order to do this, there must be a concept which allows us to discern \"which actor is acting at the moment\". The stage provides this via the concept of a Spotlight. Either zero or one actor may be in the spotlight at any given time. If a new actor is placed in the spotlight then the previous actor is removed from it. Spotlighting an actor facilitates performance steps which use 'the current actor' instead of a specific named actor. The lifetime of a stage instance is equal to the lifetime of the current IPerformance. An actor in the spotlight will be consistent across the lifetime of the performance but will be independent of other performances. In a Screenplay the stage is a dependency-injectable service which may be used within your performances. The stage implicitly consumes some functionality from the ICast. If Spotlight(IPersona) is used, then the Actor to put in the spotlight will implicitly be retrieved using the cast, via GetActor(IPersona). Properties Cast Gets the cast to which the current stage is linked. ICast Cast { get; } Property Value ICast Methods GetSpotlitActor() Gets the actor which is currently in the spotlight. Actor GetSpotlitActor() Returns Actor The actor who has previously been placed in the spotlight, or a null reference if there is presently no actor in the spotlight. Spotlight(Actor) Places the specified actor into the spotlight, making them 'the current actor' on this stage. void Spotlight(Actor actor) Parameters actor Actor Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the specified actor. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If the specified actor is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Exceptions ArgumentNullException If the actor is null. Spotlight(IPersona) Places an actor matching the specified persona into the spotlight, making them 'the current actor' on this stage. Actor Spotlight(IPersona persona) Parameters persona IPersona Returns Actor The actor instance which was placed into the spotlight. Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the actor derived from the persona. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If actor indicated by the persona is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. When spotlighting a persona, the actor instance is retrieved from an ICast based upon that same persona. See GetActor(IPersona) for more information. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Consider using Spotlight<TPersona>(IStage) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. Exceptions ArgumentNullException If the actor is null. TurnSpotlightOff() Removes any existing actor from the spotlight, ensuring that no actor is in the spotlight. Actor TurnSpotlightOff() Returns Actor If an actor was previously in the spotlight, and has now been removed, then this method returns that actor; otherwise it will return a null reference. Remarks If there was already no actor in the spotlight when this method is executed then it will have no effect, the spotlight will remain empty and this method will return null. See Also ICast"
  },
  "api/CSF.Screenplay.JsonToHtmlReport.IConvertsReportJsonToHtml.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.IConvertsReportJsonToHtml.html",
    "title": "Interface IConvertsReportJsonToHtml | Screenplay docs",
    "keywords": "Interface IConvertsReportJsonToHtml Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll An object which can convert a JSON Screenplay report to an HTML format. public interface IConvertsReportJsonToHtml Methods ConvertAsync(ReportConverterOptions) Converts the JSON Screenplay report data to HTML asynchronously. Task ConvertAsync(ReportConverterOptions options) Parameters options ReportConverterOptions The options for the report conversion. Returns Task A task that represents the asynchronous operation."
  },
  "api/CSF.Screenplay.JsonToHtmlReport.IGetsHtmlTemplate.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.IGetsHtmlTemplate.html",
    "title": "Interface IGetsHtmlTemplate | Screenplay docs",
    "keywords": "Interface IGetsHtmlTemplate Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll Provides functionality to read the HTML template. public interface IGetsHtmlTemplate Methods ReadTemplate() Reads the HTML template as a string. Task<string> ReadTemplate() Returns Task<string>"
  },
  "api/CSF.Screenplay.JsonToHtmlReport.Program.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.Program.html",
    "title": "Class Program | Screenplay docs",
    "keywords": "Class Program Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll The main entry point class for the JSON to HTML report converter application. public static class Program Inheritance object Program Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Main(string[]) The main entry point method for the JSON to HTML report converter application. public static void Main(string[] args) Parameters args string[] The command-line arguments. Remarks This method scaffolds the application using the Generic Host pattern, then runs that host. This method is available only when the project is built as an executable. It is unavailable for the netstandard2.0 target framework."
  },
  "api/CSF.Screenplay.JsonToHtmlReport.ReportConverter.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.ReportConverter.html",
    "title": "Class ReportConverter | Screenplay docs",
    "keywords": "Class ReportConverter Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll Provides functionality to convert JSON reports to HTML format. public class ReportConverter : IConvertsReportJsonToHtml Inheritance object ReportConverter Implements IConvertsReportJsonToHtml Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ReportConverter(IGetsHtmlTemplate) Initializes a new instance of the ReportConverter class. public ReportConverter(IGetsHtmlTemplate templateReader) Parameters templateReader IGetsHtmlTemplate The template reader used to get the HTML template. Methods ConvertAsync(ReportConverterOptions) Converts the JSON Screenplay report data to HTML asynchronously. public Task ConvertAsync(ReportConverterOptions options) Parameters options ReportConverterOptions The options for the report conversion. Returns Task A task that represents the asynchronous operation."
  },
  "api/CSF.Screenplay.JsonToHtmlReport.ReportConverterApplication.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.ReportConverterApplication.html",
    "title": "Class ReportConverterApplication | Screenplay docs",
    "keywords": "Class ReportConverterApplication Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll An application/background service that begins the JSON to HTML report conversion process. public class ReportConverterApplication : BackgroundService, IHostedService, IDisposable Inheritance object BackgroundService ReportConverterApplication Implements IHostedService IDisposable Inherited Members BackgroundService.StartAsync(CancellationToken) BackgroundService.StopAsync(CancellationToken) BackgroundService.Dispose() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ReportConverterApplication(IOptions<ReportConverterOptions>, IConvertsReportJsonToHtml) Initializes a new instance of the ReportConverterApplication class. public ReportConverterApplication(IOptions<ReportConverterOptions> options, IConvertsReportJsonToHtml reportConverter) Parameters options IOptions<ReportConverterOptions> The options for performing the conversion. reportConverter IConvertsReportJsonToHtml The report converter instance to use for conversion. Methods ExecuteAsync(CancellationToken) Executes the background service operation. protected override Task ExecuteAsync(CancellationToken stoppingToken) Parameters stoppingToken CancellationToken A token that can be used to stop the operation. Returns Task A task that represents the asynchronous operation."
  },
  "api/CSF.Screenplay.JsonToHtmlReport.ReportConverterOptions.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.ReportConverterOptions.html",
    "title": "Class ReportConverterOptions | Screenplay docs",
    "keywords": "Class ReportConverterOptions Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll Options for converting a JSON report to HTML. public class ReportConverterOptions Inheritance object ReportConverterOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties OutputPath Gets or sets the file system path where the HTML report will be saved. public string OutputPath { get; set; } Property Value string ReportPath Gets or sets the file system path to the JSON report which is to be converted to HTML. public string ReportPath { get; set; } Property Value string"
  },
  "api/CSF.Screenplay.JsonToHtmlReport.ServiceRegistrations.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.ServiceRegistrations.html",
    "title": "Class ServiceRegistrations | Screenplay docs",
    "keywords": "Class ServiceRegistrations Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll Provides methods to register services for the JsonToHtmlReport application (or library). public static class ServiceRegistrations Inheritance object ServiceRegistrations Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This type is consumed by the JSON to HTML report converter when it is built as an application, but it may also be used when consuming this project as a library, for integrating it into other solutions. Methods RegisterServices(IServiceCollection) Registers the services required for the JsonToHtmlReport application (or library). public static void RegisterServices(IServiceCollection services) Parameters services IServiceCollection The service collection to which the services will be added."
  },
  "api/CSF.Screenplay.JsonToHtmlReport.TemplateReader.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.TemplateReader.html",
    "title": "Class TemplateReader | Screenplay docs",
    "keywords": "Class TemplateReader Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll Provides functionality to read the HTML template which is embedded as a resource into the current assembly. public class TemplateReader : IGetsHtmlTemplate Inheritance object TemplateReader Implements IGetsHtmlTemplate Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ReadTemplate() Reads the HTML template which is embedded as a resource into the current assembly. public Task<string> ReadTemplate() Returns Task<string> The HTML template as a string."
  },
  "api/CSF.Screenplay.JsonToHtmlReport.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.html",
    "title": "Namespace CSF.Screenplay.JsonToHtmlReport | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.JsonToHtmlReport Classes Program The main entry point class for the JSON to HTML report converter application. ReportConverter Provides functionality to convert JSON reports to HTML format. ReportConverterApplication An application/background service that begins the JSON to HTML report conversion process. ReportConverterOptions Options for converting a JSON report to HTML. ServiceRegistrations Provides methods to register services for the JsonToHtmlReport application (or library). TemplateReader Provides functionality to read the HTML template which is embedded as a resource into the current assembly. Interfaces IConvertsReportJsonToHtml An object which can convert a JSON Screenplay report to an HTML format. IGetsHtmlTemplate Provides functionality to read the HTML template."
  },
  "api/CSF.Screenplay.Performables.IGetsPerformable.html": {
    "href": "api/CSF.Screenplay.Performables.IGetsPerformable.html",
    "title": "Interface IGetsPerformable | Screenplay docs",
    "keywords": "Interface IGetsPerformable Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An object which can get an IPerformable instance, such as a performable builder. public interface IGetsPerformable Methods GetPerformable() Gets the performable object from the current instance. IPerformable GetPerformable() Returns IPerformable A performable object"
  },
  "api/CSF.Screenplay.Performables.IGetsPerformableWithResult-1.html": {
    "href": "api/CSF.Screenplay.Performables.IGetsPerformableWithResult-1.html",
    "title": "Interface IGetsPerformableWithResult<TResult> | Screenplay docs",
    "keywords": "Interface IGetsPerformableWithResult<TResult> Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An object which can get an IPerformableWithResult<TResult> instance, such as a performable builder. public interface IGetsPerformableWithResult<TResult> Type Parameters TResult Methods GetPerformable() Gets the performable object from the current instance. IPerformableWithResult<TResult> GetPerformable() Returns IPerformableWithResult<TResult> A performable object"
  },
  "api/CSF.Screenplay.Performables.IGetsPerformableWithResult.html": {
    "href": "api/CSF.Screenplay.Performables.IGetsPerformableWithResult.html",
    "title": "Interface IGetsPerformableWithResult | Screenplay docs",
    "keywords": "Interface IGetsPerformableWithResult Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An object which can get a non-generic IPerformableWithResult instance, such as a performable builder. public interface IGetsPerformableWithResult Methods GetPerformable() Gets the performable object from the current instance. IPerformableWithResult GetPerformable() Returns IPerformableWithResult A performable object"
  },
  "api/CSF.Screenplay.Performables.IProvidesTimeSpan.html": {
    "href": "api/CSF.Screenplay.Performables.IProvidesTimeSpan.html",
    "title": "Interface IProvidesTimeSpan | Screenplay docs",
    "keywords": "Interface IProvidesTimeSpan Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll A type which may provide a TimeSpan. public interface IProvidesTimeSpan Remarks Many performables make use of time; this interface provides a common abstraction for objects that provide time spans. Methods GetTimeSpan() Gets the TimeSpan which is exposed by the current instance. TimeSpan GetTimeSpan() Returns TimeSpan The time span See Also TimeSpanBuilder<TOtherBuilder> TimeSpanBuilder"
  },
  "api/CSF.Screenplay.Performables.PerformableException.html": {
    "href": "api/CSF.Screenplay.Performables.PerformableException.html",
    "title": "Class PerformableException | Screenplay docs",
    "keywords": "Class PerformableException Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll Thrown when a Performable fails with an unexpected exception. public class PerformableException : Exception, ISerializable Inheritance object Exception PerformableException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Remarks This exception type is rethrown from the Actor when they are executing the performable, in order to provide further context about where the error has occurred. Constructors PerformableException() Initialises a new instance of PerformableException. public PerformableException() PerformableException(string) Initialises a new instance of PerformableException. public PerformableException(string message) Parameters message string The exception message PerformableException(string, Exception) Initialises a new instance of PerformableException. public PerformableException(string message, Exception inner) Parameters message string The exception message inner Exception The inner exception Properties Performable Gets or sets a reference to the Performable object which was the cause of the exception. public object Performable { get; set; } Property Value object"
  },
  "api/CSF.Screenplay.Performables.ReadTheStopwatch.html": {
    "href": "api/CSF.Screenplay.Performables.ReadTheStopwatch.html",
    "title": "Class ReadTheStopwatch | Screenplay docs",
    "keywords": "Class ReadTheStopwatch Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An action which reads the current value of the stopwatch. public class ReadTheStopwatch : IPerformableWithResult<TimeSpan>, ICanReport Inheritance object ReadTheStopwatch Implements IPerformableWithResult<TimeSpan> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This performable requires the actor has the ability UseAStopwatch. Use this performable via the builder method ReadTheStopwatch(). Methods GetReportFragment(IHasName, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(IHasName actor, IFormatsReportFragment formatter) Parameters actor IHasName An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<TimeSpan> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TimeSpan> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Performables.ResetTheStopwatch.html": {
    "href": "api/CSF.Screenplay.Performables.ResetTheStopwatch.html",
    "title": "Class ResetTheStopwatch | Screenplay docs",
    "keywords": "Class ResetTheStopwatch Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An action which resets the stopwatch. public class ResetTheStopwatch : IPerformable, ICanReport Inheritance object ResetTheStopwatch Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This performable requires the actor has the ability UseAStopwatch. Use this performable via the builder method ResetTheStopwatch(). Methods GetReportFragment(IHasName, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(IHasName actor, IFormatsReportFragment formatter) Parameters actor IHasName An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Performables.StartTheStopwatch.html": {
    "href": "api/CSF.Screenplay.Performables.StartTheStopwatch.html",
    "title": "Class StartTheStopwatch | Screenplay docs",
    "keywords": "Class StartTheStopwatch Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An action which starts the stopwatch. public class StartTheStopwatch : IPerformable, ICanReport Inheritance object StartTheStopwatch Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This performable requires the actor has the ability UseAStopwatch. Use this performable via the builder method StartTheStopwatch(). Methods GetReportFragment(IHasName, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(IHasName actor, IFormatsReportFragment formatter) Parameters actor IHasName An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Performables.StopTheStopwatch.html": {
    "href": "api/CSF.Screenplay.Performables.StopTheStopwatch.html",
    "title": "Class StopTheStopwatch | Screenplay docs",
    "keywords": "Class StopTheStopwatch Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An action which stops the stopwatch. public class StopTheStopwatch : IPerformable, ICanReport Inheritance object StopTheStopwatch Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This performable requires the actor has the ability UseAStopwatch. Use this performable via the builder method StopTheStopwatch(). Methods GetReportFragment(IHasName, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(IHasName actor, IFormatsReportFragment formatter) Parameters actor IHasName An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Performables.StopwatchBuilder.html": {
    "href": "api/CSF.Screenplay.Performables.StopwatchBuilder.html",
    "title": "Class StopwatchBuilder | Screenplay docs",
    "keywords": "Class StopwatchBuilder Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll A builder for actions relating to the UseAStopwatch ability. public static class StopwatchBuilder Inheritance object StopwatchBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks When using this class it is recommended to include using static CSF.Screenplay.Performables.StopwatchBuilder; in the source file which uses it. This will allow you use the method names in this class in a more human-readable fashion. The actions and the question exposed by this builder allow an actor to accurately track and measure time elapsed during a Performance. Methods ReadTheStopwatch() Gets a performable which reads the stopwatch. public static ReadTheStopwatch ReadTheStopwatch() Returns ReadTheStopwatch Remarks Use of this performable requires the actor has the UseAStopwatch ability. ResetTheStopwatch() Gets a performable which resets the stopwatch to zero. public static ResetTheStopwatch ResetTheStopwatch() Returns ResetTheStopwatch Remarks Use of this performable requires the actor has the UseAStopwatch ability. StartTheStopwatch() Gets a performable which starts the stopwatch. public static StartTheStopwatch StartTheStopwatch() Returns StartTheStopwatch Remarks Use of this performable requires the actor has the UseAStopwatch ability. StopTheStopwatch() Gets a performable which stops the stopwatch. public static StopTheStopwatch StopTheStopwatch() Returns StopTheStopwatch Remarks Use of this performable requires the actor has the UseAStopwatch ability."
  },
  "api/CSF.Screenplay.Performables.TimeSpanBuilder-1.html": {
    "href": "api/CSF.Screenplay.Performables.TimeSpanBuilder-1.html",
    "title": "Class TimeSpanBuilder<TOtherBuilder> | Screenplay docs",
    "keywords": "Class TimeSpanBuilder<TOtherBuilder> Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll A supplementary builder type which enables the collection of TimeSpan instances. public class TimeSpanBuilder<TOtherBuilder> : IProvidesTimeSpan where TOtherBuilder : class Type Parameters TOtherBuilder The builder type for which this builder will supplement Inheritance object TimeSpanBuilder<TOtherBuilder> Implements IProvidesTimeSpan Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples The example below shows how the time span builder is intended to be used. It is consumed from within another builder, which needs to include a developer-configurable time span. See the documentation for writing performable builders for more information about the makeup of the EatLunchPerformableBuilder. public class EatLunchPerformableBuilder : IGetsPerformable { IProvidesTimeSpan? timeSpanBuilder; protected string? FoodName { get; init; } IPerformable IGetsPerformable.GetPerformable() => new EatLunch(FoodName, timeSpanBuilder?.GetTimeSpan() ?? TimeSpan.Zero); public TimeSpanBuilder<EatLunchPerformableBuilder> For(int howMany) { var builder = TimeSpanBuilder.Create(this, howMany); timeSpanBuilder = builder; return builder; } public static EatLunchPerformableBuilder Eat(string foodName) => new EatLunchPerformableBuilder() { FoodName = foodName }; } The sample builder above would be used to build an instance of a (fictitious) EachLunch performable, which derives from IPerformable. The fictitious performable requires two parameters; the name of the food being eaten for lunch and how long the lunch break lasts. The time span builder is used for that second parameter. A consumer which uses this builder in an IPerformance, or another performable, might consume it as follows. using static EatLunchPerformableBuilder; // ... actor.PerformAsync(Eat(\"Sandwiches\").For(30).Minutes(), cancellationToken); A note for developers with access to the source code for this library. There is a small integration test which sets up and exercises the example above; it is named TimeSpanBuilderTests. Remarks When consuming Performable objects it is recommended to use the builder pattern to create them. A commonly-used 'parameter' which may be specified in builders is 'an amount of time', IE a TimeSpan. This builder is intended to supplement another builder, for the purpose of specifying an amount of time. The 'other' builder is passed as a constructor parameter to this builder, along with an absolute amount. The consumer should then execute one of the methods of this type, which selects the unit of time and thus determines the TimeSpan value. The method which determines the units then returns that other builder instance, allowing the building process to continue with that other builder. Whilst it is possible to create instances of this type via its public constructor, it is often easier to create instances using the staticTimeSpanBuilder class. Constructors TimeSpanBuilder(TOtherBuilder, int) Initializes a new instance of TimeSpanBuilder<TOtherBuilder>. public TimeSpanBuilder(TOtherBuilder otherBuilder, int value) Parameters otherBuilder TOtherBuilder The other builder which shall be supplemented by this value int The absolute value of time, but without units Exceptions ArgumentNullException If otherBuilder is null. ArgumentOutOfRangeException If value is less than zero. Methods Days() Configures the contained time span to be measured in days, then returns the contained builder. public TOtherBuilder Days() Returns TOtherBuilder Hours() Configures the contained time span to be measured in hours, then returns the contained builder. public TOtherBuilder Hours() Returns TOtherBuilder Milliseconds() Configures the contained time span to be measured in milliseconds, then returns the contained builder. public TOtherBuilder Milliseconds() Returns TOtherBuilder Minutes() Configures the contained time span to be measured in minutes, then returns the contained builder. public TOtherBuilder Minutes() Returns TOtherBuilder Seconds() Configures the contained time span to be measured in seconds, then returns the contained builder. public TOtherBuilder Seconds() Returns TOtherBuilder See Also Create<TOtherBuilder>(TOtherBuilder, int)"
  },
  "api/CSF.Screenplay.Performables.TimeSpanBuilder.html": {
    "href": "api/CSF.Screenplay.Performables.TimeSpanBuilder.html",
    "title": "Class TimeSpanBuilder | Screenplay docs",
    "keywords": "Class TimeSpanBuilder Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll Static helper class for creating instances of TimeSpanBuilder<TOtherBuilder>. public static class TimeSpanBuilder Inheritance object TimeSpanBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks See the documentation for TimeSpanBuilder<TOtherBuilder> for more information about how this class is to be used. Methods Create<TOtherBuilder>(TOtherBuilder, int) Creates and returns a TimeSpanBuilder<TOtherBuilder> which can hold time span information and then continue the building process associated with the other builder. public static TimeSpanBuilder<TOtherBuilder> Create<TOtherBuilder>(TOtherBuilder otherBuilder, int value) where TOtherBuilder : class Parameters otherBuilder TOtherBuilder An instance of another performable builder value int The absolute time span value, without any units Returns TimeSpanBuilder<TOtherBuilder> Type Parameters TOtherBuilder The type of the other performable builder Remarks See the documentation for TimeSpanBuilder<TOtherBuilder> for more information about how this method is to be used."
  },
  "api/CSF.Screenplay.Performables.html": {
    "href": "api/CSF.Screenplay.Performables.html",
    "title": "Namespace CSF.Screenplay.Performables | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.Performables Classes PerformableException Thrown when a Performable fails with an unexpected exception. ReadTheStopwatch An action which reads the current value of the stopwatch. ResetTheStopwatch An action which resets the stopwatch. StartTheStopwatch An action which starts the stopwatch. StopTheStopwatch An action which stops the stopwatch. StopwatchBuilder A builder for actions relating to the UseAStopwatch ability. TimeSpanBuilder Static helper class for creating instances of TimeSpanBuilder<TOtherBuilder>. TimeSpanBuilder<TOtherBuilder> A supplementary builder type which enables the collection of TimeSpan instances. Interfaces IGetsPerformable An object which can get an IPerformable instance, such as a performable builder. IGetsPerformableWithResult An object which can get a non-generic IPerformableWithResult instance, such as a performable builder. IGetsPerformableWithResult<TResult> An object which can get an IPerformableWithResult<TResult> instance, such as a performable builder. IProvidesTimeSpan A type which may provide a TimeSpan."
  },
  "api/CSF.Screenplay.Performance.html": {
    "href": "api/CSF.Screenplay.Performance.html",
    "title": "Class Performance | Screenplay docs",
    "keywords": "Class Performance Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Primary implementation type of IPerformance. public sealed class Performance : IPerformance, IHasPerformanceIdentity, IHasServiceProvider, IDisposable, IBeginsAndEndsPerformance, IEquatable<Performance> Inheritance object Performance Implements IPerformance IHasPerformanceIdentity IHasServiceProvider IDisposable IBeginsAndEndsPerformance IEquatable<Performance> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Performance(IServiceProvider, IList<IdentifierAndName>, Guid) Initialises a new instance of Performance public Performance(IServiceProvider serviceProvider, IList<IdentifierAndName> namingHierarchy = null, Guid performanceIdentity = default) Parameters serviceProvider IServiceProvider A dependency injection service provider namingHierarchy IList<IdentifierAndName> A collection of identifiers and names providing the hierarchical name of this performance; see NamingHierarchy for more information. performanceIdentity Guid A unique identifier for the performance; if omitted (equal to Empty) then a new Guid will be generated as the identity for this performance Exceptions ArgumentNullException If serviceProvider is null Properties NamingHierarchy Gets an ordered list of identifiers which indicate the current performance's name within an organisational hierarchy. public List<IdentifierAndName> NamingHierarchy { get; } Property Value List<IdentifierAndName> Examples If the current performance is to be named Joe can take out the Trash, and it is part of a parent name, named Joe can do his chores then the first identifier in the list will be named Joe can do his chores and the second will be named Joe can take out the Trash. Remarks A Screenplay typically contains more than one performance and may contain many. It is normal to organise performances into a hierarchical structure based upon their purpose, role or relationship. The position of the current performance in that naming structure is represented by the value of this property. The ordered list of IdentifierAndName instances indicate a path from the 'root' of the hierarchy (which has no inherent name) to the current performance. Identifier/name pairs which are earlier in the collection are considered to be closer to the root, whereas latter identifier/names are branch & leaf names. In this manner, they work very similarly to .NET namespaces. The earlier in the list that a name appears, the more general it should be, representing a wider category. When using Screenplay with Integration, this hierarchy of names would typically correspond to the naming convention used by the testing framework. That might be based upon .NET namespaces, classes and test methods for a more traditional unit testing framework. Alternatively, for a BDD-style testing framework, it could be named based upon human-readable feature & scenario names. Ideally this property would be immutable after a Performance is created. Unfortunately, some testing frameworks do not expose relevant naming information about a test until after the point of execution where the Performance must be created. Thus, this property is mutable, so that it is possible to 'backfill' missing naming information after the performance has been created. Wherever possible, it is recommended to avoid updating this list of identifier/names and to only set them up when creating the performance, via ICreatesPerformance. PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. PerformanceState Gets a value which indicates the state of the current performance. public PerformanceState PerformanceState { get; } Property Value PerformanceState See Also PerformanceState ServiceProvider Gets a service provider/resolver instance associated with this object. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods BeginPerformance() Begins the performance public void BeginPerformance() Dispose() public void Dispose() Equals(Performance) public bool Equals(Performance other) Parameters other Performance Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool FinishPerformance(bool?) Finishes the performance with a value indicating whether or not it was a success public void FinishPerformance(bool? success) Parameters success bool? If true then the performance is to be considered a success; if false then a failure. A value of null indicates that the performance did not succeed but should not be considered a failure either. GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/CSF.Screenplay.PerformanceStarter.html": {
    "href": "api/CSF.Screenplay.PerformanceStarter.html",
    "title": "Class PerformanceStarter | Screenplay docs",
    "keywords": "Class PerformanceStarter Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Helper class for beginning the functionality of a Screenplay IPerformance from your own logic, using a fluent interface public static class PerformanceStarter Inheritance object PerformanceStarter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples Here is an example of the recommended technique for consuming this class' functionality. using static CSF.Screenplay.ScreenplayStarter; // ... then in your top-level performance logic: await Given(joe).WasAbleTo(takeOutTheTrash); Remarks This class is a convenience to aid in the readability of top-level performance logic, providing a fluent entry-point into the performance methods. Each of the methods upon this class corresponds to a PerformancePhase within the overall performance. By using these methods, the actor is down-cast to the appropriate interface that is specific to that phase, which activates appropriate functionality of the fluent interface. It is recommended to consume this functionality in your own logic via the using static directive, so that you may use the Given(Actor), When(Actor) & Then(Actor) methods stand-alone. Do not use these methods in your own Performable implementations. Doing so would reduce their reusability; use these methods only in your top-level performance logic. Any performables which are executed by one of these three methods automatically inherits the performance phase from which its top-level performable was started. Methods Given(Actor) Returns the actor instance, down-cast to ICanPerformGiven, activating the fluent interface for the Given phase of the performance. public static ICanPerformGiven Given(Actor actor) Parameters actor Actor The actor. Returns ICanPerformGiven Then(Actor) Returns the actor instance, down-cast to ICanPerformThen, activating the fluent interface for the Then phase of the performance. public static ICanPerformThen Then(Actor actor) Parameters actor Actor The actor. Returns ICanPerformThen When(Actor) Returns the actor instance, down-cast to ICanPerformWhen, activating the fluent interface for the When phase of the performance. public static ICanPerformWhen When(Actor actor) Parameters actor Actor The actor. Returns ICanPerformWhen"
  },
  "api/CSF.Screenplay.Performances.IBeginsAndEndsPerformance.html": {
    "href": "api/CSF.Screenplay.Performances.IBeginsAndEndsPerformance.html",
    "title": "Interface IBeginsAndEndsPerformance | Screenplay docs",
    "keywords": "Interface IBeginsAndEndsPerformance Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll An object which controls the beginning and ending of a performance public interface IBeginsAndEndsPerformance Methods BeginPerformance() Begins the performance void BeginPerformance() FinishPerformance(bool?) Finishes the performance with a value indicating whether or not it was a success void FinishPerformance(bool? success) Parameters success bool? If true then the performance is to be considered a success; if false then a failure. A value of null indicates that the performance did not succeed but should not be considered a failure either."
  },
  "api/CSF.Screenplay.Performances.ICreatesPerformance.html": {
    "href": "api/CSF.Screenplay.Performances.ICreatesPerformance.html",
    "title": "Interface ICreatesPerformance | Screenplay docs",
    "keywords": "Interface ICreatesPerformance Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll An object which creates instances of IPerformance; a factory service. public interface ICreatesPerformance Methods CreatePerformance() Creates a new performance instance. IPerformance CreatePerformance() Returns IPerformance A new performance instance"
  },
  "api/CSF.Screenplay.Performances.IHasPerformanceEvents.html": {
    "href": "api/CSF.Screenplay.Performances.IHasPerformanceEvents.html",
    "title": "Interface IHasPerformanceEvents | Screenplay docs",
    "keywords": "Interface IHasPerformanceEvents Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll An object which has events which are significant to the progress of a Screenplay. public interface IHasPerformanceEvents Remarks This object is used as an event publisher, such that events which originate from many separate objects may be aggregated to a single point of contact. This way, consumers of those events have only a single object to which they need subscribe. There should only be a single instance of an object which implements this interface, for the lifetime of a Screenplay. This type is closely related to IRelaysPerformanceEvents. This is the event publisher and IRelaysPerformanceEvents is event sink which collects them. Despite this, their APIs are not symmetrical, as many of the events published by this type are derived by subscribing to an Actor instance from the event sink. Events ActorCreated Occurs when a new Actor is created and added to the IPerformance. event EventHandler<ActorEventArgs> ActorCreated Event Type EventHandler<ActorEventArgs> ActorSpotlit Occurs when an Actor is placed into the Spotlight of an IStage. event EventHandler<ActorEventArgs> ActorSpotlit Event Type EventHandler<ActorEventArgs> BeginPerformable Occurs when an Actor begins the execution of a performable object. event EventHandler<PerformableEventArgs> BeginPerformable Event Type EventHandler<PerformableEventArgs> EndPerformable Occurs when an Actor ends the execution of a performable object. event EventHandler<PerformableEventArgs> EndPerformable Event Type EventHandler<PerformableEventArgs> GainedAbility Occurs when an Actor gains a new ability. event EventHandler<GainAbilityEventArgs> GainedAbility Event Type EventHandler<GainAbilityEventArgs> PerformableFailed Occurs when a performable object fails with an exception. event EventHandler<PerformableFailureEventArgs> PerformableFailed Event Type EventHandler<PerformableFailureEventArgs> PerformableResult Occurs when an Actor receives a result from a perfperformable objectrmance. event EventHandler<PerformableResultEventArgs> PerformableResult Event Type EventHandler<PerformableResultEventArgs> PerformanceBegun Occurs when a IPerformance begins executing. event EventHandler<PerformanceEventArgs> PerformanceBegun Event Type EventHandler<PerformanceEventArgs> PerformanceFinished Occurs when a IPerformance has finished executing. event EventHandler<PerformanceFinishedEventArgs> PerformanceFinished Event Type EventHandler<PerformanceFinishedEventArgs> RecordAsset Occurs when an actor records the presence of a new file asset. event EventHandler<PerformableAssetEventArgs> RecordAsset Event Type EventHandler<PerformableAssetEventArgs> ScreenplayEnded Occurs when a Screenplay has ended. event EventHandler ScreenplayEnded Event Type EventHandler ScreenplayStarted Occurs when a Screenplay starts. event EventHandler ScreenplayStarted Event Type EventHandler SpotlightTurnedOff Occurs when the Spotlight of an IStage is 'turned off'; the Actor who is currently spotlit is removed without being replaced. event EventHandler<PerformanceScopeEventArgs> SpotlightTurnedOff Event Type EventHandler<PerformanceScopeEventArgs> See Also IRelaysPerformanceEvents"
  },
  "api/CSF.Screenplay.Performances.IRelaysPerformanceEvents.html": {
    "href": "api/CSF.Screenplay.Performances.IRelaysPerformanceEvents.html",
    "title": "Interface IRelaysPerformanceEvents | Screenplay docs",
    "keywords": "Interface IRelaysPerformanceEvents Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll An object which can relay events that relate to a IPerformance public interface IRelaysPerformanceEvents Remarks This object is used as an event sink; a single point of contact to which many objects may send events. This allows event consumers to receive events from many origins by subscribing to only a single object. There should only be a single instance of an object which implements this interface, for the lifetime of a Screenplay. This type is closely related to IHasPerformanceEvents. This is the event sink and IHasPerformanceEvents is the publisher of those events. Despite this, their APIs are not symmetrical, as many of the events published are derived by subscribing to an Actor instance. Methods InvokeActorCreated(Actor) Invokes an event indicating that a new Actor has been created and added to the IPerformance. void InvokeActorCreated(Actor actor) Parameters actor Actor The actor InvokeActorSpotlit(Actor) Invokes an event indicating that an Actor has been placed into the Spotlight of an IStage. void InvokeActorSpotlit(Actor actor) Parameters actor Actor The actor InvokeGainedAbility(Actor, object) Invokes an event indicating that a new Actor has gained an ability. void InvokeGainedAbility(Actor actor, object ability) Parameters actor Actor The actor ability object The ability that the actor has gained. Remarks Use this method only when an actor gains one or more abilities before the the SubscribeTo(Actor) method has been used to subscribe to the actor. Once the actor has been subscribed-to by an implementation of this instance, their newly-added abilities will automatically be captured. In some circumstances where the actor is fully created and has their abilities granted BEFORE there has been an opportunity to subscribe to them, then this method is required to retrospectively trigger the abilitiy-granted event. This is applicable for actors who are created by an IPersona, which might grant the actors one or more abilities immediately, as part of their creation. InvokePerformanceBegun(Guid, IList<IdentifierAndName>) Invokes an event indicating that a IPerformance has begun. void InvokePerformanceBegun(Guid performanceIdentity, IList<IdentifierAndName> namingHierarchy) Parameters performanceIdentity Guid The performance identity namingHierarchy IList<IdentifierAndName> The performance's hierarchical name InvokePerformanceFinished(Guid, IList<IdentifierAndName>, bool?) Invokes an event indicating that a IPerformance has finished. void InvokePerformanceFinished(Guid performanceIdentity, IList<IdentifierAndName> namingHierarchy, bool? success) Parameters performanceIdentity Guid The performance identity namingHierarchy IList<IdentifierAndName> The performance's hierarchical name success bool? A value indicating whether or not the performance was a success InvokeScreenplayEnded() Invokes an event indicating that a Screenplay has ended. void InvokeScreenplayEnded() InvokeScreenplayStarted() Invokes an event indicating that a Screenplay has started. void InvokeScreenplayStarted() InvokeSpotlightTurnedOff(Guid) Invokes an event indicating that the Spotlight of the IStage has been 'turned off'. void InvokeSpotlightTurnedOff(Guid performanceIdentity) Parameters performanceIdentity Guid A unique identifier for the current IPerformance. SubscribeTo(Actor) Subscribes to (and relays) events from the specified actor. void SubscribeTo(Actor actor) Parameters actor Actor The actor to which this relay should subscribe. UnsubscribeFrom(Actor) Unsubscribes from events from the specified actor. void UnsubscribeFrom(Actor actor) Parameters actor Actor The actor from which this relay should unsubscribe. Remarks This method is typically used when the actor instance is about to be disposed, such as at the end of a IPerformance. UnsubscribeFromAllActors(Guid) Unsubscribes from all of the events for all of the actors who are part of the the IPerformance, indicated by its identity. void UnsubscribeFromAllActors(Guid performanceIdentity) Parameters performanceIdentity Guid The identity of a performance. Remarks Using this method is equivalent to calling UnsubscribeFrom(Actor) for every Actor which is participating in the specified performance. Use this method when ending a performance, as a convenience to unsubscribe from all of its actors at once. See Also IHasPerformanceEvents"
  },
  "api/CSF.Screenplay.Performances.IdentifierAndName.html": {
    "href": "api/CSF.Screenplay.Performances.IdentifierAndName.html",
    "title": "Class IdentifierAndName | Screenplay docs",
    "keywords": "Class IdentifierAndName Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll A model which indicates a unique identifier and a corresponding human-readable name. public sealed class IdentifierAndName : IEquatable<IdentifierAndName>, IHasName Inheritance object IdentifierAndName Implements IEquatable<IdentifierAndName> IHasName Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors IdentifierAndName(string, string, bool) Initialises a new instance of IdentifierAndName public IdentifierAndName(string identifier, string name = null, bool wasIdentifierAutoGenerated = false) Parameters identifier string The identifier for this item, which might not be human-readable name string A human-readable name for this item wasIdentifierAutoGenerated bool A value that indicates whether or not identifier is an auto-generated value Exceptions ArgumentNullException If identifier is null Properties Identifier Gets the identifier for the current item public string Identifier { get; } Property Value string Remarks The identifier for an item might not be a human-readable value. It is required to uniquely identify the current item, however. Name Gets a human-readable name for the current item public string Name { get; } Property Value string Remarks The human-readable name in this context is not mandatory, and so this property might return a null reference if no name was specified. WasIdentifierAutoGenerated Gets a value indicating whether or not the Identifier is an automatically-generated value or not. public bool WasIdentifierAutoGenerated { get; } Property Value bool Remarks Some integrations with Screenplay do not provide a suitable unique identifier for this position. In that case, because a unique identifier is required, Screenplay generates a unique identifier (the string representation of a GUID) automatically and uses it as the Identifier. Obviously, if that is the case then the identifier will have no meaning or correspondence to anything in the logic consuming Screenplay. This property is used to indicate when this is the case; if it is true then the Identifier was randomly-generated by Screenplay. Methods Equals(IdentifierAndName) public bool Equals(IdentifierAndName other) Parameters other IdentifierAndName Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string"
  },
  "api/CSF.Screenplay.Performances.PerformanceEventArgs.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceEventArgs.html",
    "title": "Class PerformanceEventArgs | Screenplay docs",
    "keywords": "Class PerformanceEventArgs Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to a scope of a IPerformance. public class PerformanceEventArgs : PerformanceScopeEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs PerformanceEventArgs Implements IHasPerformanceIdentity Derived PerformanceFinishedEventArgs Inherited Members PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformanceEventArgs(Guid, IReadOnlyList<IdentifierAndName>) Initialises a new instance of PerformanceEventArgs public PerformanceEventArgs(Guid performanceIdentity, IReadOnlyList<IdentifierAndName> namingHierarchy) Parameters performanceIdentity Guid The performance identity namingHierarchy IReadOnlyList<IdentifierAndName> The screenplay naming hierarchy Exceptions ArgumentNullException If the scenario hierarchy is null Properties NamingHierarchy Gets an ordered list of identifiers which indicate the IPerformance's name within an organisational hierarchy. public IReadOnlyList<IdentifierAndName> NamingHierarchy { get; } Property Value IReadOnlyList<IdentifierAndName> Remarks This hierarchical name has the exact same meaning and corresponds directly to NamingHierarchy. See Also IPerformance NamingHierarchy See Also IPerformance PerformanceScopeEventArgs"
  },
  "api/CSF.Screenplay.Performances.PerformanceEventBus.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceEventBus.html",
    "title": "Class PerformanceEventBus | Screenplay docs",
    "keywords": "Class PerformanceEventBus Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.dll Implementation of an event bus for performance-related events. public class PerformanceEventBus : IHasPerformanceEvents, IRelaysPerformanceEvents Inheritance object PerformanceEventBus Implements IHasPerformanceEvents IRelaysPerformanceEvents Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This object should be used as a singleton across the lifetime of a Screenplay. As an event bus object, it is both a subscriber (a sink) which can receive events. It is also a publisher, which emits events. The purpose of this object is to aggregate events from many instances of Performance and Actor over the duration/lifetime of the Screenplay. This way, consumers have only a single object to which they should subscribe in order to receive those events. As you will see from the API of this object, the implementations of IHasPerformanceEvents and IRelaysPerformanceEvents are not symmetrical. Many events are published by subscribing to the events upon an Actor. Methods InvokeActorCreated(Actor) Invokes an event indicating that a new Actor has been created and added to the IPerformance. public void InvokeActorCreated(Actor actor) Parameters actor Actor The actor InvokeActorSpotlit(Actor) Invokes an event indicating that an Actor has been placed into the Spotlight of an IStage. public void InvokeActorSpotlit(Actor actor) Parameters actor Actor The actor InvokeGainedAbility(Actor, object) Invokes an event indicating that a new Actor has gained an ability. public void InvokeGainedAbility(Actor actor, object ability) Parameters actor Actor The actor ability object The ability that the actor has gained. Remarks Use this method only when an actor gains one or more abilities before the the SubscribeTo(Actor) method has been used to subscribe to the actor. Once the actor has been subscribed-to by an implementation of this instance, their newly-added abilities will automatically be captured. In some circumstances where the actor is fully created and has their abilities granted BEFORE there has been an opportunity to subscribe to them, then this method is required to retrospectively trigger the abilitiy-granted event. This is applicable for actors who are created by an IPersona, which might grant the actors one or more abilities immediately, as part of their creation. InvokePerformanceBegun(Guid, IList<IdentifierAndName>) Invokes an event indicating that a IPerformance has begun. public void InvokePerformanceBegun(Guid performanceIdentity, IList<IdentifierAndName> namingHierarchy) Parameters performanceIdentity Guid The performance identity namingHierarchy IList<IdentifierAndName> The performance's hierarchical name InvokePerformanceFinished(Guid, IList<IdentifierAndName>, bool?) Invokes an event indicating that a IPerformance has finished. public void InvokePerformanceFinished(Guid performanceIdentity, IList<IdentifierAndName> namingHierarchy, bool? success) Parameters performanceIdentity Guid The performance identity namingHierarchy IList<IdentifierAndName> The performance's hierarchical name success bool? A value indicating whether or not the performance was a success InvokeScreenplayEnded() Invokes an event indicating that a Screenplay has ended. public void InvokeScreenplayEnded() InvokeScreenplayStarted() Invokes an event indicating that a Screenplay has started. public void InvokeScreenplayStarted() InvokeSpotlightTurnedOff(Guid) Invokes an event indicating that the Spotlight of the IStage has been 'turned off'. public void InvokeSpotlightTurnedOff(Guid performanceIdentity) Parameters performanceIdentity Guid A unique identifier for the current IPerformance. SubscribeTo(Actor) Subscribes to (and relays) events from the specified actor. public void SubscribeTo(Actor actor) Parameters actor Actor The actor to which this relay should subscribe. UnsubscribeFrom(Actor) Unsubscribes from events from the specified actor. public void UnsubscribeFrom(Actor actor) Parameters actor Actor The actor from which this relay should unsubscribe. Remarks This method is typically used when the actor instance is about to be disposed, such as at the end of a IPerformance. UnsubscribeFromAllActors(Guid) Unsubscribes from all of the events for all of the actors who are part of the the IPerformance, indicated by its identity. public void UnsubscribeFromAllActors(Guid performanceIdentity) Parameters performanceIdentity Guid The identity of a performance. Remarks Using this method is equivalent to calling UnsubscribeFrom(Actor) for every Actor which is participating in the specified performance. Use this method when ending a performance, as a convenience to unsubscribe from all of its actors at once. Events ActorCreated Occurs when a new Actor is created and added to the IPerformance. public event EventHandler<ActorEventArgs> ActorCreated Event Type EventHandler<ActorEventArgs> ActorSpotlit Occurs when an Actor is placed into the Spotlight of an IStage. public event EventHandler<ActorEventArgs> ActorSpotlit Event Type EventHandler<ActorEventArgs> BeginPerformable Occurs when an Actor begins the execution of a performable object. public event EventHandler<PerformableEventArgs> BeginPerformable Event Type EventHandler<PerformableEventArgs> EndPerformable Occurs when an Actor ends the execution of a performable object. public event EventHandler<PerformableEventArgs> EndPerformable Event Type EventHandler<PerformableEventArgs> GainedAbility Occurs when an Actor gains a new ability. public event EventHandler<GainAbilityEventArgs> GainedAbility Event Type EventHandler<GainAbilityEventArgs> PerformableFailed Occurs when a performable object fails with an exception. public event EventHandler<PerformableFailureEventArgs> PerformableFailed Event Type EventHandler<PerformableFailureEventArgs> PerformableResult Occurs when an Actor receives a result from a perfperformable objectrmance. public event EventHandler<PerformableResultEventArgs> PerformableResult Event Type EventHandler<PerformableResultEventArgs> PerformanceBegun Occurs when a IPerformance begins executing. public event EventHandler<PerformanceEventArgs> PerformanceBegun Event Type EventHandler<PerformanceEventArgs> PerformanceFinished Occurs when a IPerformance has finished executing. public event EventHandler<PerformanceFinishedEventArgs> PerformanceFinished Event Type EventHandler<PerformanceFinishedEventArgs> RecordAsset Occurs when an actor records the presence of a new file asset. public event EventHandler<PerformableAssetEventArgs> RecordAsset Event Type EventHandler<PerformableAssetEventArgs> ScreenplayEnded Occurs when a Screenplay has ended. public event EventHandler ScreenplayEnded Event Type EventHandler ScreenplayStarted Occurs when a Screenplay starts. public event EventHandler ScreenplayStarted Event Type EventHandler SpotlightTurnedOff Occurs when the Spotlight of an IStage is 'turned off'; the Actor who is currently spotlit is removed without being replaced. public event EventHandler<PerformanceScopeEventArgs> SpotlightTurnedOff Event Type EventHandler<PerformanceScopeEventArgs>"
  },
  "api/CSF.Screenplay.Performances.PerformanceFactory.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceFactory.html",
    "title": "Class PerformanceFactory | Screenplay docs",
    "keywords": "Class PerformanceFactory Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.dll A factory service for instances of Performance public class PerformanceFactory : ICreatesPerformance Inheritance object PerformanceFactory Implements ICreatesPerformance Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformanceFactory(IServiceProvider) Initialises a new instance of PerformanceFactory public PerformanceFactory(IServiceProvider services) Parameters services IServiceProvider Dependency injection services Exceptions ArgumentNullException If services is null Methods CreatePerformance() Creates a new performance instance. public IPerformance CreatePerformance() Returns IPerformance A new performance instance"
  },
  "api/CSF.Screenplay.Performances.PerformanceFinishedEventArgs.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceFinishedEventArgs.html",
    "title": "Class PerformanceFinishedEventArgs | Screenplay docs",
    "keywords": "Class PerformanceFinishedEventArgs Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to a finishing of a IPerformance. public class PerformanceFinishedEventArgs : PerformanceEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs PerformanceEventArgs PerformanceFinishedEventArgs Implements IHasPerformanceIdentity Inherited Members PerformanceEventArgs.NamingHierarchy PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformanceFinishedEventArgs(Guid, IReadOnlyList<IdentifierAndName>, bool?) Initialises a new instance of PerformanceEventArgs public PerformanceFinishedEventArgs(Guid performanceIdentity, IReadOnlyList<IdentifierAndName> namingHierarchy, bool? success) Parameters performanceIdentity Guid The performance identity namingHierarchy IReadOnlyList<IdentifierAndName> The scenario hierarchy success bool? A value indicating whether or not the scenario completed with a succeess result Exceptions ArgumentNullException If the scenario hierarchy is null Properties Success Gets a value indicating whether the finished IPerformance was a success or not public bool? Success { get; } Property Value bool? Remarks The three possible values for this property correspond to three possible values of PerformanceState which represent a performance that has finished. Value Corresponding state true Success false Failed null Completed When using Screenplay with Integration, these three performance states may go on to correspond to a test pass, failure or skipped/ignored test, respectively. See Also IPerformance PerformanceScopeEventArgs PerformanceEventArgs"
  },
  "api/CSF.Screenplay.Performances.PerformanceScopeEventArgs.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceScopeEventArgs.html",
    "title": "Class PerformanceScopeEventArgs | Screenplay docs",
    "keywords": "Class PerformanceScopeEventArgs Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to a scope of a IPerformance. public class PerformanceScopeEventArgs : EventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs Implements IHasPerformanceIdentity Derived ActorEventArgs PerformanceEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This event arguments class is often used as a base for models which identify a IPerformance. Constructors PerformanceScopeEventArgs(Guid) Initializes a new instance of PerformanceScopeEventArgs public PerformanceScopeEventArgs(Guid performanceIdentity) Parameters performanceIdentity Guid The performance identity Properties PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. See Also IPerformance"
  },
  "api/CSF.Screenplay.Performances.PerformanceState.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceState.html",
    "title": "Enum PerformanceState | Screenplay docs",
    "keywords": "Enum PerformanceState Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll Enumerates the states of an IPerformance. public enum PerformanceState Fields Completed = 4 The performance has completed but it has neither succeeded or failed. Failed = 3 The performance has completed but it has failed. InProgress = 1 The performance has been started but is not yet complete; use FinishPerformance(bool?) to complete it. NotStarted = 0 The performance is not yet started; use BeginPerformance() to begin it. Success = 2 The performance has completed and was a success. Remarks When Screenplay is being used with Integration then this will also closely correspond to the state & outcome of the corresponding Scenario"
  },
  "api/CSF.Screenplay.Performances.html": {
    "href": "api/CSF.Screenplay.Performances.html",
    "title": "Namespace CSF.Screenplay.Performances | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.Performances Classes IdentifierAndName A model which indicates a unique identifier and a corresponding human-readable name. PerformanceEventArgs A model for event arguments which relate to a scope of a IPerformance. PerformanceEventBus Implementation of an event bus for performance-related events. PerformanceFactory A factory service for instances of Performance PerformanceFinishedEventArgs A model for event arguments which relate to a finishing of a IPerformance. PerformanceScopeEventArgs A model for event arguments which relate to a scope of a IPerformance. Interfaces IBeginsAndEndsPerformance An object which controls the beginning and ending of a performance ICreatesPerformance An object which creates instances of IPerformance; a factory service. IHasPerformanceEvents An object which has events which are significant to the progress of a Screenplay. IRelaysPerformanceEvents An object which can relay events that relate to a IPerformance Enums PerformanceState Enumerates the states of an IPerformance."
  },
  "api/CSF.Screenplay.ReportFragment.html": {
    "href": "api/CSF.Screenplay.ReportFragment.html",
    "title": "Class ReportFragment | Screenplay docs",
    "keywords": "Class ReportFragment Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A model for a fragment of a report upon a IPerformance. public sealed class ReportFragment Inheritance object ReportFragment Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Examples An example of a template string is \"{Actor} washes {Count} dishes\". This template expects two placeholder values for Actor & Count. A sample FormattedFragment which might result from this could be \"Joe washes 5 dishes\". Remarks A report fragment is typically human readable summary of the execution of a single performable item or the assignment of an ability to an Actor (the actor \"gaining\" an ability). A complete report about an IPerformance would usually contain many such fragments, organised hierarchically where performables consume & execute performables themselves. This creates a nested structure where the outermost report fragments describe higher-level performables, with lower-level performables contained within. Report fragments are created from a template, which is a human-readable string with named placeholders, using a syntax which is very similar to the way in which Microsoft.Extensions.Logging uses template strings: https://learn.microsoft.com/en-us/dotnet/core/extensions/logging. The template may have any number of placeholders, which are names enclosed within braces, such as {Actor}. These placeholders are then populated with a collection of values which are provided to fill those placeholders. The result is a completely formatted, human-readable report fragment string. This model holds the result of this formatting process, the implementation of IFormatsReportFragment is responsible for performing the formatting itself. Constructors ReportFragment(string, string, IReadOnlyList<NameAndValue>) Initializes a new instance of ReportFragment. public ReportFragment(string originalTemplate, string formattedFragment, IReadOnlyList<NameAndValue> placeholderValues) Parameters originalTemplate string The original template string formattedFragment string The formatted report fragment placeholderValues IReadOnlyList<NameAndValue> The placeholder values Exceptions ArgumentNullException If any parameter is null. Properties FormattedFragment Gets the formatted report fragment, after placeholder substitution has taken place. public string FormattedFragment { get; } Property Value string OriginalTemplate Gets the original template string for this report fragment, without placeholder substitution. public string OriginalTemplate { get; } Property Value string PlaceholderValues Gets a collection of the placeholder values, and the placeholder names to which those values correspond. public IReadOnlyList<NameAndValue> PlaceholderValues { get; } Property Value IReadOnlyList<NameAndValue> Methods ToString() public override string ToString() Returns string See Also IFormatsReportFragment"
  },
  "api/CSF.Screenplay.ReportFragmentFormatter.html": {
    "href": "api/CSF.Screenplay.ReportFragmentFormatter.html",
    "title": "Class ReportFragmentFormatter | Screenplay docs",
    "keywords": "Class ReportFragmentFormatter Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Default implementation of IFormatsReportFragment. public class ReportFragmentFormatter : IFormatsReportFragment Inheritance object ReportFragmentFormatter Implements IFormatsReportFragment Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ReportFragmentFormatter(IGetsReportFormat, IGetsValueFormatter) Initializes a new instance of ReportFragmentFormatter. public ReportFragmentFormatter(IGetsReportFormat formatCreator, IGetsValueFormatter formatterFactory) Parameters formatCreator IGetsReportFormat A format creator which parses the original format string and values into a ReportFormat formatterFactory IGetsValueFormatter A factory for instances of IValueFormatter Exceptions ArgumentNullException If any parameter is null. Methods Format(string, params object[]) Gets the formatted report fragment from the specified template and values. public ReportFragment Format(string template, params object[] values) Parameters template string A string template for the report fragment values object[] A collection of values associated with the report fragment Returns ReportFragment A formatted report fragment Examples The following code will produce the final formatted string as noted below. var p1 = \"first\"; var p2 = \"second\"; formatter.Format(\"The values are {p2} and {p1}\", p1, p2); // This will yield the result \"The values are first and second\" Remarks The template should be a human-readable string (localized if you wish) which would be recorded in a Screenplay report. This string may contain any number of placeholder markers which are indicated by some text enclosed within braces, such as {Name}. This functions in a slightly similar fashion to .NET logging: https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-message-template or the Format(string, params object[]) method. Importantly, the placeholders are identified by names, rather than numeric index, in the same way that logging template strings work. Placeholders do not support any kind of format or alignment syntax. Developers are encouraged to choose meaningful names for their placeholders. The ReportFragment which is produced by this method will include the values associated with those placeholder names. This allows reporting infrastructure to work in a similar manner to the way in which structured logging is described in the article linked above. This provides a richer data model than simply a plain string. See Also ReportFragment"
  },
  "api/CSF.Screenplay.ReportModel.ActorCreatedReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.ActorCreatedReport.html",
    "title": "Class ActorCreatedReport | Screenplay docs",
    "keywords": "Class ActorCreatedReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll An implementation of ReportableModelBase which represents the addition/creation of a new actor in a performance. public class ActorCreatedReport : ReportableModelBase Inheritance object ReportableModelBase ActorCreatedReport Inherited Members ReportableModelBase.Report ReportableModelBase.ActorName object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This model exposes nothing more than the ReportableModelBase already provides."
  },
  "api/CSF.Screenplay.ReportModel.ActorGainedAbilityReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.ActorGainedAbilityReport.html",
    "title": "Class ActorGainedAbilityReport | Screenplay docs",
    "keywords": "Class ActorGainedAbilityReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll An implementation of ReportableModelBase which occurs when an Actor gains a new ability. public class ActorGainedAbilityReport : ReportableModelBase Inheritance object ReportableModelBase ActorGainedAbilityReport Inherited Members ReportableModelBase.Report ReportableModelBase.ActorName object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This model exposes nothing more than the ReportableModelBase already provides."
  },
  "api/CSF.Screenplay.ReportModel.ActorSpotlitReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.ActorSpotlitReport.html",
    "title": "Class ActorSpotlitReport | Screenplay docs",
    "keywords": "Class ActorSpotlitReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll An implementation of ReportableModelBase which occurs when an Actor is put into the spotlight. public class ActorSpotlitReport : ReportableModelBase Inheritance object ReportableModelBase ActorSpotlitReport Inherited Members ReportableModelBase.Report ReportableModelBase.ActorName object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This model exposes nothing more than the ReportableModelBase already provides."
  },
  "api/CSF.Screenplay.ReportModel.IdentifierAndNameModel.html": {
    "href": "api/CSF.Screenplay.ReportModel.IdentifierAndNameModel.html",
    "title": "Class IdentifierAndNameModel | Screenplay docs",
    "keywords": "Class IdentifierAndNameModel Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll Model represents an IdentifierAndName within a Screenplay report. public class IdentifierAndNameModel Inheritance object IdentifierAndNameModel Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Like many models in this namespace, this type mimicks a first-class part of the Screenplay architecture. This model type is intended for use with the serialization process to JSON. Many of the properties of these types will correspond directly with the same-named properties on the original Screenplay architecture types. Properties Identifier Corresponds to the value Identifier. public string Identifier { get; set; } Property Value string Name Corresponds to the value Name. public string Name { get; set; } Property Value string WasIdentifierAutoGenerated Corresponds to the value WasIdentifierAutoGenerated. public bool WasIdentifierAutoGenerated { get; set; } Property Value bool"
  },
  "api/CSF.Screenplay.ReportModel.PerformableAsset.html": {
    "href": "api/CSF.Screenplay.ReportModel.PerformableAsset.html",
    "title": "Class PerformableAsset | Screenplay docs",
    "keywords": "Class PerformableAsset Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll Model represents a single asset which was recorded from a performable. public class PerformableAsset Inheritance object PerformableAsset Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Assets are files which are saved to disk, containing arbitrary information, recorded by a performable. This might be a screenshot, some generated content or diagnostic information. Its real content is arbitrary and down to the implementation. An asset is described here by a file path and an optional human-readable summary. Properties FilePath Gets or sets a full/absolute path to the asset file. public string FilePath { get; set; } Property Value string FileSummary Gets or sets an optional human-readable summary of what this asset represents. This should be one sentence at most, suitable for display in a UI tool-tip. public string FileSummary { get; set; } Property Value string"
  },
  "api/CSF.Screenplay.ReportModel.PerformableReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.PerformableReport.html",
    "title": "Class PerformableReport | Screenplay docs",
    "keywords": "Class PerformableReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll An implementation of ReportableModelBase which represents the execution of a performable item. public class PerformableReport : ReportableModelBase Inheritance object ReportableModelBase PerformableReport Inherited Members ReportableModelBase.Report ReportableModelBase.ActorName object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Reports about performables may themselves contain further reportables. This may create a hierarchical structure of reports which contain further reports, and so on. This represents the use of high-level performables which consume/compose lower-level performables. Properties Assets Gets or sets a collection of the assets which were recorded by the current performable. public List<PerformableAsset> Assets { get; set; } Property Value List<PerformableAsset> Exception Gets or sets a value which is the string representation of any Exception which occurred, causing the performable to fail. public string Exception { get; set; } Property Value string Remarks If this property is non-null then the performable has failed with an exception, and this property will contain the result of ToString() for that error. If this property is null then the performable did not raise an exception and completed successfully. ExceptionIsFromConsumedPerformable Gets a value which indicates whether or not the Exception is one which was originally thrown from a consumed performable. public bool ExceptionIsFromConsumedPerformable { get; set; } Property Value bool Remarks If Exception is null then the value of this property is meaningless and undefined. If the exception is not null then - if this property is set to true then it means that exception which is recorded for this performable was originally thrown from a performable which was consumed by the current one. In other words, it indicates whether or not the reason for the current performable's error was because a consumed/child performable encountered an error. If, on the other hand, Exception is not null and this property value is false then it indicates that the current performable is the original source of the error. HasResult Gets or sets a value that indicates whether or not the performable (which generated this report) emitted a result. public bool HasResult { get; set; } Property Value bool Remarks This property will be true if the original performable which lead to this report derived from either IPerformableWithResult or IPerformableWithResult<TResult> (and did not fail). For performables which do not emit a result, this value will always be false. See Also Result PerformableType Gets or sets the FullName of the performable item to which this report model relates. public string PerformableType { get; set; } Property Value string PerformancePhase Corresponds to the PerformancePhase to which the current reportable is part. public string PerformancePhase { get; set; } Property Value string Remarks This property contains the string representation of that performance phase. It is quite rare for this property to be unset (IE: null), typically it is only unset for the initial creation/setup of Actors at the beginning of a performance. Reportables Gets or sets a collection of the reportable items which have been composed by the current performable. public List<ReportableModelBase> Reportables { get; set; } Property Value List<ReportableModelBase> Remarks This collection is commonly populated for task performables, because the nature of tasks is to consume and compose other performables. This collection can create a hierarchical structure of performables composing other performables. That structure could be deeply nested. Result Gets or sets a string representation of the result which was emitted by the corresponding performable. public string Result { get; set; } Property Value string Remarks This property is only relevant if the original performable which lead to this report derived from either IPerformableWithResult or IPerformableWithResult<TResult>. For performables which do not emit a result, this value will always be null. See Also HasResult"
  },
  "api/CSF.Screenplay.ReportModel.PerformanceReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.PerformanceReport.html",
    "title": "Class PerformanceReport | Screenplay docs",
    "keywords": "Class PerformanceReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll Model represents an IPerformance within a Screenplay report. public class PerformanceReport Inheritance object PerformanceReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Like many models in this namespace, this type mimicks a first-class part of the Screenplay architecture. This model type is intended for use with the serialization process to JSON. Many of the properties of these types will correspond directly with the same-named properties on the original Screenplay architecture types. Properties NamingHierarchy Corresponds with NamingHierarchy. public List<IdentifierAndNameModel> NamingHierarchy { get; set; } Property Value List<IdentifierAndNameModel> Outcome Corresponds with PerformanceState, showing the final outcome of the performance. public string Outcome { get; set; } Property Value string Remarks This property contains the string representation of the value of PerformanceState. It is named 'Outcome' rather than 'PerformanceState' because the concept of state would refer to a current state, wheras a report is about something which happened in the past. Additionally, it is impossible for a report to indicate InProgress or NotStarted here. The state will always correspond to one of the three terminal states for a performance. Thus, this property indicates the final outcome of the performance, rather than where it is 'right now'. Reportables Gets or set an ordered collection of the reportable events which occurred in the current performance. public List<ReportableModelBase> Reportables { get; set; } Property Value List<ReportableModelBase>"
  },
  "api/CSF.Screenplay.ReportModel.ReportMetadata.html": {
    "href": "api/CSF.Screenplay.ReportModel.ReportMetadata.html",
    "title": "Class ReportMetadata | Screenplay docs",
    "keywords": "Class ReportMetadata Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll Model represents the metadata about a Screenplay report. public class ReportMetadata Inheritance object ReportMetadata Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ReportFormatVersion Gets or sets a version number for the format of report that has been produced. public string ReportFormatVersion { get; set; } Property Value string Remarks This version number is intended to comply with Semantic versioning: https://semver.org/spec/v2.0.0.html. It may be used to assist parsing logic determine whether or not it is reading a compatible report file. Timestamp Gets or sets the UTC timestamp at which the report was generated. public DateTime Timestamp { get; set; } Property Value DateTime"
  },
  "api/CSF.Screenplay.ReportModel.ReportableModelBase.html": {
    "href": "api/CSF.Screenplay.ReportModel.ReportableModelBase.html",
    "title": "Class ReportableModelBase | Screenplay docs",
    "keywords": "Class ReportableModelBase Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll Model represents anything which may be reported-upon within an IPerformance. [JsonPolymorphic(TypeDiscriminatorPropertyName = \"Type\")] [JsonDerivedType(typeof(ActorCreatedReport), \"ActorCreatedReport\")] [JsonDerivedType(typeof(ActorGainedAbilityReport), \"ActorGainedAbilityReport\")] [JsonDerivedType(typeof(ActorSpotlitReport), \"ActorSpotlitReport\")] [JsonDerivedType(typeof(SpotlightTurnedOffReport), \"SpotlightTurnedOffReport\")] [JsonDerivedType(typeof(PerformableReport), \"PerformableReport\")] public abstract class ReportableModelBase Inheritance object ReportableModelBase Derived ActorCreatedReport ActorGainedAbilityReport ActorSpotlitReport PerformableReport SpotlightTurnedOffReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This base model has subclasses for each of the specific types of event which may be reported-upon. Properties ActorName Gets or sets the name of the Actor who is associated with this report. public string ActorName { get; set; } Property Value string Remarks Almost all reportables involve an actor, it is rare for this value to be unset (IE: null). Report Gets or sets the human-readable text of the report. public string Report { get; set; } Property Value string"
  },
  "api/CSF.Screenplay.ReportModel.ScreenplayReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.ScreenplayReport.html",
    "title": "Class ScreenplayReport | Screenplay docs",
    "keywords": "Class ScreenplayReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll Represents a complete Screenplay report. public class ScreenplayReport Inheritance object ScreenplayReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This type is not used in the writing of Screenplay reports; the JsonScreenplayReporter writes the report by streaming it to a file as it is generated. This type is used only for the deserialization of a report file. Properties Metadata Gets or sets the metadata for the report. public ReportMetadata Metadata { get; set; } Property Value ReportMetadata Performances Gets or sets the performances which are included within the report. public ICollection<PerformanceReport> Performances { get; set; } Property Value ICollection<PerformanceReport> Remarks There is no defined order to the performances within the report. The order in which they appear in this collection will correspond to the order in which they were serialized to the report file. However, because performances may occur in parallel, there is no guarantee that the order will be stable between different reports, even if the Screenplay and IPerformance instances contained are the same, with the same logic."
  },
  "api/CSF.Screenplay.ReportModel.SpotlightTurnedOffReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.SpotlightTurnedOffReport.html",
    "title": "Class SpotlightTurnedOffReport | Screenplay docs",
    "keywords": "Class SpotlightTurnedOffReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll An implementation of ReportableModelBase which occurs when the spotlight is turned off. public class SpotlightTurnedOffReport : ReportableModelBase Inheritance object ReportableModelBase SpotlightTurnedOffReport Inherited Members ReportableModelBase.Report ReportableModelBase.ActorName object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This model exposes nothing more than the ReportableModelBase already provides."
  },
  "api/CSF.Screenplay.ReportModel.html": {
    "href": "api/CSF.Screenplay.ReportModel.html",
    "title": "Namespace CSF.Screenplay.ReportModel | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.ReportModel Classes ActorCreatedReport An implementation of ReportableModelBase which represents the addition/creation of a new actor in a performance. ActorGainedAbilityReport An implementation of ReportableModelBase which occurs when an Actor gains a new ability. ActorSpotlitReport An implementation of ReportableModelBase which occurs when an Actor is put into the spotlight. IdentifierAndNameModel Model represents an IdentifierAndName within a Screenplay report. PerformableAsset Model represents a single asset which was recorded from a performable. PerformableReport An implementation of ReportableModelBase which represents the execution of a performable item. PerformanceReport Model represents an IPerformance within a Screenplay report. ReportMetadata Model represents the metadata about a Screenplay report. ReportableModelBase Model represents anything which may be reported-upon within an IPerformance. ScreenplayReport Represents a complete Screenplay report. SpotlightTurnedOffReport An implementation of ReportableModelBase which occurs when the spotlight is turned off."
  },
  "api/CSF.Screenplay.Reporting.FormattableFormatter.html": {
    "href": "api/CSF.Screenplay.Reporting.FormattableFormatter.html",
    "title": "Class FormattableFormatter | Screenplay docs",
    "keywords": "Class FormattableFormatter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Implementation of IValueFormatter which formats objects that implement IFormattableValue. public class FormattableFormatter : IValueFormatter Inheritance object FormattableFormatter Implements IValueFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CanFormat(object) Gets a value indicating whether this object is suitable for formatting the specified value. public bool CanFormat(object value) Parameters value object The value to be formatted Returns bool true if this formatter is suitable for formatting the specified value; false if not. FormatForReport(object) Gets a formatted string which represents the specified value. public string FormatForReport(object value) Parameters value object The value to be formatted Returns string A formatted string which represents the specified value. Remarks Ensure that the value has been tested with CanFormat(object) before executing this method. The behaviour of this method is undefined for any value for which the can-format method does not return true. It may lead to exceptions or garbage output."
  },
  "api/CSF.Screenplay.Reporting.HumanizerFormatter.html": {
    "href": "api/CSF.Screenplay.Reporting.HumanizerFormatter.html",
    "title": "Class HumanizerFormatter | Screenplay docs",
    "keywords": "Class HumanizerFormatter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll A formatter which makes use of the Humanizer: https://github.com/Humanizr/Humanizer library to format a limited number of value types. public class HumanizerFormatter : IValueFormatter Inheritance object HumanizerFormatter Implements IValueFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks In theory this formatter could do quite a lot more, as Humanizer's capabilities are much wider than the functionality used here. Since this is a preloaded/default formatter, it is intentionally limited so as to avoid accidentally \"humanising\" values which were already human-readable, mangling them in an unwanted way. The types supported by this formatter implementation are: Type Note DateTime Formatted by Humanizer Nullable<T> of DateTime Formatted by Humanizer if not null, otherwise CanFormat(object) will return false TimeSpan Formatted by Humanizer Nullable<T> of TimeSpan Formatted by Humanizer if not null, otherwise CanFormat(object) will return false Implements IEnumerable<T> of string Formatted by Humanizer into a comma-separated list Developers are welcome to create their own formatter implementations which make use of Humanizer (the dependency is already present) and which more closely target the values they'd like formatted. This class is intentionally limited to formatting values which are unlikely to be controversial. Methods CanFormat(object) Gets a value indicating whether this object is suitable for formatting the specified value. public bool CanFormat(object value) Parameters value object The value to be formatted Returns bool true if this formatter is suitable for formatting the specified value; false if not. FormatForReport(object) Gets a formatted string which represents the specified value. public string FormatForReport(object value) Parameters value object The value to be formatted Returns string A formatted string which represents the specified value. Remarks Ensure that the value has been tested with CanFormat(object) before executing this method. The behaviour of this method is undefined for any value for which the can-format method does not return true. It may lead to exceptions or garbage output."
  },
  "api/CSF.Screenplay.Reporting.IDeserializesReport.html": {
    "href": "api/CSF.Screenplay.Reporting.IDeserializesReport.html",
    "title": "Interface IDeserializesReport | Screenplay docs",
    "keywords": "Interface IDeserializesReport Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll An object which deserializes a Screenplay report from a stream. public interface IDeserializesReport Methods DeserializeAsync(Stream) Deserializes a Screenplay report from the provided stream asynchronously. Task<ScreenplayReport> DeserializeAsync(Stream stream) Parameters stream Stream The stream containing the serialized Screenplay report. Returns Task<ScreenplayReport> A task that represents the asynchronous operation. The task result contains the deserialized Screenplay report."
  },
  "api/CSF.Screenplay.Reporting.IFormattableValue.html": {
    "href": "api/CSF.Screenplay.Reporting.IFormattableValue.html",
    "title": "Interface IFormattableValue | Screenplay docs",
    "keywords": "Interface IFormattableValue Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll An object which has its own functionality for generating a human-readable representation of itself for a Screenplay report. public interface IFormattableValue Remarks Implement this interface in your own types in order to provide a custom representation of the object when it is included in a Screenplay report. The FormatForReport() method should be used to create a human-readable string which represents the object in the report text. This interface is a part of the mechanism for formatting values in reports in Screenplay. Methods FormatForReport() Gets a human-readable formatted string which represents the current object instance, suitable to be used in a Screenplay report. string FormatForReport() Returns string A formatted string which represents the current instance. See Also IHasName IValueFormatter"
  },
  "api/CSF.Screenplay.Reporting.IFormatterRegistry.html": {
    "href": "api/CSF.Screenplay.Reporting.IFormatterRegistry.html",
    "title": "Interface IFormatterRegistry | Screenplay docs",
    "keywords": "Interface IFormatterRegistry Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll A registry of the concrete types of IValueFormatter which are available for use by the Screenplay reporting functionality. public interface IFormatterRegistry : IList<Type>, ICollection<Type>, IEnumerable<Type>, IEnumerable Inherited Members IList<Type>.IndexOf(Type) IList<Type>.Insert(int, Type) IList<Type>.RemoveAt(int) IList<Type>.this[int] ICollection<Type>.Add(Type) ICollection<Type>.Clear() ICollection<Type>.Contains(Type) ICollection<Type>.CopyTo(Type[], int) ICollection<Type>.Remove(Type) ICollection<Type>.Count ICollection<Type>.IsReadOnly IEnumerable<Type>.GetEnumerator() Remarks Formatter types stored within this registry will be selected for use in the reverse order in which they appear in the collection. When selecting a formatter for a particular object/value, this collection will be iterated starting at the end, moving toward the beginning. This means that (presuming new formatter types are added using Add(T)), types which are added later will be used with precedence over those which are added earlier. This is the mechanism which is used as a tie-breaker if two or more IValueFormatter types would both return true from CanFormat(object). Developers might want to add a IValueFormatter type to this collection, which is to have a lower precedence than another which has already been added, when they are both able to format the same value. In that scenario, use Insert(int, T) to explicitly add the formatter at a lower index (closer to the start of the collection)."
  },
  "api/CSF.Screenplay.Reporting.IGetsReportFormat.html": {
    "href": "api/CSF.Screenplay.Reporting.IGetsReportFormat.html",
    "title": "Interface IGetsReportFormat | Screenplay docs",
    "keywords": "Interface IGetsReportFormat Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll An object which can get a ReportFormat from a report format template and the associated values. public interface IGetsReportFormat Methods GetReportFormat(string, IList<object>) Gets a ReportFormat instance from the specified template and collection of values. ReportFormat GetReportFormat(string template, IList<object> values) Parameters template string The original report format template values IList<object> An ordered collection of placeholder values to be used with the template Returns ReportFormat An instance of ReportFormat which combines the template and the values. Remarks The template is intended to be a human-readable string, with value placeholders enclosed within braces. The values is a collection of data values to be used as the 'filler' for those placeholders. The order in which the values are provided is important, as the placeholders will be filled in the order in which they appear in the template string. Note that duplicate placeholders will receive the same value and do not require the value to be repeated in the values collection. Exceptions ArgumentNullException If any parameter is null."
  },
  "api/CSF.Screenplay.Reporting.IGetsValueFormatter.html": {
    "href": "api/CSF.Screenplay.Reporting.IGetsValueFormatter.html",
    "title": "Interface IGetsValueFormatter | Screenplay docs",
    "keywords": "Interface IGetsValueFormatter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll An object which can select the most appropriate implementation of IValueFormatter from a IFormatterRegistry. public interface IGetsValueFormatter Extension Methods ValueFormatterExtensions.FormatValue(IGetsValueFormatter, object) Methods GetValueFormatter(object) Selects and returns an IValueFormatter which is most appropriate to the specified value. IValueFormatter GetValueFormatter(object value) Parameters value object The value to be formatted Returns IValueFormatter A value formatter Remarks See the remarks for IFormatterRegistry for more information about the algorithm by which an appropriate formatter is selected. It should be very rare for this method to raise an exception; as implementations of this type should come pre-loaded with fallback formatters which may format any value. Exceptions might only be expected if a developer removes these default formatters and does not replace them with suitable implementaton types that can cover all scenarios. Exceptions InvalidOperationException If no appropriate formatter could be selected"
  },
  "api/CSF.Screenplay.Reporting.IReporter.html": {
    "href": "api/CSF.Screenplay.Reporting.IReporter.html",
    "title": "Interface IReporter | Screenplay docs",
    "keywords": "Interface IReporter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll Defines a reporter that subscribes to and processes events from a Screenplay event notifier. public interface IReporter : IDisposable Inherited Members IDisposable.Dispose() Remarks Implementations of this interface are responsible for accumulating information about the Screenplay as events are received, and generating reports based on that information. Methods SubscribeTo(IHasPerformanceEvents) Subscribes to the events emitted by the specified Screenplay event notifier. void SubscribeTo(IHasPerformanceEvents events) Parameters events IHasPerformanceEvents A Screenplay event notifier Remarks As events are received, this reporter instance may accumulate information about the Screnplay that it is to report upon. UnsubscribeFrom(IHasPerformanceEvents) Unsubscribes from the specified Screenplay event notifier. void UnsubscribeFrom(IHasPerformanceEvents events) Parameters events IHasPerformanceEvents A Screenplay event notifier Remarks Use this method only after the event notifier has emitted the ScreenplayEnded event. If this reporter unsubscribes from Screenplay events before the Screenplay has ended then the results are undefined. This could lead to a corrupt report file."
  },
  "api/CSF.Screenplay.Reporting.ITestsPathForWritePermissions.html": {
    "href": "api/CSF.Screenplay.Reporting.ITestsPathForWritePermissions.html",
    "title": "Interface ITestsPathForWritePermissions | Screenplay docs",
    "keywords": "Interface ITestsPathForWritePermissions Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll An object which may test a file system path for writability. public interface ITestsPathForWritePermissions Methods HasWritePermission(string) Gets a value indicating whether or not the current process should be able to write a file at the specified path. bool HasWritePermission(string path) Parameters path string An absolute or relative file path. Returns bool true if the current process is able to write to the specified path; false if not. Remarks The path may be relative or absolute; if relative then it is treated as relative to the current working directory."
  },
  "api/CSF.Screenplay.Reporting.IValueFormatter.html": {
    "href": "api/CSF.Screenplay.Reporting.IValueFormatter.html",
    "title": "Interface IValueFormatter | Screenplay docs",
    "keywords": "Interface IValueFormatter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll An object which can format a value which appears within a Screenplay report. public interface IValueFormatter Remarks Implement this interface in your own types in order to create a service which may externally format values for inclusion in a Screenplay report. A typical Screenplay solution will include many implementations of this interface, each of which is responsible for formatting a specific subset of values. Before an implementation of this type is used to format a value, the CanFormat(object) method should be called in order to determine whether the formatter is suitable for the value in question. This is an application of the strategy pattern: https://en.wikipedia.org/wiki/Strategy_pattern. For any concrete implementation of this interface to be considered in formatting a value with a report, its type must first be registered with the IFormatterRegistry. The FormatForReport(object) method should be used to create a human-readable string which represents the object in the report text. This interface is a part of the mechanism for formatting values in reports in Screenplay. Methods CanFormat(object) Gets a value indicating whether this object is suitable for formatting the specified value. bool CanFormat(object value) Parameters value object The value to be formatted Returns bool true if this formatter is suitable for formatting the specified value; false if not. FormatForReport(object) Gets a formatted string which represents the specified value. string FormatForReport(object value) Parameters value object The value to be formatted Returns string A formatted string which represents the specified value. Remarks Ensure that the value has been tested with CanFormat(object) before executing this method. The behaviour of this method is undefined for any value for which the can-format method does not return true. It may lead to exceptions or garbage output. See Also IHasName IFormattableValue IFormatterRegistry"
  },
  "api/CSF.Screenplay.Reporting.JsonScreenplayReportReader.html": {
    "href": "api/CSF.Screenplay.Reporting.JsonScreenplayReportReader.html",
    "title": "Class JsonScreenplayReportReader | Screenplay docs",
    "keywords": "Class JsonScreenplayReportReader Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Implementation of IDeserializesReport that deserializes a Screenplay report from a JSON stream. public class JsonScreenplayReportReader : IDeserializesReport Inheritance object JsonScreenplayReportReader Implements IDeserializesReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods DeserializeAsync(Stream) Deserializes a Screenplay report from the provided stream asynchronously. public Task<ScreenplayReport> DeserializeAsync(Stream stream) Parameters stream Stream The stream containing the serialized Screenplay report. Returns Task<ScreenplayReport> A task that represents the asynchronous operation. The task result contains the deserialized Screenplay report."
  },
  "api/CSF.Screenplay.Reporting.JsonScreenplayReporter.html": {
    "href": "api/CSF.Screenplay.Reporting.JsonScreenplayReporter.html",
    "title": "Class JsonScreenplayReporter | Screenplay docs",
    "keywords": "Class JsonScreenplayReporter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll An object which subscribes/listens to the events of IHasPerformanceEvents and which produces a JSON-formatted report from them. public sealed class JsonScreenplayReporter : IReporter, IDisposable Inheritance object JsonScreenplayReporter Implements IReporter IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Note that instances of this class are not reusable; this is a stateful type. Each instance builds and writes a single report file which corresponds to the execution of a single instance of Screenplay. To write a second report, or to write a report about a different Screenplay, please create a new instance of this type. This type works by accumulating reporting information about IPerformance instances using ScreenplayReportBuilder. Each of these performances may themselves accumulate information from the various events which occur during the performance lifetime. Once a performance is ended (success or otherwise), the completed PerformanceReport may be retrieved from the screenplay report builder. This is then written & flushed to the JSON file. The writing of JSON must be performed in a thread-safe manner, recall that multiple performances could be ongoing at the same time, in parallel. Additionally, it is important to write the JSON as-we-progress, rather than waiting until the end of the Screenplay, or the ScreenplayEnded event. That's because in many scenarios, the end of the Screenplay is triggered by the assembly-unload events for the whole process. This is particularly true for software testing frameworks. If we waited to write all of the JSON at the very end of the process then it is very likely that the write will be interrupted. Logic triggered from unload event handlers is permitted only a tiny amount of system compute resource and is inappropriate for performing anything substantial. This is why this type writes each performance to JSON as it completes, essentially streaming the information to the JSON file. This means that all that is left to be done when the Screenplay completes is to write a few closing symbols and then close the file. Constructors JsonScreenplayReporter(Stream, ScreenplayReportBuilder) Initializes a new instance of JsonScreenplayReporter for a specified file path. public JsonScreenplayReporter(Stream writeStream, ScreenplayReportBuilder builder) Parameters writeStream Stream The stream to which the JSON report shall be written. builder ScreenplayReportBuilder The Screenplay report builder Exceptions ArgumentNullException If writeStream is null. Methods Dispose() public void Dispose() SubscribeTo(IHasPerformanceEvents) Subscribes to the events emitted by the specified Screenplay event notifier. public void SubscribeTo(IHasPerformanceEvents events) Parameters events IHasPerformanceEvents A Screenplay event notifier Remarks As events are received, this reporter instance may accumulate information about the Screnplay that it is to report upon. UnsubscribeFrom(IHasPerformanceEvents) Unsubscribes from the specified Screenplay event notifier. public void UnsubscribeFrom(IHasPerformanceEvents events) Parameters events IHasPerformanceEvents A Screenplay event notifier Remarks Use this method only after the event notifier has emitted the ScreenplayEnded event. If this reporter unsubscribes from Screenplay events before the Screenplay has ended then the results are undefined. This could lead to a corrupt report file."
  },
  "api/CSF.Screenplay.Reporting.NameAndValue.html": {
    "href": "api/CSF.Screenplay.Reporting.NameAndValue.html",
    "title": "Class NameAndValue | Screenplay docs",
    "keywords": "Class NameAndValue Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll A simple model for a value that is to be included in a formatted ReportFragment, which has an associated name. public class NameAndValue Inheritance object NameAndValue Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NameAndValue(string, object) Initializes a new instance of NameAndValue. public NameAndValue(string name, object value) Parameters name string The name for the value value object The value Exceptions ArgumentNullException If name is null. Properties Name Gets the name associated with this value. public string Name { get; } Property Value string Value Gets the value. public object Value { get; } Property Value object"
  },
  "api/CSF.Screenplay.Reporting.NameFormatter.html": {
    "href": "api/CSF.Screenplay.Reporting.NameFormatter.html",
    "title": "Class NameFormatter | Screenplay docs",
    "keywords": "Class NameFormatter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Implementation of IValueFormatter which formats objects that implement IHasName. public class NameFormatter : IValueFormatter Inheritance object NameFormatter Implements IValueFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CanFormat(object) Gets a value indicating whether this object is suitable for formatting the specified value. public bool CanFormat(object value) Parameters value object The value to be formatted Returns bool true if this formatter is suitable for formatting the specified value; false if not. FormatForReport(object) Gets a formatted string which represents the specified value. public string FormatForReport(object value) Parameters value object The value to be formatted Returns string A formatted string which represents the specified value. Remarks Ensure that the value has been tested with CanFormat(object) before executing this method. The behaviour of this method is undefined for any value for which the can-format method does not return true. It may lead to exceptions or garbage output."
  },
  "api/CSF.Screenplay.Reporting.NoOpReporter.html": {
    "href": "api/CSF.Screenplay.Reporting.NoOpReporter.html",
    "title": "Class NoOpReporter | Screenplay docs",
    "keywords": "Class NoOpReporter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll A no-op implementation of IReporter which does nothing. public sealed class NoOpReporter : IReporter, IDisposable Inheritance object NoOpReporter Implements IReporter IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Methods Dispose() public void Dispose() SubscribeTo(IHasPerformanceEvents) Subscribes to the events emitted by the specified Screenplay event notifier. public void SubscribeTo(IHasPerformanceEvents events) Parameters events IHasPerformanceEvents A Screenplay event notifier Remarks As events are received, this reporter instance may accumulate information about the Screnplay that it is to report upon. UnsubscribeFrom(IHasPerformanceEvents) Unsubscribes from the specified Screenplay event notifier. public void UnsubscribeFrom(IHasPerformanceEvents events) Parameters events IHasPerformanceEvents A Screenplay event notifier Remarks Use this method only after the event notifier has emitted the ScreenplayEnded event. If this reporter unsubscribes from Screenplay events before the Screenplay has ended then the results are undefined. This could lead to a corrupt report file."
  },
  "api/CSF.Screenplay.Reporting.PerformanceReportBuilder.html": {
    "href": "api/CSF.Screenplay.Reporting.PerformanceReportBuilder.html",
    "title": "Class PerformanceReportBuilder | Screenplay docs",
    "keywords": "Class PerformanceReportBuilder Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Builder for an instance of PerformanceReport. public class PerformanceReportBuilder Inheritance object PerformanceReportBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This is a stateful builder, so instances of this type are not reusable for more than one PerformanceReport. Constructors PerformanceReportBuilder(List<IdentifierAndNameModel>, IGetsValueFormatter, IFormatsReportFragment) Initialises a new instance of PerformanceReportBuilder. public PerformanceReportBuilder(List<IdentifierAndNameModel> namingHierarchy, IGetsValueFormatter valueFormatterProvider, IFormatsReportFragment formatter) Parameters namingHierarchy List<IdentifierAndNameModel> The naming hierarchy of the performance; see NamingHierarchy valueFormatterProvider IGetsValueFormatter A value formatter factory formatter IFormatsReportFragment A report-fragment formatter Exceptions ArgumentNullException If any parameter is null. Methods ActorCreated(Actor) Adds a report to the current performance indicating that an actor has been created/added to the performance. public void ActorCreated(Actor actor) Parameters actor Actor The actor ActorGainedAbility(Actor, object) Adds a report to the current performance indicating that an actor has gained/been granted a new ability. public void ActorGainedAbility(Actor actor, object ability) Parameters actor Actor The actor ability object The ability which was granted ActorSpotlit(Actor) Adds a report to the current performance indicating that an actor has been placed into the spotlight. public void ActorSpotlit(Actor actor) Parameters actor Actor The actor Remarks For more information, see the spotlight glossary item. BeginPerformable(object, Actor, string) Begins a new report within the current performance, that a new performable has been begun. public void BeginPerformable(object performable, Actor actor, string performancePhase) Parameters performable object The performable obeject which has begun actor Actor The actor executing the performable performancePhase string The performance phase in which the performable occurs Remarks This might be a new performable at the root of the performance, or it might be nested within another performable which is already in progress. When this method is executed, the performable becomes the 'current' performable for this builder. The current performable is tracked as a Stack<T>, as a performable may contain a hierarchy of further performables, each of which becomes the current performable in its turn. This method pushes a new performable onto the stack. Once all of the consumed performables have finished, the current performable will return to this one. Thus, as performables begin and end, the current performable stack will be pushed and popped many times. See Also EndPerformable(object, Actor) RecordFailureForCurrentPerformable(Exception) EndPerformable(object, Actor) Indicates that the current performable has finished normally and that it should no longer be current. public void EndPerformable(object performable, Actor actor) Parameters performable object The performable which is ending actor Actor The actor which was executing the performable Remarks This method will 'pop' the current performable from the current performable stack. The current performable will become either the performable which directly consumed/composed the one which is ending, or perhaps this will lead to there being no current performable (if the ending performable was at the root of the performance). See Also BeginPerformable(object, Actor, string) GetReport(bool?) Records the outcome of this performance and gets the report. public PerformanceReport GetReport(bool? success) Parameters success bool? A value indicating the outcome of the performance, this has the same semantics as the parameter to FinishPerformance(bool?) Returns PerformanceReport The completed performance report. Remarks Use this method when the performance has completed. Once this method has been used, it is normal that this builder instance will not be used any further. RecordAssetForCurrentPerformable(string, string) Enriches the current performable with information about a file asset. public void RecordAssetForCurrentPerformable(string assetPath, string assetSummary) Parameters assetPath string The file path to the asset assetSummary string The human readable summary of the asset Remarks This method may be called many times for the same performable, or it might not be used at all. RecordFailureForCurrentPerformable(Exception) Records the current performable as a failure, due to an uncaught exception. public void RecordFailureForCurrentPerformable(Exception exception) Parameters exception Exception The exception which lead to the failure Remarks This method will 'pop' the current performable from the current performable stack. The current performable will become either the performable which directly consumed/composed the one which is ending, or perhaps this will lead to there being no current performable (if the ending performable was at the root of the performance). RecordResultForCurrentPerformable(object) Enriches the current performable with information about its result. public void RecordResultForCurrentPerformable(object result) Parameters result object The result of the performable Remarks This method is only applicable to performables which may return a result. SpotlightTurnedOff() Adds a report to the current performance indicating that the spotlight has been turned off. public void SpotlightTurnedOff() Remarks For more information, see the spotlight glossary item."
  },
  "api/CSF.Screenplay.Reporting.ReportFormat.html": {
    "href": "api/CSF.Screenplay.Reporting.ReportFormat.html",
    "title": "Class ReportFormat | Screenplay docs",
    "keywords": "Class ReportFormat Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll Model used for creating a ReportFragment, which includes the original report fragment template string, a reworked template string suitable for use with Format(string, params object[]) and the placeholder values to be inserted into that format. public class ReportFormat Inheritance object ReportFormat Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ReportFormat(string, string, IList<NameAndValue>) Initializes a new instance of ReportFormat. public ReportFormat(string originalTemplate, string formatTemplate, IList<NameAndValue> values) Parameters originalTemplate string The original template string formatTemplate string The reformatted template string values IList<NameAndValue> The placeholder values and their names Exceptions ArgumentNullException If any parameter is null. Properties FormatTemplate Gets a reformatted version of OriginalTemplate, which includes only numeric placeholders. public string FormatTemplate { get; } Property Value string Remarks This string should be in a format which could be used by Format(string, params object[]). OriginalTemplate Gets the original template string, which may include named placeholders. public string OriginalTemplate { get; } Property Value string Values Gets a collection of the placeholder values which are to be inserted into the FormatTemplate. public IReadOnlyList<NameAndValue> Values { get; } Property Value IReadOnlyList<NameAndValue> Remarks The value's numeric position/index in this collection corresponds to which of the numeric placeholders of FormatTemplate the value should be inserted into. The Name associated with the value may be used to report upon the name of that particular value, preserving that aspect of the OriginalTemplate for informational purposes."
  },
  "api/CSF.Screenplay.Reporting.ReportFormatCreator.html": {
    "href": "api/CSF.Screenplay.Reporting.ReportFormatCreator.html",
    "title": "Class ReportFormatCreator | Screenplay docs",
    "keywords": "Class ReportFormatCreator Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Default implementation of IGetsReportFormat. public class ReportFormatCreator : IGetsReportFormat Inheritance object ReportFormatCreator Implements IGetsReportFormat Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetReportFormat(string, IList<object>) Gets a ReportFormat instance from the specified template and collection of values. public ReportFormat GetReportFormat(string template, IList<object> values) Parameters template string The original report format template values IList<object> An ordered collection of placeholder values to be used with the template Returns ReportFormat An instance of ReportFormat which combines the template and the values. Remarks The template is intended to be a human-readable string, with value placeholders enclosed within braces. The values is a collection of data values to be used as the 'filler' for those placeholders. The order in which the values are provided is important, as the placeholders will be filled in the order in which they appear in the template string. Note that duplicate placeholders will receive the same value and do not require the value to be repeated in the values collection. Exceptions ArgumentNullException If any parameter is null."
  },
  "api/CSF.Screenplay.Reporting.ScreenplayReportBuilder.html": {
    "href": "api/CSF.Screenplay.Reporting.ScreenplayReportBuilder.html",
    "title": "Class ScreenplayReportBuilder | Screenplay docs",
    "keywords": "Class ScreenplayReportBuilder Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Builder type accumulates PerformanceReportBuilder as performances occur within the Screenplay. public class ScreenplayReportBuilder Inheritance object ScreenplayReportBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This type is used by JsonScreenplayReporter so that it may direct the appropriate reports (relating to performances) to the appropriate performance. Be mindful that performances could be occurring in parallel, so it would be incorrect to maintain a concept of \"the current performance\". This class provides a thread-safe mechanism by which to access the builder for each performance, as they occur. Use BeginPerformance(Guid, IReadOnlyList<IdentifierAndName>) in order to add a new performance to this builder. During that performance's lifespan use GetPerformanceBuilder(Guid) in order to direct logic to its builder. Once the performance is over, use EndPerformanceAndGetReport(Guid, bool?) to remove that performance from this instance (it doesn't need tracking once it's finished) and to get the completed report for that performance. Constructors ScreenplayReportBuilder(Func<List<IdentifierAndNameModel>, PerformanceReportBuilder>) Initialises a new instance of ScreenplayReportBuilder. public ScreenplayReportBuilder(Func<List<IdentifierAndNameModel>, PerformanceReportBuilder> performanceBuilderFactory) Parameters performanceBuilderFactory Func<List<IdentifierAndNameModel>, PerformanceReportBuilder> A factory function for performance report builders Exceptions ArgumentNullException If performanceBuilderFactory is null. Methods BeginPerformance(Guid, IReadOnlyList<IdentifierAndName>) Begins building a report about a new performance. public void BeginPerformance(Guid performanceIdentifier, IReadOnlyList<IdentifierAndName> namingHierarchy) Parameters performanceIdentifier Guid The performance identifier namingHierarchy IReadOnlyList<IdentifierAndName> A naming hierarchy for that performance Remarks This method adds the new performance to the state of the current instance, so that it tracked and may be built by accumulating further reporting data. Once the performance is being tracked, use GetPerformanceBuilder(Guid) to return a reference to that builder. Use EndPerformanceAndGetReport(Guid, bool?) once the performance is finished (successfully or otherwise), which will remove it from the current Screenplay builder. See Also IPerformance NamingHierarchy IHasPerformanceIdentity EndPerformanceAndGetReport(Guid, bool?) Ends the specified performance, removing its builder from the current instance, and returns the completed/built report. public PerformanceReport EndPerformanceAndGetReport(Guid performanceIdentifier, bool? success) Parameters performanceIdentifier Guid The performance identifier success bool? A value indicating whether or not the performance was a success. This has the same semantics as the parameter to FinishPerformance(bool?) Returns PerformanceReport The performance report which was built by the performance report builder Exceptions ArgumentException If the current Screenplay builder does not have a tracked performance with the specified performanceIdentifier. See Also IPerformance IHasPerformanceIdentity IBeginsAndEndsPerformance PerformanceReport GetPerformanceBuilder(Guid) Gets the performance builder corresponding to the specified identifier. public PerformanceReportBuilder GetPerformanceBuilder(Guid performanceIdentifier) Parameters performanceIdentifier Guid The performance identifier Returns PerformanceReportBuilder A performance report builder which corresponds to the requested performance Exceptions ArgumentException If the current Screenplay builder does not have a tracked performance with the specified performanceIdentifier. See Also IPerformance IHasPerformanceIdentity PerformanceReportBuilder See Also PerformanceReportBuilder"
  },
  "api/CSF.Screenplay.Reporting.ToStringFormatter.html": {
    "href": "api/CSF.Screenplay.Reporting.ToStringFormatter.html",
    "title": "Class ToStringFormatter | Screenplay docs",
    "keywords": "Class ToStringFormatter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Implementation of IValueFormatter which formats any object by using its default ToString() method, or returns the string <null> if the value is null. public class ToStringFormatter : IValueFormatter Inheritance object ToStringFormatter Implements IValueFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This formatter should be used as a default/last resort. It is very likely that this could produce results which are not particularly human readable. Methods CanFormat(object) Gets a value indicating whether this object is suitable for formatting the specified value. public bool CanFormat(object value) Parameters value object The value to be formatted Returns bool true if this formatter is suitable for formatting the specified value; false if not. FormatForReport(object) Gets a formatted string which represents the specified value. public string FormatForReport(object value) Parameters value object The value to be formatted Returns string A formatted string which represents the specified value. Remarks Ensure that the value has been tested with CanFormat(object) before executing this method. The behaviour of this method is undefined for any value for which the can-format method does not return true. It may lead to exceptions or garbage output."
  },
  "api/CSF.Screenplay.Reporting.ValueFormatterExtensions.html": {
    "href": "api/CSF.Screenplay.Reporting.ValueFormatterExtensions.html",
    "title": "Class ValueFormatterExtensions | Screenplay docs",
    "keywords": "Class ValueFormatterExtensions Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll Extension methods for IGetsValueFormatter. public static class ValueFormatterExtensions Inheritance object ValueFormatterExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods FormatValue(IGetsValueFormatter, object) Formats the specified value using an appropriate implementation of IValueFormatter, retrieved from the factory. public static string FormatValue(this IGetsValueFormatter formatterProvider, object value) Parameters formatterProvider IGetsValueFormatter A value formatter factory value object The value to be formatted Returns string The formatted value Remarks This extension method is a convenience, equivalent to using GetValueFormatter(object), followed by FormatForReport(object), both using value as the parameter. Exceptions ArgumentNullException If formatterProvider is null."
  },
  "api/CSF.Screenplay.Reporting.ValueFormatterProvider.html": {
    "href": "api/CSF.Screenplay.Reporting.ValueFormatterProvider.html",
    "title": "Class ValueFormatterProvider | Screenplay docs",
    "keywords": "Class ValueFormatterProvider Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Implementation of IGetsValueFormatter which uses dependency injection services. public class ValueFormatterProvider : IGetsValueFormatter Inheritance object ValueFormatterProvider Implements IGetsValueFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ValueFormatterProvider(IServiceProvider, IFormatterRegistry) Initializes a new instance of ValueFormatterProvider. public ValueFormatterProvider(IServiceProvider services, IFormatterRegistry registry) Parameters services IServiceProvider A service provider registry IFormatterRegistry A registry of the available formatter types Exceptions ArgumentNullException If any parameter is null. Methods GetValueFormatter(object) Selects and returns an IValueFormatter which is most appropriate to the specified value. public IValueFormatter GetValueFormatter(object value) Parameters value object The value to be formatted Returns IValueFormatter A value formatter Remarks See the remarks for IFormatterRegistry for more information about the algorithm by which an appropriate formatter is selected. It should be very rare for this method to raise an exception; as implementations of this type should come pre-loaded with fallback formatters which may format any value. Exceptions might only be expected if a developer removes these default formatters and does not replace them with suitable implementaton types that can cover all scenarios. Exceptions InvalidOperationException If no appropriate formatter could be selected"
  },
  "api/CSF.Screenplay.Reporting.ValueFormatterRegistry.html": {
    "href": "api/CSF.Screenplay.Reporting.ValueFormatterRegistry.html",
    "title": "Class ValueFormatterRegistry | Screenplay docs",
    "keywords": "Class ValueFormatterRegistry Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Default implementation of IFormatterRegistry which also serves as an object factory, by virtue of a service provider. public class ValueFormatterRegistry : IFormatterRegistry, IList<Type>, ICollection<Type>, IEnumerable<Type>, IEnumerable Inheritance object ValueFormatterRegistry Implements IFormatterRegistry IList<Type> ICollection<Type> IEnumerable<Type> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Count public int Count { get; } Property Value int IsReadOnly public bool IsReadOnly { get; } Property Value bool this[int] public Type this[int index] { get; set; } Parameters index int Property Value Type Methods Add(Type) public void Add(Type item) Parameters item Type Clear() public void Clear() Contains(Type) public bool Contains(Type item) Parameters item Type Returns bool CopyTo(Type[], int) public void CopyTo(Type[] array, int arrayIndex) Parameters array Type[] arrayIndex int GetEnumerator() public IEnumerator<Type> GetEnumerator() Returns IEnumerator<Type> IndexOf(Type) public int IndexOf(Type item) Parameters item Type Returns int Insert(int, Type) public void Insert(int index, Type item) Parameters index int item Type Remove(Type) public bool Remove(Type item) Parameters item Type Returns bool RemoveAt(int) public void RemoveAt(int index) Parameters index int"
  },
  "api/CSF.Screenplay.Reporting.WritePermissionTester.html": {
    "href": "api/CSF.Screenplay.Reporting.WritePermissionTester.html",
    "title": "Class WritePermissionTester | Screenplay docs",
    "keywords": "Class WritePermissionTester Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Helper class to determine whether or not we have write permission to a specified file path. public class WritePermissionTester : ITestsPathForWritePermissions Inheritance object WritePermissionTester Implements ITestsPathForWritePermissions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods HasWritePermission(string) Gets a value indicating whether or not the current process has write permission to the specified file path. public bool HasWritePermission(string path) Parameters path string An absolute or relative file path. Returns bool true if the current process is able to write to the specified path; false if not. Remarks The path may be relative or absolute; if relative then it is treated as relative to the current working directory. This method will recurse in order to test the permissions for parent directories, if it finds a file or directory which does not exist. When testing for the writability of directories, this is performed by attempting to create a temporary file with a random file name; see GetRandomFileName(). If we are able to create such a file then it is assumed that we have full write permissions to the directory. In this scenario, the temporary file is deleted immediately after. This method will return false if we reach the root directory of the filesystem."
  },
  "api/CSF.Screenplay.Reporting.html": {
    "href": "api/CSF.Screenplay.Reporting.html",
    "title": "Namespace CSF.Screenplay.Reporting | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.Reporting Classes FormattableFormatter Implementation of IValueFormatter which formats objects that implement IFormattableValue. HumanizerFormatter A formatter which makes use of the Humanizer: https://github.com/Humanizr/Humanizer library to format a limited number of value types. JsonScreenplayReportReader Implementation of IDeserializesReport that deserializes a Screenplay report from a JSON stream. JsonScreenplayReporter An object which subscribes/listens to the events of IHasPerformanceEvents and which produces a JSON-formatted report from them. NameAndValue A simple model for a value that is to be included in a formatted ReportFragment, which has an associated name. NameFormatter Implementation of IValueFormatter which formats objects that implement IHasName. NoOpReporter A no-op implementation of IReporter which does nothing. PerformanceReportBuilder Builder for an instance of PerformanceReport. ReportFormat Model used for creating a ReportFragment, which includes the original report fragment template string, a reworked template string suitable for use with Format(string, params object[]) and the placeholder values to be inserted into that format. ReportFormatCreator Default implementation of IGetsReportFormat. ScreenplayReportBuilder Builder type accumulates PerformanceReportBuilder as performances occur within the Screenplay. ToStringFormatter Implementation of IValueFormatter which formats any object by using its default ToString() method, or returns the string <null> if the value is null. ValueFormatterExtensions Extension methods for IGetsValueFormatter. ValueFormatterProvider Implementation of IGetsValueFormatter which uses dependency injection services. ValueFormatterRegistry Default implementation of IFormatterRegistry which also serves as an object factory, by virtue of a service provider. WritePermissionTester Helper class to determine whether or not we have write permission to a specified file path. Interfaces IDeserializesReport An object which deserializes a Screenplay report from a stream. IFormattableValue An object which has its own functionality for generating a human-readable representation of itself for a Screenplay report. IFormatterRegistry A registry of the concrete types of IValueFormatter which are available for use by the Screenplay reporting functionality. IGetsReportFormat An object which can get a ReportFormat from a report format template and the associated values. IGetsValueFormatter An object which can select the most appropriate implementation of IValueFormatter from a IFormatterRegistry. IReporter Defines a reporter that subscribes to and processes events from a Screenplay event notifier. ITestsPathForWritePermissions An object which may test a file system path for writability. IValueFormatter An object which can format a value which appears within a Screenplay report."
  },
  "api/CSF.Screenplay.ScopeAndPerformance.html": {
    "href": "api/CSF.Screenplay.ScopeAndPerformance.html",
    "title": "Class ScopeAndPerformance | Screenplay docs",
    "keywords": "Class ScopeAndPerformance Namespace CSF.Screenplay Assembly CSF.Screenplay.dll A model which contains both an IPerformance and a dependency injection IServiceScope. public sealed class ScopeAndPerformance : IDisposable Inheritance object ScopeAndPerformance Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors ScopeAndPerformance(IPerformance, IServiceScope) Initialises a new instance of ScopeAndPerformance. public ScopeAndPerformance(IPerformance performance, IServiceScope scope) Parameters performance IPerformance The performance scope IServiceScope The scope Exceptions ArgumentNullException If any parameter is null. Properties Performance Gets the performance. public IPerformance Performance { get; } Property Value IPerformance Scope Gets the DI scope. public IServiceScope Scope { get; } Property Value IServiceScope Methods Dispose() public void Dispose()"
  },
  "api/CSF.Screenplay.Screenplay.html": {
    "href": "api/CSF.Screenplay.Screenplay.html",
    "title": "Class Screenplay | Screenplay docs",
    "keywords": "Class Screenplay Namespace CSF.Screenplay Assembly CSF.Screenplay.dll An object which represents a complete execution of Screenplay logic, which should include one or more Performance instances. public sealed class Screenplay : IHasServiceProvider Inheritance object Screenplay Implements IHasServiceProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods ScreenplayExtensions.CreateScopedPerformance(Screenplay, IList<IdentifierAndName>) ScreenplayExtensions.ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, int) ScreenplayExtensions.ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, CancellationToken) ScreenplayExtensions.ExecuteAsPerformanceAsync<T>(Screenplay, IList<IdentifierAndName>, CancellationToken) Remarks A Screenplay, when used as a noun (an instance of this class), refers to a complete execution of the Screenplay software. A Screenplay is composed of at least one Performance and typically contains many performances. When the Screenplay architecture is applied to automated testing, an instance of this class corresponds to a complete test run, where each test corresponds to a performance. End-user logic, such as test logic, rarely interacts directly with this class. That is because the Screenplay object is generally consumed only by integration logic. It is recommended to create instances of this type by adding Screenplay to a dependency injection IServiceCollection via the extension method AddScreenplay(IServiceCollection, Action<ScreenplayOptions>) and then resolving an instance of this class from the service provider. Alternatively, if you do not wish to configure a service collection manually and just want an instance of this type then use the static Create(Action<IServiceCollection>, Action<ScreenplayOptions>) method. The Screenplay object is used to create instances of Performance via the PerformanceFactory. You may wish to read a diagram showing how screenplays, performances, actors and performables relate to one another. Constructors Screenplay(IServiceProvider) Initialises a new instance of Screenplay. public Screenplay(IServiceProvider serviceProvider) Parameters serviceProvider IServiceProvider A service provider Remarks It is unlikely that developers should be executing this constructor directly. Consider using the static factory method Create(Action<IServiceCollection>, Action<ScreenplayOptions>). Alternatively, add Screenplay to an IServiceCollection using AddScreenplay(IServiceCollection, Action<ScreenplayOptions>) and then resolve an instance of this class from the service provider built from that service collection. Exceptions ArgumentNullException If serviceProvider is null. Properties ServiceProvider Gets a service provider/resolver instance associated with this object. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods BeginScreenplay() Execute this method from the consuming logic in order to inform the Screenplay architecture that the Screenplay has begun. public void BeginScreenplay() CompleteScreenplay() Execute this method from the consuming logic in order to inform the Screenplay architecture that the Screenplay is now complete. public void CompleteScreenplay() Create(Action<IServiceCollection>, Action<ScreenplayOptions>) Creates and returns a Screenplay, optionally including some dependency injection service customisations. public static Screenplay Create(Action<IServiceCollection> serviceCollectionCustomisations = null, Action<ScreenplayOptions> options = null) Parameters serviceCollectionCustomisations Action<IServiceCollection> An optional action which permits further customization of the service collection that is implicitly created by this method. options Action<ScreenplayOptions> An optional action to configure the Screenplay which is created by this method. Returns Screenplay A Screenplay instance created from a new service collection. Remarks Use this method to create an instance of Screenplay when you are not already using an IServiceCollection. This method creates a new service collection instance, adds Screenplay to it and then creates & returns the Screenplay object instance. If you already have an IServiceCollection and you wish to integrate Screenplay into it, then use the extension method AddScreenplay(IServiceCollection, Action<ScreenplayOptions>) instead. ExecuteAsPerformanceAsync(Func<IServiceProvider, CancellationToken, Task<bool?>>, IList<IdentifierAndName>, CancellationToken) Executes the specified logic as a Performance public Task ExecuteAsPerformanceAsync(Func<IServiceProvider, CancellationToken, Task<bool?>> performanceLogic, IList<IdentifierAndName> namingHierarchy = null, CancellationToken cancellationToken = default) Parameters performanceLogic Func<IServiceProvider, CancellationToken, Task<bool?>> The logic to be executed by the performance. namingHierarchy IList<IdentifierAndName> An optional naming hierarchy used to identify the performance. cancellationToken CancellationToken An optional cancellation token to abort the performance logic. Returns Task A task which completes when the performance's logic has completed. Remarks This method is the primary entry point for beginning a Screenplay Performance. This method begins a new Dependency Injection Scope, and within that scope starts the performance, which executes the specified performance logic: performanceLogic. The return value from the performance logic should conform to the semantics of the parameter value passed to FinishPerformance(bool?). The namingHierarchy may be used to give the performance a name, so that its results (and subsequent report) may be identified. This parameter has the same semantics as NamingHierarchy. Note that if the performanceLogic raises a PerformableException then this method will catch that exception and not rethrow. In that case: An event will be raised with the event bus: IHasPerformanceEvents, specifically PerformableFailed. This will contain details of the exception which occurred; subscribers to be informed that the performance has failed. The performance will be immediately terminated and placed into the Failed state. Any other exception, which does not derive from PerformableException, will not be caught by this method and will propagate outward. These exceptions will be interpreted as an error within the Screenplay architecture, since the Actor class will always catch and rethrow any exception encountered from any overload of PerformAsync, wrapped as the inner exception of a PerformableException. Exceptions ArgumentNullException If the performanceLogic is null. See Also Performance ScreenplayServiceCollectionExtensions"
  },
  "api/CSF.Screenplay.ScreenplayAssemblyAttribute.html": {
    "href": "api/CSF.Screenplay.ScreenplayAssemblyAttribute.html",
    "title": "Class ScreenplayAssemblyAttribute | Screenplay docs",
    "keywords": "Class ScreenplayAssemblyAttribute Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll An attribute used to mark an assembly which contains Screenplay-based tests. [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false)] public class ScreenplayAssemblyAttribute : TestActionAttribute, ITestAction Inheritance object Attribute TestActionAttribute ScreenplayAssemblyAttribute Implements ITestAction Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples Decorate your assembly with this attribute using the syntax [assembly: CSF.Screenplay.ScreenplayAssembly]. You may place this into any source file, outside of any type declaration. By convention it would be put into a dedicated source file within the Properties project directory. Remarks This attribute is the core of the NUnit3 test framework integration with Screenplay. In order to run tests with Screenplay, the assembly must be decorated with this attribute. This attribute has one mandatory parameter; that is the Type of a concrete implementation of IGetsScreenplay. That type will be instantiated by the NUnit3 integration and will be used to build and retrieve the Screenplay instance for running the Screenplay-based tests within the decorated assembly. Each test method must additionally be decorated with the ScreenplayAttribute in order to make it a Screenplay-based test. Constructors ScreenplayAssemblyAttribute(Type) Initializes a new instance of ScreenplayAssemblyAttribute. public ScreenplayAssemblyAttribute(Type factoryType) Parameters factoryType Type The concrete type of a class which implements IGetsScreenplay. Remarks The factoryType specified in this constructor must meet all of the following criteria: It must be a non-nullType which derives from IGetsScreenplay It must have a public parameterless constructor It must return a non-null instance of Screenplay from its GetScreenplay() method Properties Targets Provides the target for the action attribute public override ActionTargets Targets { get; } Property Value ActionTargets Methods AfterTest(ITest) Executed after each test is run public override void AfterTest(ITest test) Parameters test ITest The test that has just been run. BeforeTest(ITest) Executed before each test is run public override void BeforeTest(ITest test) Parameters test ITest The test that is going to be run. GetScreenplay() Gets the Screenplay which is to be used for tests contained in the current assembly. public Screenplay GetScreenplay() Returns Screenplay The Screenplay. Exceptions InvalidOperationException If the Screenplay factory used with the constructor to this attribute is invalid or fails to return a non-nullScreenplay instance. See Also ScreenplayAttribute"
  },
  "api/CSF.Screenplay.ScreenplayAttribute.html": {
    "href": "api/CSF.Screenplay.ScreenplayAttribute.html",
    "title": "Class ScreenplayAttribute | Screenplay docs",
    "keywords": "Class ScreenplayAttribute Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll Applied to a test method, indicates that decorated test is a Screenplay test. [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class ScreenplayAttribute : Attribute, ITestAction, ITestBuilder Inheritance object Attribute ScreenplayAttribute Implements ITestAction ITestBuilder Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks When a test method is decorated with this attribute then the test corresponding to that method will be executed via Screenplay. This means that the affected test method will be executed as an IPerformance. It also means that all parameters for the method will be provided by resolving them from the current performance's ServiceProvider. See the article on dependency injection in Screenplay for more information about what may be injected into test logic from DI, via the test method parameters. Remember that for this attribute to be effective, the Assembly which contains the test method must be decorated with ScreenplayAssemblyAttribute. If it is not, then the test will fail with an exception. Properties Targets Gets the targets for the attribute (when performing before/after test actions). public ActionTargets Targets { get; } Property Value ActionTargets The targets. Methods AfterTest(ITest) Executed after each test is run public void AfterTest(ITest test) Parameters test ITest The test that has just been run. BeforeTest(ITest) Executed before each test is run public void BeforeTest(ITest test) Parameters test ITest The test that is going to be run. BuildFrom(IMethodInfo, Test) Build one or more TestMethods from the provided MethodInfo. public IEnumerable<TestMethod> BuildFrom(IMethodInfo method, Test suite) Parameters method IMethodInfo The method to be used as a test suite Test The TestSuite to which the method will be added Returns IEnumerable<TestMethod> A TestMethod object See Also ScreenplayAssemblyAttribute"
  },
  "api/CSF.Screenplay.ScreenplayBinding.html": {
    "href": "api/CSF.Screenplay.ScreenplayBinding.html",
    "title": "Class ScreenplayBinding | Screenplay docs",
    "keywords": "Class ScreenplayBinding Namespace CSF.Screenplay Assembly CSF.Screenplay.SpecFlowPlugin.dll SpecFlow binding which uses hooks to coordinate the relevant Screenplay & IPerformance event invokers. [Binding] public class ScreenplayBinding Inheritance object ScreenplayBinding Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ScreenplayBinding(IServiceProvider) Initialises a new instance of ScreenplayBinding. public ScreenplayBinding(IServiceProvider serviceProvider) Parameters serviceProvider IServiceProvider The service provider Exceptions ArgumentNullException If the serviceProvider is null. Methods AfterScenario() Executed after each scenario. [AfterScenario(new string[] { })] public void AfterScenario() AfterTestRun() Executed after a test run. [AfterTestRun] public static void AfterTestRun() BeforeScenario() Executed before each scenario. [BeforeScenario(new string[] { })] public void BeforeScenario() BeforeTestRun() Executed before a test run. [BeforeTestRun] public static void BeforeTestRun()"
  },
  "api/CSF.Screenplay.ScreenplayExtensions.html": {
    "href": "api/CSF.Screenplay.ScreenplayExtensions.html",
    "title": "Class ScreenplayExtensions | Screenplay docs",
    "keywords": "Class ScreenplayExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Extension methods for the Screenplay type. public static class ScreenplayExtensions Inheritance object ScreenplayExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CreateScopedPerformance(Screenplay, IList<IdentifierAndName>) Creates a new IPerformance within its own newly-created Dependency Injection scope. public static ScopeAndPerformance CreateScopedPerformance(this Screenplay screenplay, IList<IdentifierAndName> namingHierarchy = null) Parameters screenplay Screenplay The Screenplay from which to create the performance namingHierarchy IList<IdentifierAndName> An optional collection of identifiers and names providing the hierarchical name of this performance; see NamingHierarchy for more information. Returns ScopeAndPerformance A ScopeAndPerformance containing the newly-created performance as well as the newly-started DI scope. Remarks This method includes the consequence/side-effect of creating a new dependency injection scope from the ServiceProvider associated with the specified Screenplay. That scope will be associated with the created performance and will be returned as part of the return of this method. Please use the Dispose() method the returned object when you are finished with the performance. This ensures that the DI scope and all associated resources (including the performance) will also be properly disposed-of. Exceptions ArgumentNullException If screenplay is null. ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, int) Executes the specified logic as a Performance, synchronously. public static void ExecuteAsPerformance(this Screenplay screenplay, Func<IServiceProvider, bool?> performanceLogic, IList<IdentifierAndName> namingHierarchy = null, int timeoutMiliseconds = 0) Parameters screenplay Screenplay The screenplay with which to execute the logic. performanceLogic Func<IServiceProvider, bool?> The logic to be executed by the performance. namingHierarchy IList<IdentifierAndName> An optional naming hierarchy used to identify the performance. timeoutMiliseconds int If set to a non-zero positive value, then the performance logic will be aborted after the specified timeout in milliseconds. Remarks This method is the primary entry point for beginning a Screenplay Performance. This method begins a new Dependency Injection Scope, and within that scope starts the performance, which executes the specified performance logic: performanceLogic. The return value from the performance logic should conform to the semantics of the parameter value passed to FinishPerformance(bool?). The namingHierarchy may be used to give the performance a name, so that its results (and subsequent report) may be identified. This parameter has the same semantics as NamingHierarchy. Use this method only if ExecuteAsPerformanceAsync(Func<IServiceProvider, CancellationToken, Task<bool?>>, IList<IdentifierAndName>, CancellationToken) is not viable. This method executes the logic asynchronously, as is the architecture of Screenplay, but then uses Wait(CancellationToken) to convert the asynchronous result into a synchronous one. If timeoutMiliseconds is not specified, or specified with a zero value then there will be no timeout applied to the performance's logic. If specified with a positive integer then the performance logic will be aborted if the specified timeout (in milliseconds) is exceeded. Please be aware that - as with Wait(CancellationToken) - if the timeout duration is exceded, the synchronous performance logic is not actually aborted. The thread on which this method is executed will stop waiting for the thread on which the performance logic is running, but the performance logic thread will still continue, typically to completion. All this means is that when the performance logic eventually does complete, its results are discarded because the Screenplay 'gave up waiting' for it. Exceptions ArgumentNullException If either screenplay or performanceLogic is null. ArgumentOutOfRangeException If timeoutMiliseconds is a negative number. See Also ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, CancellationToken) ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, CancellationToken) Executes the specified logic as a Performance, synchronously. public static void ExecuteAsPerformance(this Screenplay screenplay, Func<IServiceProvider, bool?> performanceLogic, IList<IdentifierAndName> namingHierarchy, CancellationToken cancellationToken) Parameters screenplay Screenplay The screenplay with which to execute the logic. performanceLogic Func<IServiceProvider, bool?> The logic to be executed by the performance. namingHierarchy IList<IdentifierAndName> A naming hierarchy used to identify the performance; if null then an empty name will be used. cancellationToken CancellationToken A cancellation token, which if cancelled will abort waiting for performanceLogic to complete. Remarks This method is the primary entry point for beginning a Screenplay Performance. This method begins a new Dependency Injection Scope, and within that scope starts the performance, which executes the specified performance logic: performanceLogic. The return value from the performance logic should conform to the semantics of the parameter value passed to FinishPerformance(bool?). The namingHierarchy may be used to give the performance a name, so that its results (and subsequent report) may be identified. This parameter has the same semantics as NamingHierarchy. Use this method only if ExecuteAsPerformanceAsync(Func<IServiceProvider, CancellationToken, Task<bool?>>, IList<IdentifierAndName>, CancellationToken) is not viable. This method executes the logic asynchronously, as is the architecture of Screenplay, but then uses Wait(CancellationToken) to convert the asynchronous result into a synchronous one. If cancellationToken is not specified then no cancellation/abort logic will be applied. If specified, and the token is cancelled, then the Screenplay will abort waiting for the performance logic to complete. Please be aware that - as with Wait(CancellationToken) - if the token is cancelled, the synchronous performance logic is not actually aborted. The thread on which this method is executed will stop waiting for the thread on which the performance logic is running, but the performance logic thread will still continue, typically to completion. All this means is that when the performance logic eventually does complete, its results are discarded because the Screenplay 'gave up waiting' for it. Exceptions ArgumentNullException If either screenplay or performanceLogic is null. ExecuteAsPerformanceAsync<T>(Screenplay, IList<IdentifierAndName>, CancellationToken) Executes the logic with a specified imlpementation of IHostsPerformance as a Performance public static Task ExecuteAsPerformanceAsync<T>(this Screenplay screenplay, IList<IdentifierAndName> namingHierarchy = null, CancellationToken cancellationToken = default) where T : IHostsPerformance Parameters screenplay Screenplay The screenplay with which to execute the logic. namingHierarchy IList<IdentifierAndName> An optional naming hierarchy used to identify the performance. cancellationToken CancellationToken An optional cancellation token to abort the performance logic. Returns Task A task which completes when the performance's logic has completed. Type Parameters T The concrete type of an implementation of IHostsPerformance which contains the performance logic. Remarks This method is a convenient way to execute performances, where the logic for the performance is contained within a concrete type. This method begins a new Dependency Injection Scope, and within that scope starts the performance. It resolves an instance of the specified T from the DI container, and executes its ExecutePerformanceAsync(CancellationToken) method to get the performance result. An advantage of using this method is that the performance logic is encapsulated within a class, and that the service provider is used to resolve only a single object instance, thus avoiding the service locator anti-pattern. The namingHierarchy may be used to give the performance a name, so that its results (and subsequent report) may be identified. This parameter has the same semantics as NamingHierarchy. Note that if the specified implementation of IHostsPerformance raises a PerformableException then this method will catch that exception and not rethrow. In that case: An event will be raised with the event bus: IHasPerformanceEvents, specifically PerformableFailed. This will contain details of the exception which occurred; subscribers to be informed that the performance has failed. The performance will be immediately terminated and placed into the Failed state. Any other exception, which does not derive from PerformableException, will not be caught by this method and will propagate outward. These exceptions will be interpreted as an error within the Screenplay architecture, since the Actor class will always catch and rethrow any exception encountered from any overload of PerformAsync, wrapped as the inner exception of a PerformableException. Exceptions ArgumentNullException If the screenplay is null. See Also IHostsPerformance"
  },
  "api/CSF.Screenplay.ScreenplayLocator.html": {
    "href": "api/CSF.Screenplay.ScreenplayLocator.html",
    "title": "Class ScreenplayLocator | Screenplay docs",
    "keywords": "Class ScreenplayLocator Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll A small static service locator of sorts, dedicated to getting an appropriate instance of Screenplay for a specified test object. public static class ScreenplayLocator Inheritance object ScreenplayLocator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This type uses reflection to find the ScreenplayAssemblyAttribute which decorates the assembly in which the specified object (a test, a test method or the assembly itself) resides. It additionally caches the results in-memory to avoid repetitive reflection, only to retrieve the same results. Methods GetScreenplay(IMethodInfo) Gets a Screenplay instance from the specified test method. public static Screenplay GetScreenplay(IMethodInfo method) Parameters method IMethodInfo The test method for which to get a Screenplay object. Returns Screenplay The Screenplay object for the specified test method. Remarks This method makes use of the ScreenplayAssemblyAttribute which decorates the assembly in which the specified method was declared, to get a Screenplay object instance applicable to the test method. If the method's assembly is not decorated with the Screenplay assembly attribute then this method will raise an exception. Exceptions ArgumentNullException If method is null. ArgumentException If the method's assembly is null or is not decorated with ScreenplayAssemblyAttribute. GetScreenplay(ITest) Gets a Screenplay instance from the specified test. public static Screenplay GetScreenplay(ITest test) Parameters test ITest The test for which to get a Screenplay object. Returns Screenplay The Screenplay object for the specified test. Remarks This method makes use of the ScreenplayAssemblyAttribute which decorates the assembly in which the specified test's method was declared, to get a Screenplay object instance applicable to the test method. If the test's method's assembly is not decorated with the Screenplay assembly attribute then this method will raise an exception. Exceptions ArgumentNullException If test is null. ArgumentException If the test's method's assembly is null or is not decorated with ScreenplayAssemblyAttribute. GetScreenplay(Assembly) Gets a Screenplay instance from the specified Assembly. public static Screenplay GetScreenplay(Assembly assembly) Parameters assembly Assembly The test assembly for which to get a Screenplay object. Returns Screenplay The Screenplay object for the specified assembly. Remarks This method makes use of the ScreenplayAssemblyAttribute which decorates the assembly to get a Screenplay object instance for that assembly. If the specified assembly is not decorated with the Screenplay assembly attribute then this method will raise an exception. Exceptions ArgumentNullException If assembly is null. ArgumentException If the assembly is not decorated with ScreenplayAssemblyAttribute."
  },
  "api/CSF.Screenplay.ScreenplayOptions.html": {
    "href": "api/CSF.Screenplay.ScreenplayOptions.html",
    "title": "Class ScreenplayOptions | Screenplay docs",
    "keywords": "Class ScreenplayOptions Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Options model which permits the customization/configuration of Screenplay in DI. public sealed class ScreenplayOptions Inheritance object ScreenplayOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Developer note: In an ideal world, this type would be registered into DI via the Options pattern: https://learn.microsoft.com/en-us/dotnet/core/extensions/options. Unfortunately, the BoDi DI container used by SpecFlow (which I wish to support with Screenplay) does not support the appropriate methods/logic to register the neccesary services for Options. This is why this object uses a somewhat homebrew version of options, without making use of the official libraries. Properties OnBeginScreenplayActions Gets an ordered collection of actions which should be executed when the Screenplay begins, before the first IPerformance starts. public List<Action<IServiceProvider>> OnBeginScreenplayActions { get; } Property Value List<Action<IServiceProvider>> Remarks Each of the actions in this configuration parameter are executed when the BeginScreenplay() method is invoked. By default this collection contains one item. This will initialise an instance of IReporter and subscribe it to the event bus: IHasPerformanceEvents, which will activate Screenplay reporting. You may add further callbacks if you wish, to extend Screenplay; they are executed in the order in which they appear in this collection. OnEndScreenplayActions Gets an ordered collection of actions which should be executed when the Screenplay finished, after the last IPerformance ends. public List<Action<IServiceProvider>> OnEndScreenplayActions { get; } Property Value List<Action<IServiceProvider>> Remarks Each of the actions in this configuration parameter are executed when the CompleteScreenplay() method is invoked. By default this collection contains one item, which disposes of the reporting infrastructure. You may add further callbacks if you wish, to extend Screenplay; they are executed in the order in which they appear in this collection. Be very wary of the use of this property. This is because it is usual for the end of a Screenplay to be triggered by the unloading of the the assemblies in the current process. If the logic triggered by this is nontrivial, it's very likely that it will be terminated early by the ending of the overall process. PerformanceEventsConfig An optional callback/action which exposes the various IHasPerformanceEvents which may be subscribed-to in order to be notified of the progress of a screenplay. public Action<IHasPerformanceEvents> PerformanceEventsConfig { get; set; } Property Value Action<IHasPerformanceEvents> Remarks The implementation of IHasPerformanceEvents is an event publisher which emits notifications when key evens occur during the lifetime of a Screenplay and its performances: IPerformance. If you wish, you may subscribe to these events from your own logic in order to develop new functionality or extend Screenplay. There is no need to add an explicit subscription to any events for the reporting infrastructure. Screenplay will automatically subscribe to this object from the reporting mechanism, unless the value of ReportPath means that reporting is disabled. ReportPath Gets a file system path at which a Screenplay report file will be written. public string ReportPath { get; set; } Property Value string Remarks As a Screenplay executes each IPerformance, it accumulates data relating to those performances, via its reporting mechanism. This information is then written to a JSON-formatted report file, which is saved at the path specified by this property. Once the Screenplay has completed this file may be inspected, converted into a different format and otherwise used to learn-about and diagnose the Screenplay. If this value is set to a relative file path, then it will be relative to the current working directory. If using Screenplay with a software testing integration, then this directory might not be easily determined. The default value for this property is a relative file path in the current working directory, using the filename ScreenplayReport_[timestamp].json where [timestamp] is replaced by the current UTC date & time in a format which is similar to ISO 8601, except that the : characters separating the hours, minutes and second are omitted. This is because they are typically not legal filename characters. A sample of a Screenplay Report filename using this default path is ScreenplayReport_2024-10-04T192345Z.json. If this property is set to null, or an empty/whitespace-only string, or if the path is not writable, then the reporting functionality will be disabled and no report will be written. ValueFormatters Gets a collection of concrete Type which implement IValueFormatter, which will be used to format values which are to appear in Screenplay reports. public IFormatterRegistry ValueFormatters { get; } Property Value IFormatterRegistry Remarks As noted in the documentation for IFormatterRegistry, the types in this collection are considered for use in reverse-collection-order. In other words, they will be tested using CanFormat(object) from last-to-first in this collection. Thus, generalized formatters should be placed at the beginning of this collection, where more specialized formatters should be placed toward the end. Make use of Add(T) to add new formatters to the end of this collection. It comes pre-loaded with three generalised formatters by default, in the following order. ToStringFormatter - a default/fallback implementation which may format any value at all HumanizerFormatter - a formatter for dates, times & time spans which uses the Humanizer library NameFormatter - which formats values that implement IHasName by emitting their name FormattableFormatter - which formats values that implement IFormattableValue There is no need to register/add any types listed in this registry into dependency injection. The methods which accept a configuration action of ScreenplayOptions will iterate through this collection and add every one of the implementation types found as transient-lifetime services in dependency injection."
  },
  "api/CSF.Screenplay.ScreenplayPlugin.html": {
    "href": "api/CSF.Screenplay.ScreenplayPlugin.html",
    "title": "Class ScreenplayPlugin | Screenplay docs",
    "keywords": "Class ScreenplayPlugin Namespace CSF.Screenplay Assembly CSF.Screenplay.SpecFlowPlugin.dll The Screenplay plugin for SpecFlow. public class ScreenplayPlugin : IRuntimePlugin Inheritance object ScreenplayPlugin Implements IRuntimePlugin Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This plugin class is the test framework integration for SpecFlow. Crucially it adds the Screenplay architecture to the SpecFlow architecture. Becuase this plugin leverages the SpecFlow/BoDi IObjectContainer, it is likely incompatible with other plugins which integrate with third party Dependency Injection libraries. This may be easily worked-around, though. If you are using a third-party DI plugin then do not use this plugin. Instead use the AddScreenplay(IServiceCollection, Action<ScreenplayOptions>) method to add Screenplay to that third-party DI system, when customising the dependency registrations. Adding Screenplay in that way is equivalent to the work done by this plugin. If you wish to further customise the dependency injection, such as adding injectable services for abilities or implementations of IPersona, add them to the relevant DI container. When using SpecFlow's default BoDi container this is described in the following article https://docs.specflow.org/projects/specflow/en/latest/Bindings/Context-Injection.html#advanced-options. If using a third-party DI container then you should use that container's appropriate mechanism of adding services. Properties Screenplay Provides static access to the Screenplay instance. public static Screenplay Screenplay { get; } Property Value Screenplay Remarks This is required because the bindings for beginning/ending the Screenplay in ScreenplayBinding must be static: https://docs.specflow.org/projects/specflow/en/latest/Bindings/Hooks.html#supported-hook-attributes. Methods Initialize(RuntimePluginEvents, RuntimePluginParameters, UnitTestProviderConfiguration) public void Initialize(RuntimePluginEvents runtimePluginEvents, RuntimePluginParameters runtimePluginParameters, UnitTestProviderConfiguration unitTestProviderConfiguration) Parameters runtimePluginEvents RuntimePluginEvents runtimePluginParameters RuntimePluginParameters unitTestProviderConfiguration UnitTestProviderConfiguration"
  },
  "api/CSF.Screenplay.ScreenplayServiceCollectionExtensions.html": {
    "href": "api/CSF.Screenplay.ScreenplayServiceCollectionExtensions.html",
    "title": "Class ScreenplayServiceCollectionExtensions | Screenplay docs",
    "keywords": "Class ScreenplayServiceCollectionExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Extension methods for IServiceCollection relating to Screenplay. public static class ScreenplayServiceCollectionExtensions Inheritance object ScreenplayServiceCollectionExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddScreenplay(IServiceCollection, Action<ScreenplayOptions>) Adds the Screenplay framework to the specified service collection. public static IServiceCollection AddScreenplay(this IServiceCollection services, Action<ScreenplayOptions> options = null) Parameters services IServiceCollection An IServiceCollection options Action<ScreenplayOptions> An optional configuration action, used to configure Screenplay in DI Returns IServiceCollection The service collection, so that calls may be chained Remarks Use this method to add Screenplay to an existing service collection; if you just want an instance of Screenplay and do not care for integrating it with a service collection of your own then consider the convenience method Create(Action<IServiceCollection>, Action<ScreenplayOptions>). If you choose to provide any configuration via the options parameter, do not 'capture' the ScreenplayOptions object outside the closure. This object is added to dependency injection as a singleton, and so if it is modified outside of this configuration action then the integrity of the Screenplay dependency injection may be compromised. Exceptions ArgumentNullException If services is null."
  },
  "api/CSF.Screenplay.ScreenplaySteps.html": {
    "href": "api/CSF.Screenplay.ScreenplaySteps.html",
    "title": "Class ScreenplaySteps | Screenplay docs",
    "keywords": "Class ScreenplaySteps Namespace CSF.Screenplay Assembly CSF.Screenplay.SpecFlowPlugin.dll A subclass of TechTalk.SpecFlow.Steps provided for convenience of SpecFlow 3.x users to avoid naming conflicts. public abstract class ScreenplaySteps : Steps, IContainerDependentObject Inheritance object Steps ScreenplaySteps Implements IContainerDependentObject Inherited Members Steps.AssertInitialized() Steps.TestRunner Steps.ScenarioContext Steps.FeatureContext Steps.TestThreadContext Steps.StepContext object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks In SpecFlow 3.x, the Steps class has three methods named Given, When & Then which can cause a naming conflict with the same-named methods of PerformanceStarter. If you using the performance starter in the recommended way, then the methods of these two types can become ambiguous and force the developer to write additional boilerplate which spoils the ease-of-comprehension for Screenplay-based test logic. This subclass of Steps provides a workaround to that situation. Instead of deriving from the SpecFlow Steps class and including using static CSF.Screenplay.PerformanceStarter; at the top of your source file, have your bindings derive from this class instead. This provides Given, When, Then methods which have the same functionality as those in PerformanceStarter but in a manner which will not cause a name-resolution conflict. Note that in SpecFlow 4.x and up, this problem is irrelevant; there is no gain in using this subclass over the using static technique. As noted here https://docs.specflow.org/projects/specflow/en/latest/Bindings/Calling-Steps-from-Step-Definitions.html and here https://github.com/SpecFlowOSS/SpecFlow/issues/1733 the Give, When & Then methods upon the SpecFlow Steps class were removed in v4.x. This means that the naming conflict won't be present and that there is no need for your bindings to derive from this class instead of the official Steps class. Indeed, Screenplay could be described as a specific implementation of the 'driver pattern', which is noted in the linked Github issue as a best-practice alternative to calling-steps-from-steps. Methods Given(Actor) Returns the actor instance, as an ICanPerformGiven, in order to perform precondition actions. public static ICanPerformGiven Given(Actor actor) Parameters actor Actor The actor. Returns ICanPerformGiven Remarks This method is equivalent to Given(Actor) but is provided as a convenience method in a subclass of TechTalk.SpecFlow.Steps to avoid method-name resolution conflicts. See the remarks on ScreenplaySteps for more info. Then(Actor) Returns the actor instance, as an ICanPerformThen, in order to get information which are required to make assertions that the scenario has completed successfully. public static ICanPerformThen Then(Actor actor) Parameters actor Actor The actor. Returns ICanPerformThen Remarks This method is equivalent to Then(Actor) but is provided as a convenience method in a subclass of TechTalk.SpecFlow.Steps to avoid method-name resolution conflicts. See the remarks on ScreenplaySteps for more info. When(Actor) Returns the actor instance, as an ICanPerformWhen, in order to perform actions which exercise the system under test. public static ICanPerformWhen When(Actor actor) Parameters actor Actor The actor. Returns ICanPerformWhen Remarks This method is equivalent to When(Actor) but is provided as a convenience method in a subclass of TechTalk.SpecFlow.Steps to avoid method-name resolution conflicts. See the remarks on ScreenplaySteps for more info."
  },
  "api/CSF.Screenplay.ServiceCollectionAdapter.html": {
    "href": "api/CSF.Screenplay.ServiceCollectionAdapter.html",
    "title": "Class ServiceCollectionAdapter | Screenplay docs",
    "keywords": "Class ServiceCollectionAdapter Namespace CSF.Screenplay Assembly CSF.Screenplay.SpecFlowPlugin.dll Adapter class which allows a SpecFlow/BoDi IObjectContainer to be used as an IServiceCollection. public class ServiceCollectionAdapter : IServiceCollection, IList<ServiceDescriptor>, ICollection<ServiceDescriptor>, IEnumerable<ServiceDescriptor>, IEnumerable Inheritance object ServiceCollectionAdapter Implements IServiceCollection IList<ServiceDescriptor> ICollection<ServiceDescriptor> IEnumerable<ServiceDescriptor> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods ScreenplayServiceCollectionExtensions.AddScreenplay(IServiceCollection, Action<ScreenplayOptions>) Remarks This adapter class is highly limited and supports only a tiny subset of IServiceCollection's functionality. For many methods, and the indexer for ServiceDescriptor, it will raise NotSupportedException. The only functionality supported is IsReadOnly and Add(ServiceDescriptor). Constructors ServiceCollectionAdapter(IObjectContainer) Initialises an instance of ServiceCollectionAdapter. public ServiceCollectionAdapter(IObjectContainer wrapped) Parameters wrapped IObjectContainer The BoDi object container Exceptions ArgumentNullException If wrapped is null. Properties Count Not supported, always returns zero. public int Count { get; } Property Value int IsReadOnly Partially supported, always returns false public bool IsReadOnly { get; } Property Value bool this[int] Not supported; always throws NotSupportedException. public ServiceDescriptor this[int index] { get; set; } Parameters index int Property Value ServiceDescriptor Exceptions NotSupportedException Always thrown Methods Add(ServiceDescriptor) Partially-supported, will add the specified service descriptor to the current object container. public void Add(ServiceDescriptor item) Parameters item ServiceDescriptor The service descriptor Remarks This method supports only transient or singleton services. If the Lifetime present on the item specified is Scoped then the service descriptor will not be added and will be silently ignored. In reality, the Specflow BoDi object container only really supports singleton services at this level. So, any services added as Transient will actually become singletons here. Whilst the BoDi container does support scoped services, they must be added directly to the scope instance and cannot be added in advance. Exceptions ArgumentNullException If item is null. ArgumentException If the item has a nullServiceType. Clear() Not supported; always throws NotSupportedException. public void Clear() Exceptions NotSupportedException Always thrown Contains(ServiceDescriptor) Not supported; always throws NotSupportedException. public bool Contains(ServiceDescriptor item) Parameters item ServiceDescriptor Returns bool Exceptions NotSupportedException Always thrown CopyTo(ServiceDescriptor[], int) Not supported; always throws NotSupportedException. public void CopyTo(ServiceDescriptor[] array, int arrayIndex) Parameters array ServiceDescriptor[] arrayIndex int Exceptions NotSupportedException Always thrown GetEnumerator() Not supported; always throws NotSupportedException. public IEnumerator<ServiceDescriptor> GetEnumerator() Returns IEnumerator<ServiceDescriptor> Exceptions NotSupportedException Always thrown IndexOf(ServiceDescriptor) Not supported; always throws NotSupportedException. public int IndexOf(ServiceDescriptor item) Parameters item ServiceDescriptor Returns int Exceptions NotSupportedException Always thrown Insert(int, ServiceDescriptor) Not supported; always throws NotSupportedException. public void Insert(int index, ServiceDescriptor item) Parameters index int item ServiceDescriptor Exceptions NotSupportedException Always thrown Remove(ServiceDescriptor) Not supported; always throws NotSupportedException. public bool Remove(ServiceDescriptor item) Parameters item ServiceDescriptor Returns bool Exceptions NotSupportedException Always thrown RemoveAt(int) Not supported; always throws NotSupportedException. public void RemoveAt(int index) Parameters index int Exceptions NotSupportedException Always thrown"
  },
  "api/CSF.Screenplay.ServiceProviderAdapter.html": {
    "href": "api/CSF.Screenplay.ServiceProviderAdapter.html",
    "title": "Class ServiceProviderAdapter | Screenplay docs",
    "keywords": "Class ServiceProviderAdapter Namespace CSF.Screenplay Assembly CSF.Screenplay.SpecFlowPlugin.dll Adapter class which allows a SpecFlow/BoDi IObjectContainer to be used as an IServiceProvider. public class ServiceProviderAdapter : IServiceProvider Inheritance object ServiceProviderAdapter Implements IServiceProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ServiceProviderAdapter(IObjectContainer) Initialises an instance of ServiceProviderAdapter. public ServiceProviderAdapter(IObjectContainer wrapped) Parameters wrapped IObjectContainer The BoDi object container Exceptions ArgumentNullException If wrapped is null. Methods GetService(Type) public object GetService(Type serviceType) Parameters serviceType Type Returns object"
  },
  "api/CSF.Screenplay.StageExtensions.html": {
    "href": "api/CSF.Screenplay.StageExtensions.html",
    "title": "Class StageExtensions | Screenplay docs",
    "keywords": "Class StageExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Extension methods for IStage. public static class StageExtensions Inheritance object StageExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Spotlight<TPersona>(IStage) Places an actor matching the specified persona into the spotlight, making them 'the current actor' on this stage. public static Actor Spotlight<TPersona>(this IStage stage) where TPersona : class, IPersona Parameters stage IStage The stage on which to spotlight the actor. Returns Actor The actor instance which was placed into the spotlight. Type Parameters TPersona A concrete type of IPersona from which to get an actor. Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the actor derived from the persona. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If actor indicated by the persona is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. When spotlighting a persona, the actor instance is retrieved from an ICast based upon that same persona. See GetActor(IPersona) for more information. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). This method is the recommended way of putting an actor based upon a persona in the spotlight, as it takes care of resolving the persona from dependency injection automatically. Exceptions ArgumentNullException If the actor is null."
  },
  "api/CSF.Screenplay.WebApis.Endpoint-1.html": {
    "href": "api/CSF.Screenplay.WebApis.Endpoint-1.html",
    "title": "Class Endpoint<TResult> | Screenplay docs",
    "keywords": "Class Endpoint<TResult> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll A Web API endpoint which has no expected request payload and which is expected to return a response body that exposes a strongly-typed object. public class Endpoint<TResult> : EndpointBase, IHasName Type Parameters TResult The type of object which is expected to be exposed by the HTTP response content Inheritance object EndpointBase Endpoint<TResult> Implements IHasName Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. The manner in which this endpoint exposes the strongly typed response object is undefined within the endpoint itself. It is down to a performable implementation to deserialize the result object from the HTTP response content. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should overrideGetHttpRequestMessageBuilder() with a method that calls the base implementation and then further manipulates the message builder before returning it. When using or deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors Endpoint(string, HttpMethod) Initializes a new instance of Endpoint<TResult> with a relative URI and an optional HTTP method. public Endpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Endpoint(Uri, HttpMethod) Initializes a new instance of Endpoint<TResult> with a URI and an optional HTTP method. public Endpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder() Gets a HttpRequestMessageBuilder from the state of the current instance. public virtual HttpRequestMessageBuilder<TResult> GetHttpRequestMessageBuilder() Returns HttpRequestMessageBuilder<TResult> An HTTP request message builder See Also EndpointBase Endpoint ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResponse> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.Endpoint.html": {
    "href": "api/CSF.Screenplay.WebApis.Endpoint.html",
    "title": "Class Endpoint | Screenplay docs",
    "keywords": "Class Endpoint Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll A Web API endpoint which has no expected request payload and which is not expected to return a response body. public class Endpoint : EndpointBase, IHasName Inheritance object EndpointBase Endpoint Implements IHasName Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should overrideGetHttpRequestMessageBuilder() with a method that calls the base implementation and then further manipulates the message builder before returning it. When using or deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors Endpoint(string, HttpMethod) Initializes a new instance of Endpoint with a relative URI and an optional HTTP method. public Endpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Endpoint(Uri, HttpMethod) Initializes a new instance of Endpoint with a URI and an optional HTTP method. public Endpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder() Gets a HttpRequestMessageBuilder from the state of the current instance. public virtual HttpRequestMessageBuilder GetHttpRequestMessageBuilder() Returns HttpRequestMessageBuilder An HTTP request message builder See Also EndpointBase Endpoint<TResult> ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResponse> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.EndpointBase.html": {
    "href": "api/CSF.Screenplay.WebApis.EndpointBase.html",
    "title": "Class EndpointBase | Screenplay docs",
    "keywords": "Class EndpointBase Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Abstract base class for types which represent web API endpoints. public abstract class EndpointBase : IHasName Inheritance object EndpointBase Implements IHasName Derived Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResponse> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks An endpoint is broadly a description of a Web API URL and the corresponding HTTP method (aka \"verb\") such as GET or POST. Instances of endpoints (types which derive from this base class) are typically stored as static readonly values in Screenplay-based logic. Here, they can be reused by tasks or other performables. Choose an appropriate implementation of this type based upon your intended use case. Endpoints which expect the API to return a strongly-typed result within the response body include a generic type parameter for the type of that result object. Also, endpoints which expect a request body: \"parameterized endpoints\" include a generic type parameter for the type of that request payload. There are also specialisations of these parameterized endpoint classes for those which expect an object serialized to JSON as their request payload. When writing custom endpoints, do not derive directly from this type. Usually one of the following pre-written endpoint types will be suitable for your use case. If not, pick the one which most closely matches your use-case and derive from that. Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResponse> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult> For more information, see the documentation article for using web APIs. Constructors EndpointBase(string, HttpMethod) Initializes a new instance of a type which derives from EndpointBase with a relative URI and an optional HTTP method. protected EndpointBase(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). EndpointBase(Uri, HttpMethod) Initializes a new instance of a type which derives from EndpointBase with a URI and an optional HTTP method. protected EndpointBase(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Properties Name Gets the human-readable name of the current object. public virtual string Name { get; init; } Property Value string Examples For an endpoint implementation which represents a GET request to a user profile API, this property could be overridden so that it includes the user ID of the user which is requested. Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Where it comes to endpoints, it is normal that the human-readable name might be influenced by state which is held within the specific endpoint implementation. In these cases, developers are encouraged to override this property, providing a name which includes the relevant values. Timeout Gets or sets an optional timeout duration for requests built from this endpoint. public TimeSpan? Timeout { get; init; } Property Value TimeSpan? Remarks If this set to a non-null value, then the HTTP client used to make the request will include cancellation after an amount of time (equal to this timespan) has passed. This logic is handled within the MakeWebApiRequests action. If this action is not used then this timeout might not be honoured. The logic for honouring this timeout is contained within the performables which are shipped with this library: SendTheHttpRequest SendTheHttpRequestAndGetTheResponse<TResponse> SendTheHttpRequestAndGetJsonResponse<TResponse> If different performables are used to interact with the current endpoint then they must implement any timeout-related logic themselves, or else this value will not be honoured. Methods GetBaseHttpRequestMessageBuilder() Gets a HttpRequestMessageBuilder from the state of the current instance. protected HttpRequestMessageBuilder GetBaseHttpRequestMessageBuilder() Returns HttpRequestMessageBuilder An HTTP request message builder Remarks Derived types should make use of this method to get the request message builder from the state of this base class. They may then further-customize the message builder according to their own logic. The message builder returned from this method will respect the following state from the endpoint. The request URI specified via the constructor The request method, if specified via the constructor The Name of this endpoint The Timeout for requests to this endpoint, if specified GetBaseHttpRequestMessageBuilder<TResponse>() Gets a HttpRequestMessageBuilder<TResponse> from the state of the current instance, with information about the expected response type. protected HttpRequestMessageBuilder<TResponse> GetBaseHttpRequestMessageBuilder<TResponse>() Returns HttpRequestMessageBuilder<TResponse> An HTTP request message builder Type Parameters TResponse Remarks Derived types which expect a strongly-typed response from the API should make use of this method to get the request message builder from the state of this base class. They may then further-customize the message builder according to their own logic. The message builder returned from this method will respect the following state from the endpoint. The request URI specified via the constructor The request method, if specified via the constructor The Name of this endpoint The Timeout for requests to this endpoint, if specified See Also Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResponse> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.HttpRequestMessageBuilder-1.html": {
    "href": "api/CSF.Screenplay.WebApis.HttpRequestMessageBuilder-1.html",
    "title": "Class HttpRequestMessageBuilder<TResponse> | Screenplay docs",
    "keywords": "Class HttpRequestMessageBuilder<TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An object which can create an HttpRequestMessage for use with an HTTP client, which is expected to expose a response of a particular type. public record HttpRequestMessageBuilder<TResponse> : HttpRequestMessageBuilder, IHasName, IFormattableValue, IEquatable<HttpRequestMessageBuilder>, IEquatable<HttpRequestMessageBuilder<TResponse>> Type Parameters TResponse The type of the response expected from the endpoint to which this request would be sent. Inheritance object HttpRequestMessageBuilder HttpRequestMessageBuilder<TResponse> Implements IHasName IFormattableValue IEquatable<HttpRequestMessageBuilder> IEquatable<HttpRequestMessageBuilder<TResponse>> Inherited Members HttpRequestMessageBuilder.RequestUri HttpRequestMessageBuilder.Method HttpRequestMessageBuilder.Content HttpRequestMessageBuilder.Version HttpRequestMessageBuilder.Headers HttpRequestMessageBuilder.Name HttpRequestMessageBuilder.Timeout HttpRequestMessageBuilder.VersionPolicy HttpRequestMessageBuilder.Options HttpRequestMessageBuilder.CreateRequestMessage() HttpRequestMessageBuilder.FormatForReport() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Please note that this type differs in form depending upon the .NET version under which it is consumed. If consuming this type from logic which targets .NET Standard 2.0 or .NET Framework 4.6.2 then this type is a class. In that scenario its properties are mutable and the developer should take care to ensure that they do not mutate/alter its state inadvertently. Developers should ensure that they manually copy the state from the current instance into a new instance instead of modifying an existing instance. In these target frameworks, a Clone method has been provided to assist with this. When consuming this from .NET 5 or higher, this type is instead a record and is immutable by design. All properties are init-only. Additionally, in .NET 5+, some additional properties are available, supporting features of HttpRequestMessage which are unavailable in lower .NET versions. When using .NET 5, developers may use nondestructive mutation with the with keyword/expression to create a copy of the current instance but with some differences. This difference between this type and its non-generic counterpart is that this type includes generic information about the expected response type. This can aid subsequent type-safety in consuming logic."
  },
  "api/CSF.Screenplay.WebApis.HttpRequestMessageBuilder.html": {
    "href": "api/CSF.Screenplay.WebApis.HttpRequestMessageBuilder.html",
    "title": "Class HttpRequestMessageBuilder | Screenplay docs",
    "keywords": "Class HttpRequestMessageBuilder Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An object which can create an HttpRequestMessage for use with an HTTP client. public record HttpRequestMessageBuilder : IHasName, IFormattableValue, IEquatable<HttpRequestMessageBuilder> Inheritance object HttpRequestMessageBuilder Implements IHasName IFormattableValue IEquatable<HttpRequestMessageBuilder> Derived HttpRequestMessageBuilder<TResponse> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Please note that this type differs in form depending upon the .NET version under which it is consumed. If consuming this type from logic which targets .NET Standard 2.0 or .NET Framework 4.6.2 then this type is a class. In that scenario its properties are mutable and the developer should take care to ensure that they do not mutate/alter its state inadvertently. Developers should ensure that they manually copy the state from the current instance into a new instance instead of modifying an existing instance. In these target frameworks, a Clone method has been provided to assist with this. When consuming this from .NET 5 or higher, this type is instead a record and is immutable by design. All properties are init-only. Additionally, in .NET 5+, some additional properties are available, supporting features of HttpRequestMessage which are unavailable in lower .NET versions. When using .NET 5, developers may use nondestructive mutation with the with keyword/expression to create a copy of the current instance but with some differences. Properties Content Gets or sets the content which will be sent with the request: the request body. public HttpContent Content { get; init; } Property Value HttpContent Headers Gets or sets the HTTP headers which will be sent with the request, corresponding to Headers. public NameValueRecordCollection<string, string> Headers { get; init; } Property Value NameValueRecordCollection<string, string> Method Gets or sets the HTTP method (aka \"verb\") which shall be used to send the request. public HttpMethod Method { get; init; } Property Value HttpMethod Name Gets the human-readable name of the current object. public string Name { get; init; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Options Gets or sets the HTTP web request options, corresponding to Options. public NameValueRecordCollection<string, object> Options { get; init; } Property Value NameValueRecordCollection<string, object> Remarks Note that this property is supported only for .NET 5 and above. It is unavailable in lower .NET versions, including .NET Standard and .NET Framework. RequestUri Gets or sets the Uri to which the HTTP request shall be sent. public Uri RequestUri { get; init; } Property Value Uri Timeout Gets or sets an optional timeout duration for requests built from this builder. public TimeSpan? Timeout { get; init; } Property Value TimeSpan? Remarks If this set to a non-null value, then the HTTP client used to make the request will include cancellation after an amount of time (equal to this timespan) has passed. This logic is handled within the MakeWebApiRequests action. If this action is not used then this timeout might not be honoured. Version Gets or sets the HTTP version which shall be used by the message. public Version Version { get; init; } Property Value Version Remarks The documentation for the Version property notes that it would default to 2.0 for .NET Core 2.1 or 2.2, and defaults to 1.1 for all other versions of .NET or .NET Framework. This property will always default to 1.1 regardless of the target framework. VersionPolicy Gets or sets the HTTP version policy, corresponding to VersionPolicy. public HttpVersionPolicy VersionPolicy { get; init; } Property Value HttpVersionPolicy Remarks Note that this property is supported only for .NET 5 and above. It is unavailable in lower .NET versions, including .NET Standard and .NET Framework. Methods CreateRequestMessage() Creates and returns an HTTP request message. public HttpRequestMessage CreateRequestMessage() Returns HttpRequestMessage An HTTP request message Remarks The request message is typically created from the state of the current object instance. Multiple usages of this method must create a new request message each time. Unless some state has been altered between usages, though, each of these messages is likely to have the same data/property values. If the state of the current instance does not specify a Method; IE the method is null, then Get will be used. FormatForReport() Gets a human-readable formatted string which represents the current object instance, suitable to be used in a Screenplay report. public string FormatForReport() Returns string A formatted string which represents the current instance."
  },
  "api/CSF.Screenplay.WebApis.HttpResponseMessageAndResponseType-1.html": {
    "href": "api/CSF.Screenplay.WebApis.HttpResponseMessageAndResponseType-1.html",
    "title": "Class HttpResponseMessageAndResponseType<TResponse> | Screenplay docs",
    "keywords": "Class HttpResponseMessageAndResponseType<TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Wraps an HttpResponseMessage but also provides information about the expected response type from that message. public class HttpResponseMessageAndResponseType<TResponse> Type Parameters TResponse The expected response type. Inheritance object HttpResponseMessageAndResponseType<TResponse> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HttpResponseMessageAndResponseType(HttpResponseMessage) Initializes a new instance of HttpResponseMessageAndResponseType<TResponse>. public HttpResponseMessageAndResponseType(HttpResponseMessage responseMessage) Parameters responseMessage HttpResponseMessage The HTTP response message. Exceptions ArgumentNullException If responseMessage is null. Properties ResponseMessage Gets the HTTP response message. public HttpResponseMessage ResponseMessage { get; } Property Value HttpResponseMessage"
  },
  "api/CSF.Screenplay.WebApis.JsonEndpoint-1.html": {
    "href": "api/CSF.Screenplay.WebApis.JsonEndpoint-1.html",
    "title": "Class JsonEndpoint<TParameters> | Screenplay docs",
    "keywords": "Class JsonEndpoint<TParameters> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Base type for a Web API endpoint which accepts a request payload in the form of a strongly typed object serialized to JSON string, but which is not expected to return a response body. public class JsonEndpoint<TParameters> : ParameterizedEndpoint<TParameters>, IHasName Type Parameters TParameters The type of the parameters object which is required to create an HTTP request message Inheritance object EndpointBase ParameterizedEndpoint<TParameters> JsonEndpoint<TParameters> Implements IHasName Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should overrideGetHttpRequestMessageBuilder(TParameters) with a method that calls the base implementation and then further manipulates the message builder before returning it. When deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors JsonEndpoint(string, HttpMethod) Initializes a new instance of JsonEndpoint<TParameters> with a relative URI and an optional HTTP method. public JsonEndpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). JsonEndpoint(Uri, HttpMethod) Initializes a new instance of JsonEndpoint<TParameters> with a URI and an optional HTTP method. public JsonEndpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder(TParameters) Gets a HttpRequestMessageBuilder from the state of the current instance and the specified parameters value. public override HttpRequestMessageBuilder GetHttpRequestMessageBuilder(TParameters parameters) Parameters parameters TParameters The parameters required to create an HTTP request builder Returns HttpRequestMessageBuilder An HTTP request message builder Remarks This method serializes the parameters value into a JSON string and sets it into the HTTP request content: Content. See Also EndpointBase Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters, TResponse> ParameterizedEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.JsonEndpoint-2.html": {
    "href": "api/CSF.Screenplay.WebApis.JsonEndpoint-2.html",
    "title": "Class JsonEndpoint<TParameters, TResult> | Screenplay docs",
    "keywords": "Class JsonEndpoint<TParameters, TResult> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Base type for a Web API endpoint which accepts a request payload in the form of a strongly typed object serialized to JSON string, and which is expected to return a response body that exposes a strongly-typed object. public class JsonEndpoint<TParameters, TResult> : ParameterizedEndpoint<TParameters, TResult>, IHasName Type Parameters TParameters The type of the parameters object which is required to create an HTTP request message TResult The type of response that the endpoint is expected to return. Inheritance object EndpointBase ParameterizedEndpoint<TParameters, TResult> JsonEndpoint<TParameters, TResult> Implements IHasName Inherited Members ParameterizedEndpoint<TParameters, TResult>.GetHttpRequestMessageBuilder(TParameters) EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. The manner in which this endpoint exposes the strongly typed response object is undefined within the endpoint itself. It is down to a performable implementation to deserialize the result object from the HTTP response content. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should overrideGetHttpRequestMessageBuilder(TParameters) with a method that calls the base implementation and then further manipulates the message builder before returning it. When deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors JsonEndpoint(string, HttpMethod) Initializes a new instance of JsonEndpoint<TParameters, TResult> with a relative URI and an optional HTTP method. public JsonEndpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). JsonEndpoint(Uri, HttpMethod) Initializes a new instance of JsonEndpoint<TParameters, TResult> with a URI and an optional HTTP method. public JsonEndpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder(TParameters) Gets a HttpRequestMessageBuilder<TResponse> from the state of the current instance and the specified parameters value. public override HttpRequestMessageBuilder<TResult> GetHttpRequestMessageBuilder(TParameters parameters) Parameters parameters TParameters The parameters required to create an HTTP request builder Returns HttpRequestMessageBuilder<TResult> An HTTP request message builder Remarks This method serializes the parameters value into a JSON string and sets it into the HTTP request content: Content. See Also EndpointBase Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters, TResponse> ParameterizedEndpoint<TParameters> JsonEndpoint<TParameters>"
  },
  "api/CSF.Screenplay.WebApis.MakeWebApiRequests.html": {
    "href": "api/CSF.Screenplay.WebApis.MakeWebApiRequests.html",
    "title": "Class MakeWebApiRequests | Screenplay docs",
    "keywords": "Class MakeWebApiRequests Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An ability class which allows Actors to make HTTP web API requests using HttpClient. public sealed class MakeWebApiRequests : IDisposable Inheritance object MakeWebApiRequests Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties DefaultClient Gets or sets the HTTP client, for scenarios in which the actor needs to use a single client. public HttpClient DefaultClient { get; set; } Property Value HttpClient Remarks If the actor needs to know about more than one HTTP client, then consider using the indexer instead, which allows storage of more than one client, using arbitrary names. this[string] Gets or sets an HTTP client with a specified name. public HttpClient this[string name] { get; set; } Parameters name string The name of the HTTP client for which this instance is getting or setting. Property Value HttpClient An HTTP client associated with the specified name, or null reference if no HTTP client has been configured for that name. Remarks Use this indexer if an actor needs to manage more than one HTTP client. The key to this index - a name - is completely arbitrary and may mean whatever your needs require. Names must not be null and should not be empty or whitespace-only strings. The name DefaultClient is reserved for the value of DefaultClient. If the actor needs to use only a single HTTP client then yoy may find the DefaultClient property easier to use, instead of this indexer. Exceptions ArgumentNullException If name is null. Methods AddClient(string, string) Adds a new HTTP client to the current instance, with an optional base URI and client name. public void AddClient(string baseUri = null, string clientName = null) Parameters baseUri string Optional, the base URI to which requests should be sent clientName string Optional, the name of the client. If omitted then the new client will be the DefaultClient Remarks This method is a shorthand for adding a new item to either DefaultClient or the class indexer. It allows the convenient configuration of a new HttpClient with just a base URI to which requests should be sent. Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() GetClient(string) Gets an HTTP client with the specified name. public HttpClient GetClient(string clientName = null) Parameters clientName string An optional client name, if omitted then the default client will be returned. Returns HttpClient An HTTP client Remarks If clientName is null then the DefaultClient will be returned. Exceptions InvalidOperationException If clientName is specified & non-null but the current instance has no client of that name."
  },
  "api/CSF.Screenplay.WebApis.NameValueRecordCollection-2.html": {
    "href": "api/CSF.Screenplay.WebApis.NameValueRecordCollection-2.html",
    "title": "Class NameValueRecordCollection<TKey, TValue> | Screenplay docs",
    "keywords": "Class NameValueRecordCollection<TKey, TValue> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll A simple name/value collection with an indexer, backed by a Dictionary<TKey, TValue>. public sealed class NameValueRecordCollection<TKey, TValue> : IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IEquatable<NameValueRecordCollection<TKey, TValue>> where TKey : notnull where TValue : class Type Parameters TKey The key type TValue The value type Inheritance object NameValueRecordCollection<TKey, TValue> Implements IEnumerable<KeyValuePair<TKey, TValue>> IEnumerable IEquatable<NameValueRecordCollection<TKey, TValue>> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Please note that this type differs in form depending upon the .NET version under which it is consumed. If consuming this type from logic which targets .NET Standard 2.0 or .NET Framework 4.6.2 then this type is mutable. In that scenario the developer should take care to ensure that they do not mutate/alter its state inadvertently. Developers should ensure that they manually copy the state from the current instance into a new instance instead of modifying an existing instance. In these target frameworks, a Clone method has been provided to assist with this. When consuming this from .NET 5 or higher, this type is immutable by design; the indexer is init-only. When using .NET 5, developers may use nondestructive mutation by using either the WithItem or WithItems methods to create a copy of the current instance, but with modified items. Constructors NameValueRecordCollection() Initialises a new instance of NameValueRecordCollection<TKey, TValue>. public NameValueRecordCollection() Properties this[TKey] Gets or sets the values within this collection, via an indexer. public TValue? this[TKey key] { get; init; } Parameters key TKey The key Property Value TValue The value Examples In order to set this property, particularly when using .NET 5 or higher (when this type is a record rather than a class, and this indexer is immutable), use the following syntax. var nvr = new NameValueRecordCollection<int,string> { [7] = \"seven\", [9] = \"nine\", [13] = \"thirteen\", } Remarks null may not be stored in this collection as a value. An attempt to store a null value will result in the removal of the item at the specified key. As a type which is intended to be immutable, it goes without saying that ideally both TKey and TValue should ideally also be immutable types. If they are not, developers must be careful to avoid mutating them, as doing so could adulterate the state of the current instance. Methods Equals(NameValueRecordCollection<TKey, TValue>?) Indicates whether the current object is equal to another object of the same type. public bool Equals(NameValueRecordCollection<TKey, TValue>? other) Parameters other NameValueRecordCollection<TKey, TValue> An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetEnumerator() Returns an enumerator that iterates through the collection. public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() Returns IEnumerator<KeyValuePair<TKey, TValue>> An enumerator that can be used to iterate through the collection. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. WithItem(TKey, TValue?) Gets a clone (shallow copy) of the current NameValueRecordCollection<TKey, TValue> containing the same items, as well as the specified item. public NameValueRecordCollection<TKey, TValue> WithItem(TKey key, TValue? value) Parameters key TKey The key at which to add, remove or update an item value TValue The value to store for the item, or null which indicates that the item is to be removed. Returns NameValueRecordCollection<TKey, TValue> A copy of the current instance, with a single item added, removed or altered in that copied instance. Remarks As with the indexer, if the value is null then this will result in the removal of the item in the returned copy. WithItems(IEnumerable<KeyValuePair<TKey, TValue?>>) Gets a clone (shallow copy) of the current NameValueRecordCollection<TKey, TValue> containing the same items, as well as the specified items. public NameValueRecordCollection<TKey, TValue> WithItems(IEnumerable<KeyValuePair<TKey, TValue?>> items) Parameters items IEnumerable<KeyValuePair<TKey, TValue>> A collection of key/value pairs, indicating the keys & values to add, remove or alter in the copied instance. Returns NameValueRecordCollection<TKey, TValue> A copy of the current instance, with the specified items added, removed or altered. Remarks As with indexer, if any value is null then this will result in the removal of the corresponding item in the returned copy."
  },
  "api/CSF.Screenplay.WebApis.ParameterizedEndpoint-1.html": {
    "href": "api/CSF.Screenplay.WebApis.ParameterizedEndpoint-1.html",
    "title": "Class ParameterizedEndpoint<TParameters> | Screenplay docs",
    "keywords": "Class ParameterizedEndpoint<TParameters> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Base type for a Web API endpoint which has a strongly-typed request payload but which is not expected to return a response body. public abstract class ParameterizedEndpoint<TParameters> : EndpointBase, IHasName Type Parameters TParameters The type of the parameters object which is required to create an HTTP request message Inheritance object EndpointBase ParameterizedEndpoint<TParameters> Implements IHasName Derived JsonEndpoint<TParameters> Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should overrideGetHttpRequestMessageBuilder(TParameters) with a method that calls the base implementation and then further manipulates the message builder before returning it. This particular class may only be used as a base type for specialized implementations. Implementing types must provide an implementation of GetHttpRequestMessageBuilder(TParameters) which includes whatever logic is required to serialize the parameters value into the HTTP request. For an example implementation which serializes the parameters as a JSON string, see JsonEndpoint<TParameters>. When deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors ParameterizedEndpoint(string, HttpMethod) Initializes a new instance of ParameterizedEndpoint<TParameters> with a relative URI and an optional HTTP method. protected ParameterizedEndpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). ParameterizedEndpoint(Uri, HttpMethod) Initializes a new instance of ParameterizedEndpoint<TParameters> with a URI and an optional HTTP method. protected ParameterizedEndpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder(TParameters) Gets a HttpRequestMessageBuilder from the state of the current instance and the specified parameters value. public abstract HttpRequestMessageBuilder GetHttpRequestMessageBuilder(TParameters parameters) Parameters parameters TParameters The parameters required to create an HTTP request builder Returns HttpRequestMessageBuilder An HTTP request message builder Remarks When overriding/implementing this method use GetBaseHttpRequestMessageBuilder() to get a builder from the base class. You should then further customize that builder instance according to the appropriate logic for this implementation, such as to add the parameter value. See Also EndpointBase Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters, TResponse> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.ParameterizedEndpoint-2.html": {
    "href": "api/CSF.Screenplay.WebApis.ParameterizedEndpoint-2.html",
    "title": "Class ParameterizedEndpoint<TParameters, TResponse> | Screenplay docs",
    "keywords": "Class ParameterizedEndpoint<TParameters, TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Base type for a Web API endpoint which has a strongly-typed request payload and which is expected to return a response body that exposes a strongly-typed object. public abstract class ParameterizedEndpoint<TParameters, TResponse> : EndpointBase, IHasName Type Parameters TParameters The type of the parameters object which is required to create an HTTP request message TResponse The type of response that the endpoint is expected to return. Inheritance object EndpointBase ParameterizedEndpoint<TParameters, TResponse> Implements IHasName Derived JsonEndpoint<TParameters, TResult> Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. The manner in which this endpoint exposes the strongly typed response object is undefined within the endpoint itself. It is down to a performable implementation to deserialize the result object from the HTTP response content. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should overrideGetHttpRequestMessageBuilder(TParameters) with a method that calls the base implementation and then further manipulates the message builder before returning it. This particular class may only be used as a base type for specialized implementations. Implementing types must provide an implementation of GetHttpRequestMessageBuilder(TParameters) which includes whatever logic is required to serialize the parameters value into the HTTP request. For an example implementation which serializes the parameters as a JSON string, see JsonEndpoint<TParameters, TResult>. When deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors ParameterizedEndpoint(string, HttpMethod) Initializes a new instance of ParameterizedEndpoint<TParameters, TResponse> with a relative URI and an optional HTTP method. protected ParameterizedEndpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). ParameterizedEndpoint(Uri, HttpMethod) Initializes a new instance of ParameterizedEndpoint<TParameters, TResponse> with a URI and an optional HTTP method. protected ParameterizedEndpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder(TParameters) Gets a HttpRequestMessageBuilder<TResponse> from the state of the current instance and the specified parameters value. public abstract HttpRequestMessageBuilder<TResponse> GetHttpRequestMessageBuilder(TParameters parameters) Parameters parameters TParameters The parameters required to create an HTTP request builder Returns HttpRequestMessageBuilder<TResponse> An HTTP request message builder Remarks When overriding/implementing this method use GetBaseHttpRequestMessageBuilder<TResponse>() to get a builder from the base class. You should then further customize that builder instance according to the appropriate logic for this implementation, such as to add the parameter value. See Also EndpointBase Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.SendTheHttpRequest.html": {
    "href": "api/CSF.Screenplay.WebApis.SendTheHttpRequest.html",
    "title": "Class SendTheHttpRequest | Screenplay docs",
    "keywords": "Class SendTheHttpRequest Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An action which creates & sends an HTTP request using the specification within an HttpRequestMessageBuilder. public class SendTheHttpRequest : IPerformableWithResult<HttpResponseMessage>, ICanReport Inheritance object SendTheHttpRequest Implements IPerformableWithResult<HttpResponseMessage> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SendTheHttpRequest(HttpRequestMessageBuilder, string) Initializes a new instance of SendTheHttpRequest. public SendTheHttpRequest(HttpRequestMessageBuilder messageBuilder, string clientName = null) Parameters messageBuilder HttpRequestMessageBuilder The HTTP request message builder. clientName string An optional client name, when actors must maintain more than one HTTP client. Exceptions ArgumentNullException If messageBuilder is null. Methods GetReportFragment(IHasName, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(IHasName actor, IFormatsReportFragment formatter) Parameters actor IHasName An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<HttpResponseMessage> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<HttpResponseMessage> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.WebApis.SendTheHttpRequestAndGetJsonResponse-1.html": {
    "href": "api/CSF.Screenplay.WebApis.SendTheHttpRequestAndGetJsonResponse-1.html",
    "title": "Class SendTheHttpRequestAndGetJsonResponse<TResponse> | Screenplay docs",
    "keywords": "Class SendTheHttpRequestAndGetJsonResponse<TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An action which creates & sends an HTTP request, using the specification within an HttpRequestMessageBuilder<TResponse> and returns a strongly-typed result deserialized from a JSON HTTP response. public class SendTheHttpRequestAndGetJsonResponse<TResponse> : IPerformableWithResult<TResponse>, ICanReport Type Parameters TResponse Inheritance object SendTheHttpRequestAndGetJsonResponse<TResponse> Implements IPerformableWithResult<TResponse> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SendTheHttpRequestAndGetJsonResponse(HttpRequestMessageBuilder<TResponse>, string) Initializes a new instance of SendTheHttpRequestAndGetJsonResponse<TResponse>. public SendTheHttpRequestAndGetJsonResponse(HttpRequestMessageBuilder<TResponse> messageBuilder, string clientName = null) Parameters messageBuilder HttpRequestMessageBuilder<TResponse> The HTTP request message builder. clientName string An optional client name, when actors must maintain more than one HTTP client. Exceptions ArgumentNullException If messageBuilder is null. Methods GetReportFragment(IHasName, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(IHasName actor, IFormatsReportFragment formatter) Parameters actor IHasName An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<TResponse> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TResponse> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.WebApis.SendTheHttpRequestAndGetTheResponse-1.html": {
    "href": "api/CSF.Screenplay.WebApis.SendTheHttpRequestAndGetTheResponse-1.html",
    "title": "Class SendTheHttpRequestAndGetTheResponse<TResponse> | Screenplay docs",
    "keywords": "Class SendTheHttpRequestAndGetTheResponse<TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An action which creates & sends an HTTP request using the specification within an HttpRequestMessageBuilder<TResponse> and returns a result which preserves the intended response type. public class SendTheHttpRequestAndGetTheResponse<TResponse> : IPerformableWithResult<HttpResponseMessageAndResponseType<TResponse>>, ICanReport Type Parameters TResponse Inheritance object SendTheHttpRequestAndGetTheResponse<TResponse> Implements IPerformableWithResult<HttpResponseMessageAndResponseType<TResponse>> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SendTheHttpRequestAndGetTheResponse(HttpRequestMessageBuilder<TResponse>, string) Initializes a new instance of SendTheHttpRequestAndGetTheResponse<TResponse>. public SendTheHttpRequestAndGetTheResponse(HttpRequestMessageBuilder<TResponse> messageBuilder, string clientName = null) Parameters messageBuilder HttpRequestMessageBuilder<TResponse> The HTTP request message builder. clientName string An optional client name, when actors must maintain more than one HTTP client. Exceptions ArgumentNullException If messageBuilder is null. Methods GetReportFragment(IHasName, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(IHasName actor, IFormatsReportFragment formatter) Parameters actor IHasName An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<HttpResponseMessageAndResponseType<TResponse>> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<HttpResponseMessageAndResponseType<TResponse>> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.WebApis.WebApiBuilder.html": {
    "href": "api/CSF.Screenplay.WebApis.WebApiBuilder.html",
    "title": "Class WebApiBuilder | Screenplay docs",
    "keywords": "Class WebApiBuilder Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll A builder for the performables SendTheHttpRequest and SendTheHttpRequestAndGetTheResponse<TResponse>. public static class WebApiBuilder Inheritance object WebApiBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetTheJsonResult<TResponse>(Endpoint<TResponse>, string) Gets an instance of SendTheHttpRequestAndGetJsonResponse<TResponse> from an endpoint and optional client name. public static SendTheHttpRequestAndGetJsonResponse<TResponse> GetTheJsonResult<TResponse>(Endpoint<TResponse> endpoint, string clientName = null) Parameters endpoint Endpoint<TResponse> The endpoint from which to get an action. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequestAndGetJsonResponse<TResponse> A performable that will send the HTTP request and await its result and deserialize that result as . Type Parameters TResponse The type of the expected result value GetTheJsonResult<TParameters, TResponse>(ParameterizedEndpoint<TParameters, TResponse>, TParameters, string) Gets an instance of SendTheHttpRequestAndGetJsonResponse<TResponse> from a parameterized endpoint, its parameters and an optional client name. public static SendTheHttpRequestAndGetJsonResponse<TResponse> GetTheJsonResult<TParameters, TResponse>(ParameterizedEndpoint<TParameters, TResponse> endpoint, TParameters parameters, string clientName = null) Parameters endpoint ParameterizedEndpoint<TParameters, TResponse> The endpoint from which to get an action. parameters TParameters The parameters required by the endpoint. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequestAndGetJsonResponse<TResponse> A performable that will send the HTTP request and await its result. Type Parameters TParameters The type of the parameters expected by the endpoint TResponse The type of the expected result value SendTheHttpRequest(Endpoint, string) Gets an instance of SendTheHttpRequest from an endpoint and optional client name. public static SendTheHttpRequest SendTheHttpRequest(Endpoint endpoint, string clientName = null) Parameters endpoint Endpoint The endpoint from which to get an action. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequest A performable that will send the HTTP request and await its result. SendTheHttpRequest<TResponse>(Endpoint<TResponse>, string) Gets an instance of SendTheHttpRequestAndGetTheResponse<TResponse> from an endpoint and optional client name. public static SendTheHttpRequestAndGetTheResponse<TResponse> SendTheHttpRequest<TResponse>(Endpoint<TResponse> endpoint, string clientName = null) Parameters endpoint Endpoint<TResponse> The endpoint from which to get an action. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequestAndGetTheResponse<TResponse> A performable that will send the HTTP request and await its result. Type Parameters TResponse The type of the expected result value SendTheHttpRequest<TParameters>(ParameterizedEndpoint<TParameters>, TParameters, string) Gets an instance of SendTheHttpRequest from a parameterized endpoint, its parameters and an optional client name. public static SendTheHttpRequest SendTheHttpRequest<TParameters>(ParameterizedEndpoint<TParameters> endpoint, TParameters parameters, string clientName = null) Parameters endpoint ParameterizedEndpoint<TParameters> The endpoint from which to get an action. parameters TParameters The parameters required by the endpoint. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequest A performable that will send the HTTP request and await its result. Type Parameters TParameters The type of the parameters expected by the endpoint SendTheHttpRequest<TParameters, TResponse>(ParameterizedEndpoint<TParameters, TResponse>, TParameters, string) Gets an instance of SendTheHttpRequestAndGetTheResponse<TResponse> from a parameterized endpoint, its parameters and an optional client name. public static SendTheHttpRequestAndGetTheResponse<TResponse> SendTheHttpRequest<TParameters, TResponse>(ParameterizedEndpoint<TParameters, TResponse> endpoint, TParameters parameters, string clientName = null) Parameters endpoint ParameterizedEndpoint<TParameters, TResponse> The endpoint from which to get an action. parameters TParameters The parameters required by the endpoint. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequestAndGetTheResponse<TResponse> A performable that will send the HTTP request and await its result. Type Parameters TParameters The type of the parameters expected by the endpoint TResponse The type of the expected result value"
  },
  "api/CSF.Screenplay.WebApis.html": {
    "href": "api/CSF.Screenplay.WebApis.html",
    "title": "Namespace CSF.Screenplay.WebApis | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.WebApis Classes Endpoint A Web API endpoint which has no expected request payload and which is not expected to return a response body. EndpointBase Abstract base class for types which represent web API endpoints. Endpoint<TResult> A Web API endpoint which has no expected request payload and which is expected to return a response body that exposes a strongly-typed object. HttpRequestMessageBuilder An object which can create an HttpRequestMessage for use with an HTTP client. HttpRequestMessageBuilder<TResponse> An object which can create an HttpRequestMessage for use with an HTTP client, which is expected to expose a response of a particular type. HttpResponseMessageAndResponseType<TResponse> Wraps an HttpResponseMessage but also provides information about the expected response type from that message. JsonEndpoint<TParameters> Base type for a Web API endpoint which accepts a request payload in the form of a strongly typed object serialized to JSON string, but which is not expected to return a response body. JsonEndpoint<TParameters, TResult> Base type for a Web API endpoint which accepts a request payload in the form of a strongly typed object serialized to JSON string, and which is expected to return a response body that exposes a strongly-typed object. MakeWebApiRequests An ability class which allows Actors to make HTTP web API requests using HttpClient. NameValueRecordCollection<TKey, TValue> A simple name/value collection with an indexer, backed by a Dictionary<TKey, TValue>. ParameterizedEndpoint<TParameters> Base type for a Web API endpoint which has a strongly-typed request payload but which is not expected to return a response body. ParameterizedEndpoint<TParameters, TResponse> Base type for a Web API endpoint which has a strongly-typed request payload and which is expected to return a response body that exposes a strongly-typed object. SendTheHttpRequest An action which creates & sends an HTTP request using the specification within an HttpRequestMessageBuilder. SendTheHttpRequestAndGetJsonResponse<TResponse> An action which creates & sends an HTTP request, using the specification within an HttpRequestMessageBuilder<TResponse> and returns a strongly-typed result deserialized from a JSON HTTP response. SendTheHttpRequestAndGetTheResponse<TResponse> An action which creates & sends an HTTP request using the specification within an HttpRequestMessageBuilder<TResponse> and returns a result which preserves the intended response type. WebApiBuilder A builder for the performables SendTheHttpRequest and SendTheHttpRequestAndGetTheResponse<TResponse>."
  },
  "api/CSF.Screenplay.html": {
    "href": "api/CSF.Screenplay.html",
    "title": "Namespace CSF.Screenplay | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay Classes Actor A representation of an autonomous, or at least seemingly-autonomous, person or system which directs the events of a IPerformance. ActorExtensions Extension methods for actor types CastExtensions Extension methods for ICast. Performance Primary implementation type of IPerformance. PerformanceStarter Helper class for beginning the functionality of a Screenplay IPerformance from your own logic, using a fluent interface ReportFragment A model for a fragment of a report upon a IPerformance. ReportFragmentFormatter Default implementation of IFormatsReportFragment. ScopeAndPerformance A model which contains both an IPerformance and a dependency injection IServiceScope. Screenplay An object which represents a complete execution of Screenplay logic, which should include one or more Performance instances. ScreenplayAssemblyAttribute An attribute used to mark an assembly which contains Screenplay-based tests. ScreenplayAttribute Applied to a test method, indicates that decorated test is a Screenplay test. ScreenplayBinding SpecFlow binding which uses hooks to coordinate the relevant Screenplay & IPerformance event invokers. ScreenplayExtensions Extension methods for the Screenplay type. ScreenplayLocator A small static service locator of sorts, dedicated to getting an appropriate instance of Screenplay for a specified test object. ScreenplayOptions Options model which permits the customization/configuration of Screenplay in DI. ScreenplayPlugin The Screenplay plugin for SpecFlow. ScreenplayServiceCollectionExtensions Extension methods for IServiceCollection relating to Screenplay. ScreenplaySteps A subclass of TechTalk.SpecFlow.Steps provided for convenience of SpecFlow 3.x users to avoid naming conflicts. ServiceCollectionAdapter Adapter class which allows a SpecFlow/BoDi IObjectContainer to be used as an IServiceCollection. ServiceProviderAdapter Adapter class which allows a SpecFlow/BoDi IObjectContainer to be used as an IServiceProvider. StageExtensions Extension methods for IStage. Interfaces ICanPerform An actor which may perform in the Screenplay. ICanReport A type which can provide a human-readable report fragment when it is used in a IPerformance. ICast A combined registry and factory for Actor instances, useful when coordinating multiple actors across a IPerformance IFormatsReportFragment A service which produces formatted report fragments from a template and a collection of parameter values. IGetsScreenplay An object which can fully configure and get a Screenplay instance. IHasAbilities An object which has & is able to gain abilities. IHasName A part of a Screenplay performance which has a human-readable name. IHasPerformanceIdentity An object which provides a value which uniquely identifies the currently-executing IPerformance. IHasServiceProvider An object which has an associated IServiceProvider, which resolves services from dependency injection. IHostsPerformance An object which encapsulates the logic of an IPerformance in a standalone Screenplay. IPerformable An object which represents something that a performer (typically an actor) may perform. IPerformableWithResult An object which represents something that a performer (typically an actor) may perform and which returns a result when it completes. IPerformableWithResult<TResult> An object which represents something that a performer (typically an actor) may perform and which returns a strongly-typed result when it completes. IPerformance A performance represents a self-contained scope of performables which typically results in overall success or failure. IPersona A persona is a factory for a commonly-used actor IStage The stage facilitates a contextual Actor who is 'in the spotlight' - a currently-active actor"
  },
  "docs/GettingReports.html": {
    "href": "docs/GettingReports.html",
    "title": "Screenplay reports | Screenplay docs",
    "keywords": "Screenplay reports TODO: Write this docco This should start with info about the JSON report file, and how to influence where it's written. It should go on to include info about how to convert that to other formats."
  },
  "docs/HowScreenplayAndPerformanceRelate.html": {
    "href": "docs/HowScreenplayAndPerformanceRelate.html",
    "title": "Top-down look at a screenplay | Screenplay docs",
    "keywords": "Top-down look at a screenplay The diagram below shows a top-down look at a Screenplay and how it relates to Performances, Actors and Performables. The Screenplay might itself be controlled by a Test Integration, if Screenplay is being used for automated tests. The lifetime shown, for the Performance also indicates the lifetime of the dependency injection scope. sequenceDiagram accDescr { A single instance of Screenplay runs each Performance. Each Performance contains scripts for one or more Actors. Within the Performance, the Actor(s) perform one or more Performables. The lifetime of a single performance is shown, to illustrate the DI lifetime scope. } Screenplay->>Performance: Runs each actor A as Actor activate Performance Performance->>A: Contains scripts for<br>one or more A->>Performable: Performs one<br>or more Performable-->>A: Complete A-->>Performance: Complete Performance-->>Screenplay: Complete deactivate Performance"
  },
  "docs/MakeupOfAScreenplay.html": {
    "href": "docs/MakeupOfAScreenplay.html",
    "title": "Makeup of a Screenplay | Screenplay docs",
    "keywords": "Makeup of a Screenplay A Screenplay, used as a verb, refers to a complete execution screenplay-based logic, written using this framework. Screenplay, when used as a noun, is a class which coordinates the scope & execution of that logic. A Screenplay is comprised or one or more Performances, usually many. The diagram below shows the basic building blocks of a performance and how they interact. block-beta columns 3 Screenplay:3 Performance[\"Performance<br>(each Screenplay may contain many)\"]:3 Actor(\"Actors\") space block:Perf columns 3 space Task[\"Tasks\"] space Action[\"Actions\"] space Question[\"Questions\"] end space:3 Ability[\"Abilities\"] Actor -- \"Perform\" --> Perf Ability -- \"Has\" --> Actor Action -- \"Use\" --> Ability Question -- \"Use\" --> Ability style Perf fill:#E0E0F0,stroke:#C0C0E0 Explanation A performance involves one or more Actors. Each actor usually has at least one Ability. The actor performs Performables, of which there are three fundamental types: Tasks Actions Questions Actions and questions make direct use of the actor's abilities to perform their work. Tasks, on the other hand, are compositions of any of actions, questions and/or other tasks. A full Screenplay comprises of one or more performances."
  },
  "docs/ScreenplayInTheTestingStack.html": {
    "href": "docs/ScreenplayInTheTestingStack.html",
    "title": "Screenplay in the testing stack | Screenplay docs",
    "keywords": "Screenplay in the testing stack Screenplay is often used as a tool for writing automated tests. It is not a complete testing framework, though. It serves as an extension/plugin to existing testing frameworks, enhancing them with Screenplay syntax and logic. The diagram below shows where Screenplay lies within the technology stack, when it is used as a tool for testing. The dark yellow/light brown blocks show the Screenplay-specific components. The explanation below uses the NUnit test framework as an example, but this could be substituted for counterparts applicable to any test framework. block-beta columns 2 Runner[\"Test runner\"]:2 FW[\"Test framework\"]:2 Int[\"Test integration\"]:2 Test Logic[\"Screenplay test logic\"] classDef sp fill:#f0f0bb,stroke:#cc7 class Int,Logic sp The test runner This is the executable tool which runs tests. Applied to NUnit, this could be the nunit3-console.exe application. The test framework All testing framework contain some framework-specific logic of their own, which provide the basis for writing tests. Applied to NUnit, this is the NUnit.Framework.dll which is included in the NUnit NuGet package. The Test integration The Test Integration is the extension to the test framework (above) which enables the use of Screenplay-based logic in tests. Each testing framework has its own test integration, as it must be developed for the test framework's syntax and extension points. Tests The tests are normal tests written for the chosen test framework. Whilst they might be decorated with additional Screenplay-specific attributes or use Screenplay syntax, they are normal tests in the context of the test framework. Applied to NUnit, this would be your methods which look similar to: [Test] public void MyFunctionShouldReturnTrueWhenItIsTuesday() { // Test logic omitted } Screenplay test logic The logic within tests (above) which use Screenplay will be written using Screenplay's test syntax. That it, it will use Actors, Abilities and Performables. In this context, each test is a Screenplay Performance."
  },
  "docs/StandaloneScreenplay.html": {
    "href": "docs/StandaloneScreenplay.html",
    "title": "Using Screenplay standalone | Screenplay docs",
    "keywords": "Using Screenplay standalone Screenplay is often used as a tool for automating software tests, but it is not limited to only this usage. Screenplay may be added to any application or library, via dependency injection. This is as simple as installing the CSF.Screenplay NuGet package and adding Screenplay to your service collection. For more information, see the documentation for ScreenplayServiceCollectionExtensions. using CSF.Screenplay; // IServiceCollection services; services.AddScreenplay(); // ... then, after the service collection is built: // IServiceProvider serviceProvider; var screenplay = serviceProvider.GetService<Screenplay>(); // Or you may constructor-inject an instance of Screenplay into // any type which was resolved from the service provider Once Screenplay has been added to your DI, you may resolve and use Screenplay-related services from dependency injection. To execute some logic in the scope of a Performance, consider using the method Screenplay.ExecuteAsPerformanceAsync. Abstractions package If your solution is separated into multiple projects/assemblies then only your entry-point project needs the full CSF.Screenplay NuGet package. Once Screenplay has been added to DI, other projects in the solution may consume its logic, only requiring the CSF.Screenplay.Abstractions package."
  },
  "docs/SuitabilityAsATestingTool.html": {
    "href": "docs/SuitabilityAsATestingTool.html",
    "title": "Where Screenplay is suitable for testing | Screenplay docs",
    "keywords": "Where Screenplay is suitable for testing The Screenplay pattern is a recommended tool for writing automated tests for application software. Unlike NUnit or SpecFlow (or many others) Screenplay is not a complete testing framework. Rather, Screenplay integrates with your chosen testing framework to assist in the writing of test logic. Screenplay is not a silver bullet; some kinds of tests could benefit from Screenplay and others will not. Some testing scenarios are listed below, along with a brief consideration as to whether Screenplay is likely to be relevant. Terminology can differ between developers, so each type of test begins with a short definition. Ideal: System tests Also known as \"end-to-end tests\"; this kind of test exercises and tests the full deployed application without the use of any test fakes. The application might be set up/configured in a controlled environment but it runs and is exercised in the same way it would in production. System tests are an ideal candidate for the use of Screenplay. System tests are often written from a user's perspective and test meaningful, observable behaviour of the application, such as a complete user story. Screenplay excels in this area of test design. Unsuitable: Unit tests Unit tests test the functionality of a small unit of code in isolation. Typically this is a single class or function. Anything external to the tested unit is replaced with a test fake or a mock. Screenplay is not recommended for use in unit testing. Unit tests are rarely written from an end-user's perspective and often do not test complete application behaviour, such as a user story. A unit test will only test only a small aspect of some functionality. When this aspect is considered in isolation it may be meaningless, or too abstract to comprehend for an end-user. Additionally: The steps involved in unit tests should be short & simple, with minimal need for code reuse or composition The steps are typically difficult to describe in the application's 'behaviour domain', only with language that a software developer would understand Perhaps useful: Integration tests Integration tests live at a point in the spectrum of testing between unit & system tests. Like unit tests, they execute logic via its programming API instead of testing the deployed application. Unlike unit tests, each integration test exercises logic across many units of code/classes. Thus, it is common for integration tests to test high-level APIs which represent complete user stories. Integration tests might include some test fakes. Usually these are limited to things which are difficult or expensive to control. Asynchronous web services & databases are typically replaced with test fakes in integration tests. For integration tests, we recommend that you evaluate for yourself whether Screenplay is useful. In some projects/applications, Screenplay will be excellent for integration tests. In others it might not. You will find Screenplay most useful if your integration tests test complete user stories. This is particularly true if the test/sample scenarios would be recognisable to end users, even if described in an abstract manner, for example without reference to a user interface. Recommended: Use BDD-style tests Screenplay is a great tool when used alongside Behaviour Driven Development (BDD). Whilst the use of a BDD framework such as SpecFlow is not at all mandatory, those familiar with BDD will quickly see the synergies with Screenplay."
  },
  "docs/WritingTests.html": {
    "href": "docs/WritingTests.html",
    "title": "Advice for writing tests with Screenplay | Screenplay docs",
    "keywords": "Advice for writing tests with Screenplay Whichever testing integration you choose to use, there are some general pieces of advice and best practice which apply. Use high-level tasks Avoid the use of too many tasks/performables in each test. Too many performables in a single test makes it hard to comprehend at-a-glance and forces the reader to commit too much detail to memory. Rather than using many performables at the top-level of your tests, create high-level tasks which compose and simplify some of that detail into a single logical step. When using a method-driven testing framework, such as NUnit, five performables in a single test method is a reasonable number. More than approximately ten performables is too many. When using a binding-driven testing framework like SpecFlow, each binding should ideally correspond to at-most one performable. Use the Performance Starter Your top-level test logic should consume its performables via the class PerformanceStarter. This provides for a clear given/when/then appearance to your top-level test logic. Consider a fluent-style assertions library Depending upon the testing framework you have chosen, you may or may not have access to fluent-style assertions functionality. NUnit, for example, provides assertions based upon the constraint model, which is an extensible fluent-style syntax. If your chosen testing framework does not provide easy-to-read assertions, consider an external assertion library. Assertion libraries to consider include Shouldly and Fluent Assertions. Do not include assertions in performables It might be tempting to include assertion syntax within performables such as tasks. This is not recommended. Where assertions appear within performables: They reduce the reusability of the performables They create a dependency between your performables and your testing framework/assertion library They can make test logic harder to read and understand It is recommended to keep your performables/tasks free from assertions. In your test code, use questions or question-like tasks to get values/data from the system under test. Write your assertions in your main test logic, asserting that the values retrieved are as-expected."
  },
  "docs/builderPattern/index.html": {
    "href": "docs/builderPattern/index.html",
    "title": "The builder pattern | Screenplay docs",
    "keywords": "The builder pattern TODO: Write this docco This should be about the way in which Performables are created using Builders."
  },
  "docs/dependencyInjection/AddingServices.html": {
    "href": "docs/dependencyInjection/AddingServices.html",
    "title": "Adding dependency services to Screenplay | Screenplay docs",
    "keywords": "Adding dependency services to Screenplay There are two techniques to add dependency services to Screenplay. You may either integrate Screenplay into an existing container for your application or tests or you may add additional services via the static Create factory method. Integrating with an existing container When using an existing IServiceCollection for you application, either using Screenplay standalone or with a test framework that integrates with dependency injection, then adding services is simple. Just add your services to the container (the service collection) as normal; they will be available to resolve and inject over the course of the Screenplay. Using the static Create factory If you do not wish to integrate Screenplay into an existing dependency injection container then the simplest way to create an instance of Screenplay is to use the static Screenplay.Create factory method. This method offers an optional parameter to provide an Action<IServiceCollection>. If you do so, then you may provide a customization action which adds additional services to the container. These services will be integrated into the self-contained service collection which the Create method creates for Screenplay. var screenplay = Screenplay.Create(services => { services.AddTransient<MyCustomService>(); // ... and anything further you want here }); A reminder on lifetime scopes Remember that Screenplay imposes some requirements upon service lifetime: The Screenplay object is always a singleton Each Performance is always executed within its own lifetime scope Add your own services to dependency injection accordingly."
  },
  "docs/dependencyInjection/DependencyInjectionScope.html": {
    "href": "docs/dependencyInjection/DependencyInjectionScope.html",
    "title": "Dependency injection scope | Screenplay docs",
    "keywords": "Dependency injection scope Developers familiar with dependency injection are likely to be familiar with the concept of DI Scopes. That is - some services which are designated as scoped or instance per scope use a common/shared instance for the lifetime/duration of the scope. Within Screenplay logic, a DI scope is automatically created, with a lifetime matching that of the current Performance. Within a performance, when any of the scoped services (listed below) are injected, each point of injection will receive the same shared instance of that service. Instances are independent per-performance; each performance gets its own shared instance of each of the listed services. List of scoped services The Cast The Stage The current performance"
  },
  "docs/dependencyInjection/InjectableServices.html": {
    "href": "docs/dependencyInjection/InjectableServices.html",
    "title": "Injectable services | Screenplay docs",
    "keywords": "Injectable services TODO: Write this docco It should be a list of services which Screenplay makes available for DI, such as the cast & stage etc."
  },
  "docs/dependencyInjection/InjectingServices.html": {
    "href": "docs/dependencyInjection/InjectingServices.html",
    "title": "Injecting services | Screenplay docs",
    "keywords": "Injecting services There are a few techniques in which injecting dependencies is relevant. These are summarised below. All but one of these techniques provide access to the services which are added to the container. Into test logic When using automated test logic based upon Screenplay, the use of dependency injection typically takes one of two forms. Which of these depends upon the nature and paradigm of the test framework. For frameworks which are based on test methods such as NUnit, services are typically injected via method parameter injection into the test methods. If Screenplay were to be extended to work with frameworks such as xUnit or MSTest then this is likely to be the technique used. For frameworks which are based on binding classes such as SpecFlow, services are constructor-injected into binding classes. Use dependencies injected in this way to get access to commonly-used Screenplay services and anything else required at the root level of your test logic. Into standalone performance logic If you are using Screenplay standalone then the Screenplay.ExecuteAsPerformanceAsync permits resolution of dependencies via its parameter. That parameter is a Func<IServiceProvider,CancellationToken,Task<bool?>>. The service provider may be used to resolve dependency services for the performance's logic. Developers are urged to consider encapsulating their performance logic in implementations of IHostsPerformance. Through an overload (extension method) named ExecuteAsPerformanceAsync<T>, developers may specify the concrete implementation of that interface. This extension method will resolve that implementation type along with any of its constructor-injected dependencies. This avoids the service locator anti-pattern and provides a convenient pattern by which to write performance logic. Use services resolved from the service provider, or injected into your IHostsPerformance implementation, to get access to commonly-used Screenplay services and anything else required at the root level of your performance logic. Into personas Types which derive from IPersona support constructor-injected dependencies. Personas are typically used by either the cast or the stage to get an Actor. The technique in which they are used means that they are resolved, along with their constructor-injected dependencies, from DI. Use constructor-injected dependencies in persona classes to provide access to the APIs required to resolve Abilities that the actor is to be granted. Into performables See the article explaining how performables get their dependencies."
  },
  "docs/dependencyInjection/Performables.html": {
    "href": "docs/dependencyInjection/Performables.html",
    "title": "How Performables get their dependencies | Screenplay docs",
    "keywords": "How Performables get their dependencies Importantly, Performable types do not participate in dependency injection from the container. This means that dependency services cannot be constructor-injected into performable types. Performables' state represents parameters Performables are created using the builder pattern and do not hold references to any dependency services. Instead, the state of the performable represents the 'parameters' for that performable. This state is typically set via constructor parameters or public settable properties. An example For example, a Task which adds an item to the user's shopping basket might accept a constructor parameter representing the unique ID of the product to be added to the basket. That unique ID would be stored within the performable instance, in a field or property for example. When the relevant ExecuteAsync method is executed, the unique ID stored in the performable instance is used to conduct whatever logic is appropriate. Use abilities to get dependencies Performables, specifcally Actions and Questions, should access their dependencies via the Actor's [Abilities] by using the GetAbility<T> method or similar. In this sense, Abilities are a form of dependency injection or service locator (for a specific use case). Whilst service locators are usually considered an anti-pattern, the benefits in this specific case outweigh the disadvantages. The primary benefit is the ability to create performables from static builders. Importantly, Tasks should never make use of [Abilities]. Only Actions and Questions should use Abilities."
  },
  "docs/dependencyInjection/index.html": {
    "href": "docs/dependencyInjection/index.html",
    "title": "Dependency injection | Screenplay docs",
    "keywords": "Dependency injection The Screenplay design pattern is fundamentally compatible with and based upon dependency injection, aka DI. You may add Screenplay to an existing container if you wish, via the AddScreenplay extension method. Alternatively you may create an instance of Screenplay which uses its own self-contained DI container with the static Screenplay.Create helper method. Scopes Screenplay makes use of Dependency Injection Scopes. As you can see on the diagram of how Actors, Abilities and Performables relate to one another, each Screenplay contains and executes many Performances. Each performance is executed within its own DI scope, thus scoped services will have one shared instance per performance. It is also important to note that within DI, the Screenplay object must be added as a singleton (the mechanisms described above all do this for you). As a consequence there may be at most one Screenplay object per dependency injection container. Using DI in Screenplay TODO: Write this section! Injecting services Adding services Abilities as a form of DI"
  },
  "docs/extendingScreenplay/AbilitiesActionsAndQuestions.html": {
    "href": "docs/extendingScreenplay/AbilitiesActionsAndQuestions.html",
    "title": "Writing new Abilities, Actions & Questions | Screenplay docs",
    "keywords": "Writing new Abilities, Actions & Questions Screenplay ships with a small number of Abilities and performables but it is designed to be extended with new ones. New Abilities, Actions and Questions extend Screenplay by allowing Actors to interact with new APIs, services and libraries. Broadly-speaking to extend Screenplay in this way you must: Write one or more new ability types which provide access to the API of the service or library with which you'd like to interact Write one or more Action and/or Question Performables which make use of that ability Writing abilities Recall that Abilities represent capabilities & dependencies granted to or associated with Actors. It is normal for developers to want to write new Ability classes in order to provide capabilities/dependencies which are not yet catered-for. Ability classes do not need to derive from any particular base type, although it is strongly recommended that they implement ICanReport. Ability classes may constructor-inject dependencies and should declare whatever API is appropriate. Writing Actions and/or Questions Hand-in-hand with writing new ability classes, comes writing new Action and/or Question performables. These classes must derive from an appropriate Performable interface and should also implement ICanReport. These actions/questions should interact with the ability and make use of its functionality or return a value accordingly. Recall that actions & questions should be as granular as reasonably possible, accepting whatever parameters are appropriate for the usage of the ability. Continue to follow best practice for performables, though."
  },
  "docs/extendingScreenplay/EventHandlers.html": {
    "href": "docs/extendingScreenplay/EventHandlers.html",
    "title": "Writing new Event handlers | Screenplay docs",
    "keywords": "Writing new Event handlers A Screenplay is an architecture for directing a series of steps, organised into groups named Performances. Within that architecture is an event model, which allows arbitrary logic to subscribe to the progress of a Screenplay and react accordingly. This is one of the natural extension points within the Screenplay library. How to subscribe to events Within the CSF.Screenplay.Abstractions library/NuGet package is the type IHasPerformanceEvents. An instance of this type is available to resolve via dependency injection whilst a Screenplay is in-progress. Within DI, this object is a singleton which will emit when any significant Screenplay-related event occurs. Take a look at the API of the interface and its documentation to read about the available events and their meaning. If you wish to extend Screenplay you may subscribe to these from your own logic as you please."
  },
  "docs/extendingScreenplay/ReportFormtters.html": {
    "href": "docs/extendingScreenplay/ReportFormtters.html",
    "title": "Writing new Report value formtters | Screenplay docs",
    "keywords": "Writing new Report value formtters To get the best results when Screenplay writes a report, the wording in the reports should be human-readable and avoid language that relates to .NET. Reports are built from report fragments, accumulated during each performance. Baseline reporting functionality It's strongly recommended that all performables and all abilities implement the ICanReport interface. This allows these types to generate report fragments when they are performed-by or granted-to to Actors. Performables and abilities which do not implement ICanReport will use a default/fallback report template which is likely to produce sub-optimal results. Formatting values As noted in the documentation for report fragments, they are written using template strings which include a placeholder syntax. Values must be inserted into these placeholders to get the final report; this is performed by IFormatsReportFragment. There are a few mechanisms by which IFormatsReportFragments converts values to human-readable strings; you are encouraged to pick the most suitable for each scenario. You may extend Screenplay with new implementations of IHasName, IFormattableValue and/or IValueFormatter. Objects with names Actors and some other types implement the interface IHasName. This is suitable for objects which would always appear the same in any report. For example, the Actor \"Joe\" is always \"Joe\"; there's nothing more to their name than that. Self-formattable values Types which implement IFormattableValue have a FormatForReport() method which returns a human-readable formatted representation of that object, suitable for appearance in reports. Use this if the object's state must be used to get the reporting representation, but does not require any external dependencies or services. Obviously, you must have control over the type - the ability to add IFormattableValue to its interfaces - in order to use this technique. Value formatters Value formatters are external objects which are able to format objects, without needing to make any changes to the object-to-be-formatted. Value formatters implement the interface IValueFormatter and must be added to dependency injection, as well as registered with the IFormatterRegistry. The easiest way to perform both of these is to add the Type of the value formatter implementation to ScreenplayOptions.ValueFormatters when creating the Screenplay. Any types added here will automatically be included in the formatter registry and added to DI when the Screenplay is built. Use this technique when either you require external services from dependendency injection to format the object, or if you are unable/unwilling to have the type to be formatted implement IFormattableValue. Use ToString() The least optimal mechanism of formatting values in a report is to rely on the built-in (or an overridden) Object.ToString() method. Whilst this will work in reports, it is intended as fallback functionality for types which are not covered by any of the techniques above. The results of the ToString() method are often a very poor choice for reports."
  },
  "docs/extendingScreenplay/TestIntegrations.html": {
    "href": "docs/extendingScreenplay/TestIntegrations.html",
    "title": "Writing new Test framework integrations | Screenplay docs",
    "keywords": "Writing new Test framework integrations A way in which Screenplay is available for extension is the integration of Screenplay with other Test frameworks. Screenplay currently ships with integrations for NUnit and SpecFlow but developers are free to integrate it into other frameworks if they wish. Developers who are interested in this may use the source code to these two integrations as inspiration. Requirements To integrate with a test framework, the minimum requirements are as follows. Requirements which must be fulfilled are crucial to the operation of Screenplay; the integration will malfunction if they are not satisfied. Requirements which should be fulfilled are not crucial, but are strongly recommended for a good developer experience when using the integration. Terminologies differ between testing frameworks; the word Scenario is used to refer to the individual tests that the testing framework executes. The test framework must create an instance of Screenplay before it runs any Scenarios If the test framework uses dependency injection then it is advantageous to integrate Screenplay with that, via AddScreenplay If not then consider the Create factory method Consider permitting extensibility here, using the IGetsScreenplay interface Before any Scenarios run, the framework must execute BeginScreenplay() from the Screenplay instance After all Scenarios have completed it must execute CompleteScreenplay() from the Screenplay instance Each Scenario in the test framework must have its own Performance, within its own a DI lifetime scope Consider using the CreateScopedPerformance method to achieve this The Performance associated with each Scenario should have its NamingHierarchy set according to the name of the Scenario Typically this is done via parameter when creating the Performance It may alternatively be updated after creation Test frameworks have different conventions, so the precise semantics of this name is up to the framework itself The purpose of setting this is to clearly match the Performance to the Scenario to which it relates, when reading reports; if missing then the information will not be present in the report Before the logic of each Scenario starts, the BeginPerformance() method must be executed from the corresponding Performance After the logic of each Scenario ends, the FinishPerformance(bool?) method must be executed from the corresponding Performance After the logic of each Scenario ends, the dependency injection scope associated with the Performance should be disposed Failure to do this could lead to memory leaks or unnecesarily high resource usage whilst the Screenplay is in-progress The test framework must provide access to at least the ICast and IStage, resolved from the Scenario's dependency injection scope, to the Scenario logic The manner of doing this depends entirely on the test framework By way of example, in NUnit this is performed by providing the values of parameters to the test method, in SpecFlow this is performed by resolving step bindng classes from that same DI scope, allowing constructor injection"
  },
  "docs/extendingScreenplay/index.html": {
    "href": "docs/extendingScreenplay/index.html",
    "title": "Extending Screenplay | Screenplay docs",
    "keywords": "Extending Screenplay Screenplay has numerous extension points available for developers to add their own functionality. Abilities, Actions & Questions Dependency services Event handlers Report value formatters Test integrations"
  },
  "docs/nUnitTutorial/BestPractices.html": {
    "href": "docs/nUnitTutorial/BestPractices.html",
    "title": "NUnit & Screenplay best practices | Screenplay docs",
    "keywords": "NUnit & Screenplay best practices TODO: Write this docco Keep assertions out of performables Use the async test syntax"
  },
  "docs/nUnitTutorial/index.html": {
    "href": "docs/nUnitTutorial/index.html",
    "title": "Screenplay & NUnit tutorial | Screenplay docs",
    "keywords": "Screenplay & NUnit tutorial Begin writing NUnit tests using Screenplay by following these steps. Further detail is provided below. Ensure that your test project uses NUnit version 3.6.0 or higher Install the NuGet package CSF.Screenplay.NUnit to your test project Write a class which implements IGetsScreenplay Decorate your test assembly with ScreenplayAssemblyAttribute, referencing your implementation of IGetsScreenplay Write your tests, decorating each test method with ScreenplayAttribute Add parameters to your test methods to access the Screenplay architecture Tip Developers are encouraged to read these best practices for writing NUnit tests which use Screenplay. Decorating your test assembly with [ScreenplayAssembly] So that your tests may make use of a Screenplay, you must install the Screenplay extension to the NUnit testing framework. This is steps 3 & 4 in the list above. This is achieved using the ScreenplayAssemblyAttribute. Place a line of code somewhere in your test project, outside of any type definition like this: [assembly: CSF.Screenplay.ScreenplayAssembly(typeof(MyScreenplayFactory))] There is one other thing you must do, and that is to write a screenplay factory class, which configures how the Screenplay should be created for your tests. A screenplay factory is a class which must implement IGetsScreenplay. Consider the example below as a starting point for writing your own. using CSF.Screenplay; public class MyScreenplayFactory : IGetsScreenplay { public Screenplay GetScreenplay() { return Screenplay.Create(services => { // Add your own dependency injection service descriptors to the service collection here // For example, services which will be used by Screenplay Abilities. }); } } Important When using NUnit with Screenplay, every Screenplay-using test within a test assembly (thus, within a .NET project) must share the same instance of Screenplay. This is not expected to be problematic, as all the Screenplay object does is set-up the Screenplay architecture and dependency injection for the tests. Writing test methods When writing test methods, the test methods must be decorated with ScreenplayAttribute, which activates Screenplay for that particular test method. NUnit test methods which are decorated with [Screenplay] may have test parameters; these parameters will be provided by dependency injection. This covers steps 5 & 6 in the list above. Here is an example of an NUnit test method which is written using Screenplay; it assumes that the assembly has been decorated with ScreenplayAssemblyAttribute, as noted above. Tip The ability, performables and DishwashingBuilder used in this test, related to washing dishes, are all fictitious. See the documentation for writing performables to learn about how these could be written. using CSF.Screenplay; using static CSF.Screenplay.PerformanceStarter; using static WashingTheDishes.DishwashingBuilder; [Test, Screenplay] public async Task TheDishesShouldBeCleanAfterJoeWashesThem(ICast cast, IDishWashingAbility washTheDishes) { var joe = cast.GetActor(\"Joe\"); joe.IsAbleTo(washTheDishes); await Given(joe).WasAbleTo(GetSomeDirtyDishes()); await When(joe).AttemptsTo(WashTheDishes()); var dishesCondition = await Then(joe).Should(LookAtTheDishesCondition()); Assert.That(dishesCondition, Is.EqualTo(\"Clean\")); }"
  },
  "docs/performables/WebApis.html": {
    "href": "docs/performables/WebApis.html",
    "title": "Web APIs | Screenplay docs",
    "keywords": "Web APIs Screenplay may be used to interact with Web APIs. Key to this is Ability class MakeWebApiRequests, along with a number of performables and types which represent API endpoints. Use WebApiBuilder to simplify usage The section & table below indicates the combinations of 'endpoint' & performable to use for several common use cases. If the correct endpoint has been used though, the WebApiBuilder class will make it very easy to select the correct performable, by type inference. For any requests which are expecting to read a response as a JSON string, to be deserialized, use an overload of GetTheJsonResult from the static web API builder. For any other requests, use an overload of SendTheHttpRequest. The recommended way to use this builder is via using static CSF.Screenplay.WebApis.WebApiBuilder; in the source file for a custom performable. Combinations of endpoints & performables for common usages The performable which should be used, along with the approproate endpoint type depends upon your use case, summarised in the table below. The table is organised by the expected body/content of the HTTP request, the request payload and the expected type of the response body. Where None is listed, this usually means that either the request or response have no body, such as an HTTP GET request that does not send a body or an empty response. In the case of responses this might alternatively mean that the response body will be ignored or will not be interpreted as an instance of any particular type. Request payload Response type Endpoint type Performable type None None Endpoint SendTheHttpRequest None Deserialized with custom logic Endpoint<TResponse> SendTheHttpRequestAndGetTheResponse<T> None Deserialized from JSON Endpoint<TResponse> SendTheHttpRequestAndGetJsonResponse<T> Serialized with custom logic None Derive from ParameterizedEndpoint<TParameters> SendTheHttpRequest Serialized with custom logic Deserialized with custom logic Derive from ParameterizedEndpoint<TParameters,TResponse> SendTheHttpRequestAndGetTheResponse<T> Serialized with custom logic Deserialized from JSON Derive from ParameterizedEndpoint<TParameters,TResponse> SendTheHttpRequestAndGetJsonResponse<T> Serialized with JSON None JsonEndpoint<TParameters> SendTheHttpRequest Serialized with JSON Deserialized with custom logic JsonEndpoint<TParameters,TResponse> SendTheHttpRequestAndGetTheResponse<T> Serialized with JSON Deserialized from JSON JsonEndpoint<TParameters,TResponse> SendTheHttpRequestAndGetJsonResponse<T> Tip The rule to decide which types of endpoint & performable to choose is: Choose the endpoint type based upon the needs of the request, adding an extra generic type parameter if the response is to be strongly-typed. Choose the performable type based upon how you intend to read the response."
  },
  "docs/performables/index.html": {
    "href": "docs/performables/index.html",
    "title": "Performables | Screenplay docs",
    "keywords": "Performables Screenplay comes with a few pre-created Abilities, Performables and Builders, for common tasks. Some of these require the installation of additional NuGet packages. Using a Stopwatch When an actor needs to keep precise track of time, you may give them the UseAStopwatch ability. Actors with this ability may use Actions and Questions which relate to use of the stopwatch. These are all accessible from the builder class StopwatchBuilder. Interacting with web APIs The NuGet package CSF.Screenplay.WebApis provides an ability, performables and supporting types to interact with web API endpoints. Further information is available on the web API documentation page. TimeSpan builder The TimeSpanBuilder<TOtherBuilder> is not a complete performable builder; it is intended to supplement other builders such as those of your own design. It handles a commonly-used aspect of building performables in a reusable manner."
  },
  "docs/specFlowTutorial/index.html": {
    "href": "docs/specFlowTutorial/index.html",
    "title": "Screenplay & SpecFlow tutorial | Screenplay docs",
    "keywords": "Screenplay & SpecFlow tutorial Begin writing SpecFlow tests using Screenplay by following these steps. Further detail is provided below. Ensure that your test project uses SpecFlow version 3.4.3 or higher Install the NuGet package CSF.Screenplay.SpecFlow to the project which will contain your .feature files Optional: Add services to dependency injection which will be required by the Abilities you intend to use. If required, use SpecFlow context injection & hooks to add these to the DI container. Write step binding classes which dependency-inject and use Screenplay's architecture Writing step bindings Important When using SpecFlow with Screenplay, every Screenplay-using test within a test assembly (thus, within a .NET project) must share the same instance of Screenplay. This is not expected to be problematic, as all the Screenplay object does is set-up the Screenplay architecture and dependency injection for the tests. When using Screenplay with SpecFlow, .feature files are written as normal. The only difference in writing your tests is that Step Binding classes should inject Screenplay architecture and use it within the bindings. The recommended services to inject into your step binding classes are either IStage or ICast. If you are using Personas, which are the recommended way to get Actors for your performances, then most step binding classes will need only one of the two services above. If you are not using Personas to get actors, then you might also need to inject some services which relate to the Abilities that you wish to grant actors. Example Tip The implied ability, the performables, persona and DishwashingBuilder used in this test, related to washing dishes, are all fictitious. See the documentation for writing performables to learn about how these could be written. This example assumes that SpecFlow is writting using the NUnit runner, and thus it makes use of NUnit-style assertions. Feel free to replace the assertion with whichever assertion library you wish to use. using CSF.Screenplay; using static CSF.Screenplay.PerformanceStarter; using static WashingTheDishes.DishwashingBuilder; [Binding] public class WashTheDishesSteps(IStage stage) { [Given(@\"^Joe was able to get some dirty dishes$\")] public async Task GetDirtyDishes() { var joe = stage.Spotlight<Joe>(); await Given(joe).WasAbleTo(GetSomeDirtyDishes()); } [When(@\"^(?:he|she|they) attempts? to wash the dishes$\")] public async Task WashTheDishes() { var actor = stage.GetSpotlitActor(); await When(actor).AttemptsTo(WashTheDishes()); } [Then(@\"^(?:he|she|they) should see that the dishes are clean$\")] public async Task GetDirtyDishes() { var actor = stage.GetSpotlitActor(); var condition = await Then(actor).Should(LookAtTheDishesCondition()); Assert.That(condition, Is.EqualTo(\"Clean\")); } }"
  },
  "docs/writingPerformables/AllowCooperativeCancellation.html": {
    "href": "docs/writingPerformables/AllowCooperativeCancellation.html",
    "title": "Allow cooperative cancellation | Screenplay docs",
    "keywords": "Allow cooperative cancellation All Performables implement one of three interfaces and each of these interfaces exposes a PerformAsAsync method which accepts a CancellationToken as a parameter. This cancellation token is to facilitate cooperative cancellation, so that a Performance may be cancelled/terminated gracefully. If an Action or Question makes use of an asynchronous method from an Ability then pass the cancellation token as a parameter to the Ability method that is used. Any time a Performance or Task executes a performable, pass the cancellation token down to the consumed performable as a parameter. Consider the strategies below for dealing with long-running synchronous methods, which do not natively participate in cooperative cancellation. There is no need for every performable (particularly tasks) to execute ThrowIfCancellationRequested() as a matter of course. Many performables complete their logic in microseconds or less, so excess cancellation-checking will bloat the logic for no perceivable gain. So long as the cancellation token is passed from 'the top of the Performance' downwards, and any Actions or Questions which perform async or long-running logic are cancellation-enabled, cancellation should work in a timely fashion. Dealing with long-running synchronous methods Sometimes an Action or Question will need to make use of functionality from an Ability which does not support cooperative cancellation. If such functionality is long-running then this can interfere with cancellation. It can lead to performances which take a long time to respond to cancellation of/when it is requested. Perhaps it's legacy code which predates the asynchronous programming model Perhaps it doesn't conform to best practice and doesn't accept a cancellation token parameter Here are two suggestions to deal with this. Throw if cancellation requested Cancellation token objects have a method ThrowIfCancellationRequested() which will interrupt and throw an exception if cancellation has been requested. You may use this method directly before executing a long-running synchronous (non-cancelable) Ability method. This won't cancel the long-running method if cancellation is requested after it has started its work, but it will prevent it from being started if cancellation is already requested. Use this technique if it's more important that the long-running method is not interrupted than it is to support timely cancellation. Use Task.Wait to make the long-running method interruptible An alternative strategy for dealing with long-running synchronous methods is to wrap the method execution in a new Task and use Task.Wait() to interrupt the task if cancellation is requested. Here's an example of that technique in action, applied to the PerformAsAsync method of a performable. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken) { Task.Run(() => LongRunningMethod()).Wait(cancellationToken); return default; } Use this technique if it's acceptable to send the long-running method into a separate thread and to 'give up waiting' for it to complete if cancellation has been requested. This technique might provide better responsiveness to cancellation than the one above, albeit it is the most likely to produce unexpected impact on the behaviour of the performable. Note that, as is standard for usage of Task.Wait(), cancelling the wait does not abort the execution of the long-running method. The thread which is executing that logic will usually continue and run to completion. Interrupting the wait just means that the main performance thread stops waiting for the other thread to complete."
  },
  "docs/writingPerformables/AvoidBranchingLogic.html": {
    "href": "docs/writingPerformables/AvoidBranchingLogic.html",
    "title": "Avoid branching logic | Screenplay docs",
    "keywords": "Avoid branching logic Performances are written a lot like scripts. Where possible, Performables should avoid branching or looping logic. This is particularly true when Screenplay is being used as a tool for testing. Good test logic has a cyclomatic complexity of precisely one. Sometimes looping logic is unavoidable and desirable in a Screenplay, imagine a performable which has an Actor repeat a process N times. This is acceptable if used judiciously. Performables should always avoid branching logic like if or switch though, and should never contain such logic when being used for tests. If more than one mode of operation is required then write more than one performable. The path through a Performance should be completely deterministic, short of an unexpected error or failure."
  },
  "docs/writingPerformables/DoNotUseDiFrameworks.html": {
    "href": "docs/writingPerformables/DoNotUseDiFrameworks.html",
    "title": "Do not resolve performables from DI | Screenplay docs",
    "keywords": "Do not resolve performables from DI Dependency Injection using DI frameworks is usually a recommended best practice in modern software. Screenplay recommends the resolution of many services from DI, including Personas, the Cast, Stage and Abilities. It is not a good idea to resolve Performable object instances from DI, though. Because performables should be immutable but stateful, this requires all of their state to be set at the time of their construction, such as via constructor parameters or properties with init setters. Unfortunately, this state represents the configuration of how the performable will be used, so it will be entirely down to the particular usage of the performable. This would make the use of DI quite cumbersome, as many arbitrary parameter values must be passed to the resolution. What's more, performables should not depend upon anything which is resolved from DI. At most, Actions and Questions may depend upon an Actor's Abilities but they should access these from the first parameter of the PerformAsAsync method; the ICanPerform parameter (the actor). Instead, it is far better to use the builder pattern to create instances of performables."
  },
  "docs/writingPerformables/ImplementICanReport.html": {
    "href": "docs/writingPerformables/ImplementICanReport.html",
    "title": "Implement ICanReport | Screenplay docs",
    "keywords": "Implement ICanReport When writing a Performable class, implement the ICanReport interface a well as the relevant performable interface. This enables a performable to emit a formatted, human-readable fragment of a report for the current performable. If you plan to redistribute your performables as a library then consider making your report fragments localizable strings, so that they may be translated for other locales."
  },
  "docs/writingPerformables/ImplementOnePerformableInterface.html": {
    "href": "docs/writingPerformables/ImplementOnePerformableInterface.html",
    "title": "Implementing the performable interface | Screenplay docs",
    "keywords": "Implementing the performable interface A Performable is a class which implements one of the three performable interfaces: IPerformable IPerformableWithResult IPerformableWithResult<TResult> Performables must implement precisely one of these interfaces. Implementing more than one upon a single performable is not recommended or supported. Doing so is liable to cause difficulties. If you wish to share code then move the reusable logic into a Task and consume that from separate performable classes."
  },
  "docs/writingPerformables/ParameterizeLowLevelPerformables.html": {
    "href": "docs/writingPerformables/ParameterizeLowLevelPerformables.html",
    "title": "Parameterize low-level Performables | Screenplay docs",
    "keywords": "Parameterize low-level Performables When writing low-level Performables, these classes should expose parameters which allow the consumer to provide as many of the variables as make sense. This is especially important for Actions and/or Questions but also relevant for lower-level/reusable Tasks. Parameters should be accepted via the class' public constructor, the values to these parameters should then be held readonly. Accept as many parameters as are reasonable, although avoid going so far that parameterisation makes a Performable unclear as to what it does. An example Imagine we are writing a Task which makes a cup of coffee, ready to serve. It would make sense to include parameters which decide the strength of the coffee, how much milk and sweetener to add and similar. It would usually be a mistake to create a Task which can make any hot drink, where the parameters provided decide which hot drink to make. The processes for making various hot drinks are often fundamentally different; consider the process for making coffee and then that for brewing tea. In the most extreme case, where such a Task is required, separate the logic of making of each hot drink into Tasks of their own, and consume/execute the relevant one of these from the any hot drink Task."
  },
  "docs/writingPerformables/PureFunctionalTasks.html": {
    "href": "docs/writingPerformables/PureFunctionalTasks.html",
    "title": "'Pure functional' tasks | Screenplay docs",
    "keywords": "'Pure functional' tasks To maximise their reusability, developers are advised to write Tasks in a way which either: Changes the application's state Gets information from the application without changing its state This draws from the lessons that writing pure functions teaches us. If 'getting some information' has unwanted or unexpected side-effects then the task becomes less reusable. If a task must have side effects then consider separating the parts of it which do not require those side-effects into a lower-level task which is reusable without the side-effects. That lower-level task would then be consumed by a higher-level task which does include the side-effects."
  },
  "docs/writingPerformables/StatefulButImmutable.html": {
    "href": "docs/writingPerformables/StatefulButImmutable.html",
    "title": "Performables are stateful, but immutable | Screenplay docs",
    "keywords": "Performables are stateful, but immutable Instances of Performable classes are not intended to be reused. A single class may have many instances created, but each instance should be used only once. This is because the 'parameter values' for each performable are provided into that performable object instance. Parameters should ideally be provided into the performable class' public constructor. Another viable technique could be init-only property setters. Once these values are set, they should be readonly so that they may not be changed. Performable classes should also avoid the use of mutable class-level data such as fields or properties. Any temporary state should be scoped only to the relevant PerformAsAsync method."
  },
  "docs/writingPerformables/TasksDoNotUseAbilities.html": {
    "href": "docs/writingPerformables/TasksDoNotUseAbilities.html",
    "title": "Tasks should not use abilities | Screenplay docs",
    "keywords": "Tasks should not use abilities The logic of Task classes should not interact with the actor's Abilities. Logic which interacts with abilities should be limited to Action and/or Question classes. Move logic which needs to interact with Abilities into Action/Question classes and ensure that they are appropriately parameterized. Consume such actions or questions from your custom Task class."
  },
  "docs/writingPerformables/WriteABuilder.html": {
    "href": "docs/writingPerformables/WriteABuilder.html",
    "title": "Write builders for your performables | Screenplay docs",
    "keywords": "Write builders for your performables If you write a new performable class, it is strongly recommended to write a static builder for it. Benefits include: Ensuring that the performable may only be created in a valid state Making your performance logic more human-readable, almost like a domain specific language"
  },
  "docs/writingPerformables/index.html": {
    "href": "docs/writingPerformables/index.html",
    "title": "Writing Performables | Screenplay docs",
    "keywords": "Writing Performables Screenplay and add-on libraries will ship with pre-created Actions and Questions, two of the three types of Performable. Developers making use of Screenplay might not need to write new Actions or Questions, because they may use and compose the existing ones. On the other hand, it is very likely that developers will need to write Tasks, which are the kind of Performable which composes Actions, Questions and/or other Tasks. A sample Task Here is an annotated example of a Task which makes use of a fictitious Action and a fictitious Question. TODO: Write this docco Guidelines for writing performables The following list shows some guidelines for writing new performables. These apply equally across ask if the three types of performables, even though developers are mainly expected to be writing tasks. Implement precisely one performable interface Implement ICanReport Parameterize low-level performables Avoid branching logic Performables should be stateful but immutable Allow cooperative cancellation Write a builder Do not rely on a DI framework Aim for Pure Functional tasks Do not interact with Abilities from Tasks"
  },
  "glossary/Ability.html": {
    "href": "glossary/Ability.html",
    "title": "Ability | Screenplay docs",
    "keywords": "Ability An ability is an arbitrary object which may be granted to Actors in order to allow them to interact with the application as part of a Performance. Unlike many other Screenplay object-types, there is no particular interface which Abilities must implement, as their functionality, capabilities and very nature are specific to them alone. That said - it is recommended for Abilities to implement ICanReport if possible, as this allows for the production of a more pleasant human-readable report. Actions and/or Questions may interact directly with an actor's abilities in order to perform their functionality. Tasks, on the other hand, should not. The purpose of abilities Abilities typically have one (or more) of the following purposes. They provide a Gateway or Façade to external functionality They provide access to dependency services They provide a model of data, such as: Secrets/access tokens for an API to be consumed by abilities Contextual per-performance state Abilities are intended to be used by Actions and/or Questions, not Tasks. Abilities provide the dependencies that those performables require, because performables cannot participate in constructor-injected dependency injection. Abilities can receive constructor-injected dependencies from DI, making them an ideal technique to provide dependencies to performables."
  },
  "glossary/Action.html": {
    "href": "glossary/Action.html",
    "title": "Action | Screenplay docs",
    "keywords": "Action An Action is a kind of Performable in which an Actor does something or interacts with the application in such as way as to change its state. Specifically, an action should be the smallest, most granular change or interaction possible; something which cannot reasonably be split into constituent parts. In an application of Screenplay which controls a web browser, an action might be a single mouse click, or entering some specified text into an input field. To create higher-level interactions, use Tasks to compose actions. Out of the kinds of performable, actions are the smallest building blocks available. Actions don't have a direct representation in Screenplay code because they are really just an arbitrary category of performable. Actions most commonly implement the IPerformable interface though, as they usually do not return any results. Generally, the logic of actions interacts directly with the actor's Abilities in order to provide the functionality required to perform the action."
  },
  "glossary/Feature.html": {
    "href": "glossary/Feature.html",
    "title": "Feature | Screenplay docs",
    "keywords": "Feature A Feature is a concept which is relevant when the Screenplay library is being used to perform automated tests. Each feature is a logical group of one or more related Scenarios. In Screenplay, features exist only for organising scenarios. They have no first-class representation in the code; their only appearance is within Reports. Everything related to features is handled automatically when consuming Screenplay from an appropriate Integration. Depending upon the testing framework in use, features might alternatively be named \"test fixture\" or \"test class\"."
  },
  "glossary/Integration.html": {
    "href": "glossary/Integration.html",
    "title": "Integration | Screenplay docs",
    "keywords": "Integration An Integration refers to an integration library between the Screenplay library and a framework for performing automated tests. The integration library performs the necessary scaffolding to make the Screenplay types available for dependency injection. It also deals with the association of Scenarios with Performances and the lifetime of the whole Screenplay, culminating with the production of the Report."
  },
  "glossary/Performable.html": {
    "href": "glossary/Performable.html",
    "title": "Performable | Screenplay docs",
    "keywords": "Performable A 'performable' is a verb in the language of Screenplay; performables are things that Actors do. Performables are logically grouped into one of the following three kinds. Do not be mistaken in believing that these three kinds of performable correspond to the three interfaces which are listed later on this page. This is entirely coincidental and there is no direct equivalence. Actions are the most granular of individual interactions with the application, composable to form higher-order interactions Questions are granular, like actions, but read the application's state to get information instead of making changes Tasks are higher-order interactions which are formed by composing actions, questions and/or other tasks Performable instances are not reusable Types which implement the performable interfaces (below) are stateful objects which are often mutable. Their state defines their configuration, as such, instances of any performable type must not be reused. Typically, performables are created using a builder which configures their state. Each performable object is used precisely once by an actor and then discarded. Even if you would like to perform the same operation twice, do not attempt to reuse an object instance; use the builder twice to create two (identical) instances of the same performable type. Developers using Screenplay will typically be writing Tasks Actions & Questions are the smallest/low-level building blocks of a Screenplay Performance. They are parameterized and should make as few assumptions as possible. As such, they should be highly reusable. Actions & Questions rarely need to be written by developers who are using Screenplay. That is because most likely, the Action, Question and corresponding Ability classes will have been provided in a library, such as a NuGet package. On the other hand, Tasks are higher-level performables which may compose Actions, Questions and/or other lower-level Tasks. Developers using Screenplay should write as many Tasks as they need. Tasks may represent any of the - possibly complex - interactions performed by the Actor. Actions & Questions should interact directly with the Actor's Abilities to perform their logic; in most cases Tasks should not directly use any Abilities. When writing your own performables, consider these best practices for the best results. The three performable interfaces, and ICanReport In Screenplay code, a Performance is a script of sorts, written from at least one performable, usually several. All performables must implement one of the following three interfaces, but it's also strongly recommended to implement ICanReport as well. As noted above, it is coincidence alone that there are three kinds of performable and three interfaces for performables. There is no direct correlation between these interfaces and the kinds of performable. IPerformable IPerformableWithResult IPerformableWithResult<TResult>"
  },
  "glossary/Persona.html": {
    "href": "glossary/Persona.html",
    "title": "Persona | Screenplay docs",
    "keywords": "Persona A Persona is a class which serves as a factory for a specific Actor. In Screenplay, it is strongly recommended to create and re-use well-known Actors across your Performances. That is, if an actor with a specified Name has a certain set of Abilities in one Performance, then ideally all actors of the same name should have that same set of abilities in other performances. This leads to the creation of well-known Actors which are well-understood by the team who are working with Screenplay. Personas help facilitate that by providing a reusable location at which to set the actor's name and to assign & configure their abilities. Personas in Screenplay are classes which implement the IPersona interface."
  },
  "glossary/Question.html": {
    "href": "glossary/Question.html",
    "title": "Question | Screenplay docs",
    "keywords": "Question A Question is a kind of Performable in which an Actor gets or reads some information from the application, ideally in such a way that does not change the application's state. Similar to Actions, questions should be as small in their scope as possible, to make them as reusable and composable as possible. In code, questions get a value and return it to the consuming logic, so they will always implement one of IPerformableWithResult<TResult> or its non-generic counterpart IPerformableWithResult. In an application of Screenplay which controls a web browser, a questions might represent reading the text from a single HTML element, or reading the enabled/disabled state of a button. To create higher-level questions with broader scope, compose them with Tasks. Generally, the logic of questions interacts directly with the actor's Abilities in order to provide the functionality required to get the requested information."
  },
  "glossary/Report.html": {
    "href": "glossary/Report.html",
    "title": "Report | Screenplay docs",
    "keywords": "Report After a Screenplay has completed, the Screenplay software may produce a machine-readable report of what occurred. This report may be read, processed, stored or transformed into an alternative format as desired. The report is hierarchical; at its topmost level are Features and within are Scenarios. The scenario directly corresponds to a single Performance, and within are contained all of the Performables for that performance. Performables in a report are also included hierarchically. This means that high-level Tasks contain information about the performables from which they are composed. Reports are useful to document what has been performed in a Screenplay. They help developers diagnose and debug issues when they arise."
  },
  "glossary/Scenario.html": {
    "href": "glossary/Scenario.html",
    "title": "Scenario | Screenplay docs",
    "keywords": "Scenario A Scenario is a single test within a testing framework. Testing frameworks differ between one another in the terminology that they use to name their individual tests. Screenplay uses the name \"Scenario\" because this matches the name used in Cucumber. Scenarios are only relevant when Screenplay is used in conjunction with a test framework integration. It is irrelevant when using Screenplay standalone. A Scenario represents the lifetime of each individual test; when using Screenplay as a testing tool, the lifetime of the Scenario corresponds very closely to the lifetime of a Performance. When using Screenplay, each Performance (and thus Scenario) is executed within its own Dependency Injection Lifetime Scope. Every scenario is typically contained within a Feature. The structure of scenarios-within-features may be represented in the Performance using the NamingHierarchy. Other names for Scenarios Various testing frameworks have established different naming conventions for what is - fundamentally - the same thing. Here are some other names which you might see in different testing frameworks. Test Test case Theory Example"
  },
  "glossary/Spotlight.html": {
    "href": "glossary/Spotlight.html",
    "title": "Spotlight | Screenplay docs",
    "keywords": "Spotlight When the Stage is used to get an Actor, that actor is placed in the Spotlight. That same actor remains in the spotlight until a different actor is placed there. Note, though, that a Stage and thus its corresponding Spotlight is scoped to the current Performance. A different performance has a completely independent Stage and Spotlight. A stage may be used at any time to get the actor who is currently in the spotlight. Thus, it is possible to infer an actor in Performance logic without needing to use their name. See the documentation for the Stage for more information."
  },
  "glossary/Task.html": {
    "href": "glossary/Task.html",
    "title": "Task | Screenplay docs",
    "keywords": "Task A Task is a kind of Performable which represents a high-level interaction with the application. Where Actions or Questions are highly granular for maximum reusability, tasks may be as specific as the use-case warrants. Action & question classes are often shipped with Screenplay frameworks. Tasks are typically written by the developer who is making use of Screenplay. In practice, tasks are just compositions of actions, questions or other lower-level tasks. In a Screenplay which controls a web application, an example of a task is the completion of a registration form which involves entering data into multiple input fields. Writing tasks Tasks may implement any of the three performable interfaces. Developers are encouraged to follow these best practices when writing Task classes."
  },
  "glossary/index.html": {
    "href": "glossary/index.html",
    "title": "Glossary | Screenplay docs",
    "keywords": "Glossary Following is a glossary of Screenplay terminology; each term is a link to its own documentation. Many of these terms are implemented directly as .NET types in the Screenplay architecture. Where applicable, the glossary item links directly to the relevant type within the API documentation. Term Summary Screenplay A complete execution of the Screenplay software Performance A single end-to-end script of performables Performable A Screenplay verb; something that an actor can do Action A kind of peformable; the lowest-level interaction that changes the state of the application Question A kind of peformable; the lowest-level interrogation that reads application state Task A composition of actions, questions and/or other tasks to create higher-level performables Actor Typically a human user of the application, directs the use of performables Ability Something that an actor is able to do or has; provides the dependencies for actions/questions Persona A factory or template for consistently creating reusable, well-known actors Cast A factory & registry for actors which facilitates managing multiple actors in a performance Stage Provides situational context; a concept of 'the currently active actor' Spotlight The currently active actor, facilitated by the stage Report An output which details every performance/scenario and the outcomes of theie performables Scenario Typically similar to a performance, this is a single test within a testing framework Feature A logical group of related scenarios, this is a test class or test fixture in some testing frameworks Integration A consumer of the Screenplay framework, such as a testing framework"
  },
  "index.html": {
    "href": "index.html",
    "title": "Screenplay pattern | Screenplay docs",
    "keywords": "Screenplay pattern Screenplay is a software design pattern to assist in the automation of complex processes. It is particularly useful for writing tests which use a Behaviour Driven Development (BDD) style. CSF.Screenplay is a library and framework for using this design pattern. Learn about Screenplay's concepts Makeup of a Performance How a Screenplay runs Using dependency injection Glossary of Screenplay terminology As a testing tool Screenplay is useful for directing integration and system tests. It may be used for testing web applications via a web browser. In that context, Screenplay is a refinement of the Page Object Pattern. Screenplay in the testing stack NUnit & Screenplay tutorial SpecFlow & Screenplay tutorial Using Screenplay Writing performables, usually tasks Writing builders Getting reports Using pre-created Abilities & Performables Using Screenplay standalone"
  }
}