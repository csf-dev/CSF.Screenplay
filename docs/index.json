{
  "api/CSF.Screenplay.Abilities.UseAStopwatch.html": {
    "href": "api/CSF.Screenplay.Abilities.UseAStopwatch.html",
    "title": "Class UseAStopwatch | Screenplay docs",
    "keywords": "Class UseAStopwatch Namespace CSF.Screenplay.Abilities Assembly CSF.Screenplay.Abstractions.dll An ability that enables an actor to make use of a Stopwatch to accurately measure the passage of time. public class UseAStopwatch : ICanReport Inheritance object UseAStopwatch Implements ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Use this ability with the actions which exposed by StopwatchBuilder. This ability wraps a Stopwatch instance, allowing the actor to control & read it from the related actions. Properties Stopwatch Gets the stopwatch granted to the actor by this ability. public Stopwatch Stopwatch { get; } Property Value Stopwatch Methods GetReportFragment(IHasName) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public string GetReportFragment(IHasName actor) Parameters actor IHasName An actor for whom to write the report fragment Returns string A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose."
  },
  "api/CSF.Screenplay.Abilities.html": {
    "href": "api/CSF.Screenplay.Abilities.html",
    "title": "Namespace CSF.Screenplay.Abilities | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.Abilities Classes UseAStopwatch An ability that enables an actor to make use of a Stopwatch to accurately measure the passage of time."
  },
  "api/CSF.Screenplay.Actor.html": {
    "href": "api/CSF.Screenplay.Actor.html",
    "title": "Class Actor | Screenplay docs",
    "keywords": "Class Actor Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A representation of an autonomous, or at least seemingly-autonomous, person or system which directs the events of a IPerformance. public class Actor : IHasAbilities, IHasName, IHasPerformanceIdentity, IDisposable, IHasPerformableEvents, ICanPerform, ICanPerformGiven, ICanPerformWhen, ICanPerformThen Inheritance object Actor Implements IHasAbilities IHasName IHasPerformanceIdentity IDisposable IHasPerformableEvents ICanPerform ICanPerformGiven ICanPerformWhen ICanPerformThen Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods ActorExtensions.WasAbleTo(ICanPerformGiven, IGetsPerformable, CancellationToken) ActorExtensions.WasAbleTo(ICanPerformGiven, IGetsPerformableWithResult, CancellationToken) ActorExtensions.WasAbleTo<T>(ICanPerformGiven, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.Should(ICanPerformThen, IGetsPerformable, CancellationToken) ActorExtensions.Should(ICanPerformThen, IGetsPerformableWithResult, CancellationToken) ActorExtensions.Should<T>(ICanPerformThen, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.AttemptsTo(ICanPerformWhen, IGetsPerformable, CancellationToken) ActorExtensions.AttemptsTo(ICanPerformWhen, IGetsPerformableWithResult, CancellationToken) ActorExtensions.AttemptsTo<T>(ICanPerformWhen, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.GetAbility(ICanPerform, Type) ActorExtensions.GetAbility<T>(ICanPerform) ActorExtensions.HasAbility(ICanPerform, Type) ActorExtensions.HasAbility<T>(ICanPerform) ActorExtensions.IsAbleTo(ICanPerform, object) ActorExtensions.IsAbleTo<TAbility>(ICanPerform) ActorExtensions.PerformAsync(ICanPerform, IGetsPerformable, CancellationToken) ActorExtensions.PerformAsync(ICanPerform, IGetsPerformableWithResult, CancellationToken) ActorExtensions.PerformAsync<T>(ICanPerform, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.HasAbility(IHasAbilities, Type) ActorExtensions.HasAbility<T>(IHasAbilities) Examples A good example of an actor, aside from a person, could be task scheduling software which executes logic at specific times of day. That is - provided that the task scheduling software itself is not a part of the Screenplay Performance. Within the context of such a performance, the task scheduler executing its logic at the configured time would appear to be an autonomous action because nothing else within the scope of the performance prompted it. Conversely, a mouse trap would be a poor example of an actor; a mouse trap acts only reactively. The creature entering the trap would be the actor in such a performance. Remarks An actor should represent an autonomous or semi-autonomous system. Most commonly is a human being using a piece of software. An actor might also represent an automated system which acts according to policy, so long as configuring/initating that system is not a part of the IPerformance. Within a performance, each performable item is executed in the context of the actor which performed it. Actors have abilities which provide them the means by which to interact with the software. A single conceptual actor must be represented by a single instance of this type; two actors of the same name are not considered to be the same actor, nor will they behave as such. Instances of actor should have an object lifetime which lasts for the remainder of the performance in which they were created. Instances of actor must not be shared across performances. In other words, they should be scoped to only a single performance. A single performance might involve only one actor or it might involve many. If a performance makes use of multiple actors, the developer should consider making use of either or both of the ICast and/or IStage, which assist in the management of multiple actors. Constructors Actor(string, Guid) Initialises a new instance of Actor public Actor(string name, Guid performanceIdentity) Parameters name string The actor's name performanceIdentity Guid A unique identity for the performance Properties Abilities Gets a collection of the actor's abilities protected virtual HashSet<object> Abilities { get; } Property Value HashSet<object> Name Gets the actor's name protected virtual string Name { get; } Property Value string PerformanceIdentity Gets the unique identity for the performance in which this actor is participating protected virtual Guid PerformanceIdentity { get; } Property Value Guid Methods Dispose() public void Dispose() Dispose(bool) Disposes the current instance, via the Dispose Pattern. protected virtual void Dispose(bool disposing) Parameters disposing bool A value indicating wherher or not disposal should occur. InvokeBeginPerformable(object, PerformancePhase) Invokes the BeginPerformable event. protected virtual void InvokeBeginPerformable(object performable, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item phase PerformancePhase The performance phase to which this event relates InvokeEndPerformable(object, PerformancePhase) Invokes the EndPerformable event. protected virtual void InvokeEndPerformable(object performable, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item phase PerformancePhase The performance phase to which this event relates InvokeGainedAbility(object) Invokes the GainedAbility event. protected virtual void InvokeGainedAbility(object ability) Parameters ability object The ability which this actor gained InvokePerformableFailed(object, Exception, PerformancePhase) Invokes the PerformableFailed event. protected virtual void InvokePerformableFailed(object performable, Exception exception, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item exception Exception The exception which halted the performable phase PerformancePhase The performance phase to which this event relates InvokePerformableResult(object, object, PerformancePhase) Invokes the PerformableResult event. protected virtual void InvokePerformableResult(object performable, object result, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item result object The result value from the performable phase PerformancePhase The performance phase to which this event relates IsAbleTo(object) Adds a new ability to the actor protected virtual void IsAbleTo(object ability) Parameters ability object The ability to add Exceptions ArgumentNullException If the ability is null InvalidOperationException If the actor already has an ability of this type or a derived type PerformAsync(IPerformable, PerformancePhase, CancellationToken) Performs an action or task which returns no result. protected virtual ValueTask PerformAsync(IPerformable performable, PerformancePhase phase = PerformancePhase.Unspecified, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item phase PerformancePhase The performance phase to which the performable belongs cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete Exceptions ArgumentNullException If the performable is null PerformAsync(IPerformableWithResult, PerformancePhase, CancellationToken) Performs an action or task which returns an untyped result. protected virtual ValueTask<object> PerformAsync(IPerformableWithResult performable, PerformancePhase phase = PerformancePhase.Unspecified, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item phase PerformancePhase The performance phase to which the performable belongs cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which completes when the performable is complete Exceptions ArgumentNullException If the performable is null PerformAsync<T>(IPerformableWithResult<T>, PerformancePhase, CancellationToken) Performs an action or task which returns a strongly typed result. protected virtual ValueTask<T> PerformAsync<T>(IPerformableWithResult<T> performable, PerformancePhase phase = PerformancePhase.Unspecified, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item phase PerformancePhase The performance phase to which the performable belongs cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which completes when the performable is complete Type Parameters T Exceptions ArgumentNullException If the performable is null Events BeginPerformable Occurs when the actor begins the execution of a performable object. public event EventHandler<PerformableEventArgs> BeginPerformable Event Type EventHandler<PerformableEventArgs> EndPerformable Occurs when an actor ends the execution of a performable object. public event EventHandler<PerformableEventArgs> EndPerformable Event Type EventHandler<PerformableEventArgs> GainedAbility Occurs when an actor gains a new ability. public event EventHandler<GainAbilityEventArgs> GainedAbility Event Type EventHandler<GainAbilityEventArgs> PerformableFailed Occurs when a performable object fails with an exception. public event EventHandler<PerformableFailureEventArgs> PerformableFailed Event Type EventHandler<PerformableFailureEventArgs> PerformableResult Occurs when an actor receives a result from a perfperformable objectrmance. public event EventHandler<PerformableResultEventArgs> PerformableResult Event Type EventHandler<PerformableResultEventArgs> See Also IPerformance ICast IStage"
  },
  "api/CSF.Screenplay.ActorExtensions.html": {
    "href": "api/CSF.Screenplay.ActorExtensions.html",
    "title": "Class ActorExtensions | Screenplay docs",
    "keywords": "Class ActorExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Extension methods for actor types public static class ActorExtensions Inheritance object ActorExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AttemptsTo(ICanPerformWhen, IGetsPerformable, CancellationToken) Performs an action or task which returns no result. public static ValueTask AttemptsTo(this ICanPerformWhen actor, IGetsPerformable performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformWhen An actor performableBuilder IGetsPerformable The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete AttemptsTo(ICanPerformWhen, IGetsPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. public static ValueTask<object> AttemptsTo(this ICanPerformWhen actor, IGetsPerformableWithResult performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformWhen An actor performableBuilder IGetsPerformableWithResult The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete AttemptsTo<T>(ICanPerformWhen, IGetsPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. public static ValueTask<T> AttemptsTo<T>(this ICanPerformWhen actor, IGetsPerformableWithResult<T> performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformWhen An actor performableBuilder IGetsPerformableWithResult<T> The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type GetAbility(ICanPerform, Type) Gets the first ability which the actor has of the specified type public static object GetAbility(this ICanPerform actor, Type abilityType) Parameters actor ICanPerform The actor from whom to get the ability abilityType Type The type of ability desired Returns object The ability instance Exceptions ArgumentNullException If any parameter is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor does not have an ability which is or derives from abilityType GetAbility<T>(ICanPerform) Gets the first ability which the actor has of the specified type public static T GetAbility<T>(this ICanPerform actor) Parameters actor ICanPerform The actor from whom to get the ability Returns T The ability instance Type Parameters T The type of ability desired Exceptions ArgumentNullException If the actor is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor does not have an ability which is or derives from T HasAbility(ICanPerform, Type) Gets a value which indicates if the actor has an ability of the specified type. public static bool HasAbility(this ICanPerform actor, Type abilityType) Parameters actor ICanPerform An actor abilityType Type The ability type for which to test Returns bool true if the actor has an ability of the specified abilityType; false if not. Remarks This method will also return false if the actor does not implement IHasAbilities. HasAbility(IHasAbilities, Type) Gets a value which indicates if the actor has an ability of the specified type. public static bool HasAbility(this IHasAbilities actor, Type abilityType) Parameters actor IHasAbilities An actor abilityType Type The ability type for which to test Returns bool true if the actor has an ability of the specified abilityType; false if not. HasAbility<T>(ICanPerform) Gets a value which indicates if the actor has an ability of the specified type. public static bool HasAbility<T>(this ICanPerform actor) Parameters actor ICanPerform An actor Returns bool true if the actor has an ability of the specified T; false if not. Type Parameters T The ability type for which to test Remarks This method will also return false if the actor does not implement IHasAbilities. HasAbility<T>(IHasAbilities) Gets a value which indicates if the actor has an ability of the specified type. public static bool HasAbility<T>(this IHasAbilities actor) Parameters actor IHasAbilities An actor Returns bool true if the actor has an ability of the specified T; false if not. Type Parameters T The ability type for which to test IsAbleTo(ICanPerform, object) Adds an ability to the specified actor public static void IsAbleTo(this ICanPerform actor, object ability) Parameters actor ICanPerform The actor from whom to get the ability ability object The ability to add to the actor Exceptions ArgumentNullException If any parameter is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor already has an ability of the same type as the ability to add, or which derives from the same type IsAbleTo<TAbility>(ICanPerform) Adds an ability to the specified actor, where the ability has a public parameterless constructor public static void IsAbleTo<TAbility>(this ICanPerform actor) where TAbility : new() Parameters actor ICanPerform The actor from whom to get the ability Type Parameters TAbility The type of the ability to add to the actor Remarks This method is a convenience for manually instantiating the ability instance and adding it to the actor in that manner. For abilities which do not have a public parameterless constructor, consider adding them to the actor via dependency injection. The recommended technique for accomplishing this is by implementing IPersona in a class of your own. Implementations of persona are eligible for dependency injection when the actor is retrieved from the persona type via the ICast: GetActor<TPersona>(ICast). Exceptions ArgumentNullException If any parameter is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor already has an ability of the same type as the TAbility to add, or which derives from the same type PerformAsync(ICanPerform, IGetsPerformable, CancellationToken) Performs an action or task which returns no result from the performable which is exposed by the specified builder object. public static ValueTask PerformAsync(this ICanPerform actor, IGetsPerformable performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerform An actor performableBuilder IGetsPerformable The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete PerformAsync(ICanPerform, IGetsPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result from the performable which is exposed by the specified builder object. public static ValueTask<object> PerformAsync(this ICanPerform actor, IGetsPerformableWithResult performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerform An actor performableBuilder IGetsPerformableWithResult The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete PerformAsync<T>(ICanPerform, IGetsPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result from the performable which is exposed by the specified builder object. public static ValueTask<T> PerformAsync<T>(this ICanPerform actor, IGetsPerformableWithResult<T> performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerform An actor performableBuilder IGetsPerformableWithResult<T> The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type Should(ICanPerformThen, IGetsPerformable, CancellationToken) Performs an action or task which returns no result. public static ValueTask Should(this ICanPerformThen actor, IGetsPerformable performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformThen An actor performableBuilder IGetsPerformable The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete Should(ICanPerformThen, IGetsPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. public static ValueTask<object> Should(this ICanPerformThen actor, IGetsPerformableWithResult performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformThen An actor performableBuilder IGetsPerformableWithResult The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete Should<T>(ICanPerformThen, IGetsPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. public static ValueTask<T> Should<T>(this ICanPerformThen actor, IGetsPerformableWithResult<T> performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformThen An actor performableBuilder IGetsPerformableWithResult<T> The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type WasAbleTo(ICanPerformGiven, IGetsPerformable, CancellationToken) Performs an action or task which returns no result. public static ValueTask WasAbleTo(this ICanPerformGiven actor, IGetsPerformable performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformGiven An actor performableBuilder IGetsPerformable The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete WasAbleTo(ICanPerformGiven, IGetsPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. public static ValueTask<object> WasAbleTo(this ICanPerformGiven actor, IGetsPerformableWithResult performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformGiven An actor performableBuilder IGetsPerformableWithResult The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete WasAbleTo<T>(ICanPerformGiven, IGetsPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. public static ValueTask<T> WasAbleTo<T>(this ICanPerformGiven actor, IGetsPerformableWithResult<T> performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformGiven An actor performableBuilder IGetsPerformableWithResult<T> The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type"
  },
  "api/CSF.Screenplay.Actors.ActorEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.ActorEventArgs.html",
    "title": "Class ActorEventArgs | Screenplay docs",
    "keywords": "Class ActorEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to an Actor. public class ActorEventArgs : PerformanceScopeEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs Implements IHasPerformanceIdentity Derived GainAbilityEventArgs PerformableEventArgs Inherited Members PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ActorEventArgs(Actor) Initializes a new instance of ActorEventArgs public ActorEventArgs(Actor actor) Parameters actor Actor The actor ActorEventArgs(string, Guid) Initializes a new instance of ActorEventArgs public ActorEventArgs(string actorName, Guid performanceIdentity) Parameters actorName string The actor's name performanceIdentity Guid The actor's performance identity Properties ActorName Gets the name of the actor to which these event arguments relate public string ActorName { get; } Property Value string See Also Actor"
  },
  "api/CSF.Screenplay.Actors.Cast.html": {
    "href": "api/CSF.Screenplay.Actors.Cast.html",
    "title": "Class Cast | Screenplay docs",
    "keywords": "Class Cast Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.dll The default implementation of ICast which serves as a registry/factory for Actor instances. public sealed class Cast : ICast, IHasServiceProvider, IHasPerformanceIdentity Inheritance object Cast Implements ICast IHasServiceProvider IHasPerformanceIdentity Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods CastExtensions.GetActor<TPersona>(ICast) Constructors Cast(IServiceProvider, Guid) Initialises a new instance of Cast. public Cast(IServiceProvider serviceProvider, Guid performanceIdentity) Parameters serviceProvider IServiceProvider A service provider performanceIdentity Guid The identity of the current performance Exceptions ArgumentNullException If serviceProvider is null. Properties PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. ServiceProvider Gets a service provider/resolver instance associated with this object. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods GetActor(IPersona) Gets a single Actor based upon a persona, creating them if they do not already exist in the cast. public Actor GetActor(IPersona persona) Parameters persona IPersona The persona from which to get an actor Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, using the persona as a factory, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast, matched using the IPersona's Name. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified persona name differs only in case. Consider using GetActor<TPersona>(ICast) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. See Also IPersona GetActor(string) Gets a single Actor by their name, creating them if they do not already exist in the cast. public Actor GetActor(string name) Parameters name string The name of the actor to get Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified name differs only in case. If you make use of a same-named actor across multiple performances then it is highly recommended to use personas in order to consistently define the actor's attributes and abilities. You would then use the overload of this method which uses that persona to define the actor. See Also IPersona"
  },
  "api/CSF.Screenplay.Actors.GainAbilityEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.GainAbilityEventArgs.html",
    "title": "Class GainAbilityEventArgs | Screenplay docs",
    "keywords": "Class GainAbilityEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to an actor gaining a new ability. public class GainAbilityEventArgs : ActorEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs GainAbilityEventArgs Implements IHasPerformanceIdentity Inherited Members ActorEventArgs.ActorName PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GainAbilityEventArgs(string, Guid, object) Initializes a new instance of GainAbilityEventArgs. public GainAbilityEventArgs(string actorName, Guid performanceIdentity, object ability) Parameters actorName string The actor's name performanceIdentity Guid The actor's performance identity ability object The ability Properties Ability Gets the ability which the actor has gained public object Ability { get; } Property Value object"
  },
  "api/CSF.Screenplay.Actors.ICanPerformGiven.html": {
    "href": "api/CSF.Screenplay.Actors.ICanPerformGiven.html",
    "title": "Interface ICanPerformGiven | Screenplay docs",
    "keywords": "Interface ICanPerformGiven Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll An actor which is able to perform in the Given phase of a IPerformance. public interface ICanPerformGiven Extension Methods ActorExtensions.WasAbleTo(ICanPerformGiven, IGetsPerformable, CancellationToken) ActorExtensions.WasAbleTo(ICanPerformGiven, IGetsPerformableWithResult, CancellationToken) ActorExtensions.WasAbleTo<T>(ICanPerformGiven, IGetsPerformableWithResult<T>, CancellationToken) Remarks This interface is conceptually identical to ICanPerform, except that the nomenclature of its methods is written in the past tense, as is best pratice for the Given phase of a performance. Methods WasAbleTo(IPerformable, CancellationToken) Performs an action or task which returns no result. ValueTask WasAbleTo(IPerformable performable, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete WasAbleTo(IPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. ValueTask<object> WasAbleTo(IPerformableWithResult performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete WasAbleTo<T>(IPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. ValueTask<T> WasAbleTo<T>(IPerformableWithResult<T> performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type See Also ICanPerform"
  },
  "api/CSF.Screenplay.Actors.ICanPerformThen.html": {
    "href": "api/CSF.Screenplay.Actors.ICanPerformThen.html",
    "title": "Interface ICanPerformThen | Screenplay docs",
    "keywords": "Interface ICanPerformThen Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll An actor which is able to perform in the Then phase of a IPerformance. public interface ICanPerformThen Extension Methods ActorExtensions.Should(ICanPerformThen, IGetsPerformable, CancellationToken) ActorExtensions.Should(ICanPerformThen, IGetsPerformableWithResult, CancellationToken) ActorExtensions.Should<T>(ICanPerformThen, IGetsPerformableWithResult<T>, CancellationToken) Remarks This interface is conceptually identical to ICanPerform, except that the nomenclature of its methods is written in the future tense, as is best pratice for the Then phase of a performance. Methods Should(IPerformable, CancellationToken) Performs an action or task which returns no result. ValueTask Should(IPerformable performable, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete Should(IPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. ValueTask<object> Should(IPerformableWithResult performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete Should<T>(IPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. ValueTask<T> Should<T>(IPerformableWithResult<T> performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type See Also ICanPerform"
  },
  "api/CSF.Screenplay.Actors.ICanPerformWhen.html": {
    "href": "api/CSF.Screenplay.Actors.ICanPerformWhen.html",
    "title": "Interface ICanPerformWhen | Screenplay docs",
    "keywords": "Interface ICanPerformWhen Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll An actor which is able to perform in the When phase of a IPerformance. public interface ICanPerformWhen Extension Methods ActorExtensions.AttemptsTo(ICanPerformWhen, IGetsPerformable, CancellationToken) ActorExtensions.AttemptsTo(ICanPerformWhen, IGetsPerformableWithResult, CancellationToken) ActorExtensions.AttemptsTo<T>(ICanPerformWhen, IGetsPerformableWithResult<T>, CancellationToken) Remarks This interface is conceptually identical to ICanPerform, except that the nomenclature of its methods is written in the present tense, as is best pratice for the When phase of a performance. In addition, the wording of these methods indicates that the actor is attempting something, which might fail. Methods AttemptsTo(IPerformable, CancellationToken) Performs an action or task which returns no result. ValueTask AttemptsTo(IPerformable performable, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete AttemptsTo(IPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. ValueTask<object> AttemptsTo(IPerformableWithResult performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete AttemptsTo<T>(IPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. ValueTask<T> AttemptsTo<T>(IPerformableWithResult<T> performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type See Also ICanPerform"
  },
  "api/CSF.Screenplay.Actors.IHasPerformableEvents.html": {
    "href": "api/CSF.Screenplay.Actors.IHasPerformableEvents.html",
    "title": "Interface IHasPerformableEvents | Screenplay docs",
    "keywords": "Interface IHasPerformableEvents Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll An actor which may emit events as they participate in a IPerformance public interface IHasPerformableEvents Events BeginPerformable Occurs when the actor begins the execution of a performable object. event EventHandler<PerformableEventArgs> BeginPerformable Event Type EventHandler<PerformableEventArgs> EndPerformable Occurs when an actor ends the execution of a performable object. event EventHandler<PerformableEventArgs> EndPerformable Event Type EventHandler<PerformableEventArgs> GainedAbility Occurs when an actor gains a new ability. event EventHandler<GainAbilityEventArgs> GainedAbility Event Type EventHandler<GainAbilityEventArgs> PerformableFailed Occurs when a performable object fails with an exception. event EventHandler<PerformableFailureEventArgs> PerformableFailed Event Type EventHandler<PerformableFailureEventArgs> PerformableResult Occurs when an actor receives a result from a perfperformable objectrmance. event EventHandler<PerformableResultEventArgs> PerformableResult Event Type EventHandler<PerformableResultEventArgs>"
  },
  "api/CSF.Screenplay.Actors.PerformableEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.PerformableEventArgs.html",
    "title": "Class PerformableEventArgs | Screenplay docs",
    "keywords": "Class PerformableEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to an actor's use of a performable. public class PerformableEventArgs : ActorEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs PerformableEventArgs Implements IHasPerformanceIdentity Derived PerformableFailureEventArgs PerformableResultEventArgs Inherited Members ActorEventArgs.ActorName PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformableEventArgs(string, Guid, object, PerformancePhase) Initializes a new instance of PerformableEventArgs. public PerformableEventArgs(string actorName, Guid performanceIdentity, object performable, PerformancePhase phase = PerformancePhase.Unspecified) Parameters actorName string The actor's name performanceIdentity Guid The actor's performance identity performable object The performable item phase PerformancePhase The phase of performance Properties Performable Gets the performable item to which these event arguments relate. public object Performable { get; } Property Value object Phase Gets the performance phase to which these event arguments relate. public PerformancePhase Phase { get; } Property Value PerformancePhase"
  },
  "api/CSF.Screenplay.Actors.PerformableFailureEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.PerformableFailureEventArgs.html",
    "title": "Class PerformableFailureEventArgs | Screenplay docs",
    "keywords": "Class PerformableFailureEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A specialisation of PerformableEventArgs which describe the situation where an exception halted the execution of the performable item. public class PerformableFailureEventArgs : PerformableEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs PerformableEventArgs PerformableFailureEventArgs Implements IHasPerformanceIdentity Inherited Members PerformableEventArgs.Performable PerformableEventArgs.Phase ActorEventArgs.ActorName PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformableFailureEventArgs(string, Guid, object, Exception, PerformancePhase) Initializes a new instance of PerformableFailureEventArgs. public PerformableFailureEventArgs(string actorName, Guid performanceIdentity, object performable, Exception exception, PerformancePhase phase = PerformancePhase.Unspecified) Parameters actorName string The actor's name performanceIdentity Guid The actor's performance identity performable object The performable item which raised the exception exception Exception The exception which occurred phase PerformancePhase The phase of performance which was underway when the exception occurred Properties Exception Gets the exception which halted the performable item. public Exception Exception { get; } Property Value Exception"
  },
  "api/CSF.Screenplay.Actors.PerformableResultEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.PerformableResultEventArgs.html",
    "title": "Class PerformableResultEventArgs | Screenplay docs",
    "keywords": "Class PerformableResultEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A specialisation of PerformableEventArgs which describe a scenario in which the performable completed and has returned a result value. public class PerformableResultEventArgs : PerformableEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs PerformableEventArgs PerformableResultEventArgs Implements IHasPerformanceIdentity Inherited Members PerformableEventArgs.Performable PerformableEventArgs.Phase ActorEventArgs.ActorName PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformableResultEventArgs(string, Guid, object, object, PerformancePhase) Initializes a new instance of PerformableResultEventArgs. public PerformableResultEventArgs(string actorName, Guid performanceIdentity, object performable, object result, PerformancePhase phase = PerformancePhase.Unspecified) Parameters actorName string The actor's name performanceIdentity Guid The actor's performance identity performable object The performable item result object The result from the performable phase PerformancePhase The phase of performance Properties Result Gets the result value which was returned by the performable public object Result { get; } Property Value object"
  },
  "api/CSF.Screenplay.Actors.PerformancePhase.html": {
    "href": "api/CSF.Screenplay.Actors.PerformancePhase.html",
    "title": "Enum PerformancePhase | Screenplay docs",
    "keywords": "Enum PerformancePhase Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll Enumerates the phases of a performance public enum PerformancePhase Fields Given = 1 The 'Given' phase of a performance is for set-up and fulfilling preconditions Then = 3 The 'Then' phase of a performance is where the results of the When phase are as expected; is it a pass or a fail? Unspecified = 0 Indicates that no phase has been specified When = 2 The 'When' phase of a performance describes the activity which is under test Remarks It is common for a IPerformance to occur in phases. This is especially true when Screenplay is being used as a testing tool. This type enumerates the possible phases. If phases are irrelevant to your usage of Screenplay then feel free to use Unspecified, which is the default phase when no phase has been specified."
  },
  "api/CSF.Screenplay.Actors.Stage.html": {
    "href": "api/CSF.Screenplay.Actors.Stage.html",
    "title": "Class Stage | Screenplay docs",
    "keywords": "Class Stage Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.dll The default implementation of IStage which provides a context for which actor is currently active. public sealed class Stage : IStage, IHasPerformanceIdentity Inheritance object Stage Implements IStage IHasPerformanceIdentity Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods StageExtensions.Spotlight<TPersona>(IStage) Constructors Stage(ICast, IRelaysPerformanceEvents) Initialises a new instance of Stage public Stage(ICast cast, IRelaysPerformanceEvents performanceEventBus) Parameters cast ICast The cast performanceEventBus IRelaysPerformanceEvents An event bus for collecting stage-related events Exceptions ArgumentNullException If any parameter value is null Properties Cast Gets the cast to which the current stage is linked. public ICast Cast { get; } Property Value ICast PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. Methods GetSpotlitActor() Gets the actor which is currently in the spotlight. public Actor GetSpotlitActor() Returns Actor The actor who has previously been placed in the spotlight, or a null reference if there is presently no actor in the spotlight. Spotlight(Actor) Places the specified actor into the spotlight, making them 'the current actor' on this stage. public void Spotlight(Actor actor) Parameters actor Actor Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the specified actor. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If the specified actor is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Exceptions ArgumentNullException If the actor is null. Spotlight(IPersona) Places an actor matching the specified persona into the spotlight, making them 'the current actor' on this stage. public Actor Spotlight(IPersona persona) Parameters persona IPersona Returns Actor The actor instance which was placed into the spotlight. Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the actor derived from the persona. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If actor indicated by the persona is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. When spotlighting a persona, the actor instance is retrieved from an ICast based upon that same persona. See GetActor(IPersona) for more information. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Consider using Spotlight<TPersona>(IStage) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. Exceptions ArgumentNullException If the actor is null. TurnSpotlightOff() Removes any existing actor from the spotlight, ensuring that no actor is in the spotlight. public Actor TurnSpotlightOff() Returns Actor If an actor was previously in the spotlight, and has now been removed, then this method returns that actor; otherwise it will return a null reference. Remarks If there was already no actor in the spotlight when this method is executed then it will have no effect, the spotlight will remain empty and this method will return null."
  },
  "api/CSF.Screenplay.Actors.html": {
    "href": "api/CSF.Screenplay.Actors.html",
    "title": "Namespace CSF.Screenplay.Actors | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.Actors Classes ActorEventArgs A model for event arguments which relate to an Actor. Cast The default implementation of ICast which serves as a registry/factory for Actor instances. GainAbilityEventArgs A model for event arguments which relate to an actor gaining a new ability. PerformableEventArgs A model for event arguments which relate to an actor's use of a performable. PerformableFailureEventArgs A specialisation of PerformableEventArgs which describe the situation where an exception halted the execution of the performable item. PerformableResultEventArgs A specialisation of PerformableEventArgs which describe a scenario in which the performable completed and has returned a result value. Stage The default implementation of IStage which provides a context for which actor is currently active. Interfaces ICanPerformGiven An actor which is able to perform in the Given phase of a IPerformance. ICanPerformThen An actor which is able to perform in the Then phase of a IPerformance. ICanPerformWhen An actor which is able to perform in the When phase of a IPerformance. IHasPerformableEvents An actor which may emit events as they participate in a IPerformance Enums PerformancePhase Enumerates the phases of a performance"
  },
  "api/CSF.Screenplay.CastExtensions.html": {
    "href": "api/CSF.Screenplay.CastExtensions.html",
    "title": "Class CastExtensions | Screenplay docs",
    "keywords": "Class CastExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Extension methods for ICast. public static class CastExtensions Inheritance object CastExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetActor<TPersona>(ICast) Gets a single Actor based upon a persona, creating them if they do not already exist in the cast. public static Actor GetActor<TPersona>(this ICast cast) where TPersona : class, IPersona Parameters cast ICast The cast from which to get an actor Returns Actor An actor based on the specified persona, either an existing instance or a newly-created actor. Type Parameters TPersona A concrete type of IPersona from which to get an actor. Remarks This method will create the actor within the current cast, using a resolved instance of the persona as a factory, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast, matched using the IPersona's Name. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified persona name differs only in case. This method is the recommended way of getting an actor from a persona, as it takes care of resolving the persona from dependency injection automatically. See Also IPersona"
  },
  "api/CSF.Screenplay.DefaultStrings.html": {
    "href": "api/CSF.Screenplay.DefaultStrings.html",
    "title": "Class DefaultStrings | Screenplay docs",
    "keywords": "Class DefaultStrings Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which provides default human readable strings public static class DefaultStrings Inheritance object DefaultStrings Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This is most commonly used when dealing with performables which do not implement ICanReport. Methods FormatValue(object) Formats a value public static string FormatValue(object value) Parameters value object The value to format Returns string The formatted value Remarks If the value implements IHasName then its Name will be returned, otherwise the result of ToString() will be returned, or an empty string if the value is null. If, by any chance, there is an exception raised whilst formatting the value then a string will be returned which indicates this and contains the exception details. GetAbilityReport(object, object) Gets a fallback report fragment for an ability which does not implement ICanReport. public static string GetAbilityReport(object actor, object ability) Parameters actor object The actor on whom to report ability object The ability object Returns string The report fragment Remarks This mechanism of getting a report fragment uses a simple fallback string which is similar to: {Actor} is able to {Ability}. The actor and ability objects will be formatted by FormatValue(object). GetReport(object, object) Gets a fallback report fragment for a performable which does not implement ICanReport. public static string GetReport(object actor, object performable) Parameters actor object The actor on whom to report performable object The performable object Returns string The report fragment Remarks This mechanism of getting a report fragment uses a simple fallback string which is similar to: {Actor} performs {Performable}. The actor and performable objects will be formatted by FormatValue(object)."
  },
  "api/CSF.Screenplay.ICanPerform.html": {
    "href": "api/CSF.Screenplay.ICanPerform.html",
    "title": "Interface ICanPerform | Screenplay docs",
    "keywords": "Interface ICanPerform Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An actor which may perform in the Screenplay. public interface ICanPerform Extension Methods ActorExtensions.GetAbility(ICanPerform, Type) ActorExtensions.GetAbility<T>(ICanPerform) ActorExtensions.HasAbility(ICanPerform, Type) ActorExtensions.HasAbility<T>(ICanPerform) ActorExtensions.IsAbleTo(ICanPerform, object) ActorExtensions.IsAbleTo<TAbility>(ICanPerform) ActorExtensions.PerformAsync(ICanPerform, IGetsPerformable, CancellationToken) ActorExtensions.PerformAsync(ICanPerform, IGetsPerformableWithResult, CancellationToken) ActorExtensions.PerformAsync<T>(ICanPerform, IGetsPerformableWithResult<T>, CancellationToken) Methods PerformAsync(IPerformable, CancellationToken) Performs an action or task which returns no result. ValueTask PerformAsync(IPerformable performable, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete PerformAsync(IPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. ValueTask<object> PerformAsync(IPerformableWithResult performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete PerformAsync<T>(IPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. ValueTask<T> PerformAsync<T>(IPerformableWithResult<T> performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type See Also IPerformable IPerformableWithResult IPerformableWithResult<TResult> IHasAbilities"
  },
  "api/CSF.Screenplay.ICanReport.html": {
    "href": "api/CSF.Screenplay.ICanReport.html",
    "title": "Interface ICanReport | Screenplay docs",
    "keywords": "Interface ICanReport Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A type which can provide a human-readable report fragment when it is used in a IPerformance. public interface ICanReport Remarks It is recommended for all types for Actions, Questions, Tasks (broadly \"Performables\") as well as Abilities to implement this interface. Implementing this interface permits the type to emit a human-readable value for when the type is used in a Performance. For Performables implementing this interface, the report fragment indicates that the performable has been executed in the Performance. For abilities which implement this interface, the report fragment is used when an Actor gains/is granted the ability. Methods GetReportFragment(IHasName) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. string GetReportFragment(IHasName actor) Parameters actor IHasName An actor for whom to write the report fragment Returns string A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. See Also IPerformable IPerformableWithResult IPerformableWithResult<TResult>"
  },
  "api/CSF.Screenplay.ICast.html": {
    "href": "api/CSF.Screenplay.ICast.html",
    "title": "Interface ICast | Screenplay docs",
    "keywords": "Interface ICast Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A combined registry and factory for Actor instances, useful when coordinating multiple actors across a IPerformance public interface ICast : IHasServiceProvider, IHasPerformanceIdentity Inherited Members IHasServiceProvider.ServiceProvider IHasPerformanceIdentity.PerformanceIdentity Extension Methods CastExtensions.GetActor<TPersona>(ICast) Remarks The cast is a strongly recommended component of Screenplay logic. It is used to manage Actor objects for the duration of a IPerformance. Cast objects are always scoped to a IPerformance and have the same lifetime. Any actors created or tracked by a cast will also automatically share this lifetime. In terms of design patterns, the cast operates as both a registry: https://martinfowler.com/eaaCatalog/registry.html and as a factory: https://en.wikipedia.org/wiki/Factory_method_pattern for actors. During the cast's lifetime, subsequent calls to an overload of GetActor using the same actor/persona name will return the instance of Actor as was created the first time the method was called with that name. A cast, and the actors managed by a cast, are independent per IPerformance, though. Developers are strongly advised to configure their actors via classes which derive from IPersona. This allows for sharing of common actor-setup logic such as abilities. In a Screenplay the cast is a dependency-injectable service which may be used within your performances. Methods GetActor(IPersona) Gets a single Actor based upon a persona, creating them if they do not already exist in the cast. Actor GetActor(IPersona persona) Parameters persona IPersona The persona from which to get an actor Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, using the persona as a factory, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast, matched using the IPersona's Name. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified persona name differs only in case. Consider using GetActor<TPersona>(ICast) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. See Also IPersona GetActor(string) Gets a single Actor by their name, creating them if they do not already exist in the cast. Actor GetActor(string name) Parameters name string The name of the actor to get Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified name differs only in case. If you make use of a same-named actor across multiple performances then it is highly recommended to use personas in order to consistently define the actor's attributes and abilities. You would then use the overload of this method which uses that persona to define the actor. See Also IPersona See Also IStage Actor IPerformance IPersona"
  },
  "api/CSF.Screenplay.IGetsScreenplay.html": {
    "href": "api/CSF.Screenplay.IGetsScreenplay.html",
    "title": "Interface IGetsScreenplay | Screenplay docs",
    "keywords": "Interface IGetsScreenplay Namespace CSF.Screenplay Assembly CSF.Screenplay.dll An object which can fully configure and get a Screenplay instance. public interface IGetsScreenplay Examples The smallest example of a valid implementation of this class, which just gets a default Screenplay with no customizations is: public class ScreenplayFactory : IGetsScreenplay { public Screenplay GetScreenplay() => Screenplay.Create(); } Feel free to customize this example to add a parameter to the Create method, which adds other services to the DI service collection which will be used with the Screenplay. Such services could be those Remarks This interface is particularly important when using Screenplay as a testing tool. Some test integrations do not have any inherent extension points for the placement of 'configuration' or startup logic which affects the entire test run. In those cases, a developer will need to implement this interface with a class of their own, in order to configure and get the Screenplay instance. Types which implement this interface need only implement the GetScreenplay() method, which should build and return a Screenplay instance. Developers are advised to use Create(Action<IServiceCollection>) to create and return the Screenplay. Note that implementations of this type must have a public parameterless constructor, because they will be instantiated via CreateInstance(Type) and not resolved from dependency injection. Methods GetScreenplay() Gets the configured Screenplay instance provided by the current type. Screenplay GetScreenplay() Returns Screenplay A Screenplay instance Remarks Implementors should create and return a new Screenplay instance from this method; they are strongly urged to consider the use of Create(Action<IServiceCollection>) for this purpose. As well as the creation of the Screenplay instance itself, they should also add to the service collection any services which relate to abilities which could be used in the Screenplay. It is recommended to use the parameter to the Create method (above) to configure such services into the DI container."
  },
  "api/CSF.Screenplay.IHasAbilities.html": {
    "href": "api/CSF.Screenplay.IHasAbilities.html",
    "title": "Interface IHasAbilities | Screenplay docs",
    "keywords": "Interface IHasAbilities Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which has & is able to gain abilities. public interface IHasAbilities Extension Methods ActorExtensions.HasAbility(IHasAbilities, Type) ActorExtensions.HasAbility<T>(IHasAbilities) Remarks Abilities are the mechanism by which actors: ICanPerform interact with the application and system. They are arbitrary objects which provide functionality. Properties Abilities Gets the collection of the actor's abilities. IReadOnlyCollection<object> Abilities { get; } Property Value IReadOnlyCollection<object> Methods IsAbleTo(object) Adds an ability to the specified actor void IsAbleTo(object ability) Parameters ability object The ability to add to the actor Exceptions ArgumentNullException If ability is null InvalidOperationException If the actor already has an ability of the same type as ability, or which derives from the same type"
  },
  "api/CSF.Screenplay.IHasName.html": {
    "href": "api/CSF.Screenplay.IHasName.html",
    "title": "Interface IHasName | Screenplay docs",
    "keywords": "Interface IHasName Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A part of a Screenplay performance which has a human-readable name. public interface IHasName Remarks Use this interface for any object within an IPerformance which could benefit from having a human-readable name. For example, static parameter values like Web API endpoints, web page URLs, elements on a web UI, dates/times in a calendar. By referring to an object by its name, and using that name in report-generating logic, reports generated from a Screenplay can become much easier to read and comprehend. Properties Name Gets the human-readable name of the current object. string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement this interface should return a non-null response from this property."
  },
  "api/CSF.Screenplay.IHasPerformanceIdentity.html": {
    "href": "api/CSF.Screenplay.IHasPerformanceIdentity.html",
    "title": "Interface IHasPerformanceIdentity | Screenplay docs",
    "keywords": "Interface IHasPerformanceIdentity Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which provides a value which uniquely identifies the currently-executing IPerformance. public interface IHasPerformanceIdentity Properties PerformanceIdentity Gets the unique IPerformance identifier Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay."
  },
  "api/CSF.Screenplay.IHasServiceProvider.html": {
    "href": "api/CSF.Screenplay.IHasServiceProvider.html",
    "title": "Interface IHasServiceProvider | Screenplay docs",
    "keywords": "Interface IHasServiceProvider Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which has an associated IServiceProvider, which resolves services from dependency injection. public interface IHasServiceProvider Properties ServiceProvider Gets a service provider/resolver instance associated with this object. IServiceProvider ServiceProvider { get; } Property Value IServiceProvider"
  },
  "api/CSF.Screenplay.IPerformable.html": {
    "href": "api/CSF.Screenplay.IPerformable.html",
    "title": "Interface IPerformable | Screenplay docs",
    "keywords": "Interface IPerformable Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which represents something that a performer (typically an actor) may perform. public interface IPerformable Extension Methods PerformableExtensions.GetReportFragment(IPerformable, IHasName) Remarks Performable objects generally fall into one of three categories in Screenplay: An action, which is the most fine-grained type of performable, typically \"doing something which alters the state of the application\" A question, which is fine-grained like an action but instead reads state without changing it A task, which may be composed of actions, questions or even other tasks Objects which implement only this interface are the simplest types of performables; they simply 'do something' and then finish. In the list given above these are typically actions. They do not return any form of result except completion. If you wish to get a result from the performable then consider implementing an interface derived from this one, such as IPerformableWithResult or its strongly-typed counterpart IPerformableWithResult<TResult>. When implementing this interface, consider also implementing ICanReport. If a performable does not implement ICanReport then it will receive default text when the IPerformance report is generated. Implementing ICanReport allows a performable to provide a customised human-readable report fragment. Methods PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also IPerformableWithResult IPerformableWithResult<TResult>"
  },
  "api/CSF.Screenplay.IPerformableWithResult-1.html": {
    "href": "api/CSF.Screenplay.IPerformableWithResult-1.html",
    "title": "Interface IPerformableWithResult<TResult> | Screenplay docs",
    "keywords": "Interface IPerformableWithResult<TResult> Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which represents something that a performer (typically an actor) may perform and which returns a strongly-typed result when it completes. public interface IPerformableWithResult<TResult> Type Parameters TResult Extension Methods PerformableExtensions.GetReportFragment<T>(IPerformableWithResult<T>, IHasName) Remarks Performable objects generally fall into one of three categories in Screenplay: An action, which is the most fine-grained type of performable, typically \"doing something which alters the state of the application\" A question, which is fine-grained like an action but instead reads state without changing it A task, which may be composed of actions, questions or even other tasks Objects which implement this interface are questions or tasks which are composed (at least in-part) from one or more questions. If you do not wish to get a result from the performable then implement only IPerformable instead. When implementing this interface, consider also implementing ICanReport. If a performable does not implement ICanReport then it will receive default text when the IPerformance report is generated. Implementing ICanReport allows a performable to provide a customised human-readable report fragment. Methods PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. ValueTask<TResult> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TResult> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete. See Also IPerformable IPerformableWithResult"
  },
  "api/CSF.Screenplay.IPerformableWithResult.html": {
    "href": "api/CSF.Screenplay.IPerformableWithResult.html",
    "title": "Interface IPerformableWithResult | Screenplay docs",
    "keywords": "Interface IPerformableWithResult Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which represents something that a performer (typically an actor) may perform and which returns a result when it completes. public interface IPerformableWithResult Extension Methods PerformableExtensions.GetReportFragment(IPerformableWithResult, IHasName) Remarks Performable objects generally fall into one of three categories in Screenplay: An action, which is the most fine-grained type of performable, typically \"doing something which alters the state of the application\" A question, which is fine-grained like an action but instead reads state without changing it A task, which may be composed of actions, questions or even other tasks Objects which implement this interface are questions or tasks which are composed (at least in-part) from one or more questions. If you do not wish to get a result from the performable then implement only IPerformable instead. Alternatively, if you wish to return a strongly-typed result then instead consider implementing IPerformableWithResult<TResult>. When implementing this interface, consider also implementing ICanReport. If a performable does not implement ICanReport then it will receive default text when the IPerformance report is generated. Implementing ICanReport allows a performable to provide a customised human-readable report fragment. Methods PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a value. ValueTask<object> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<object> A task which exposes a 'result' value when the performable represented by the current instance is complete. See Also IPerformable IPerformableWithResult<TResult>"
  },
  "api/CSF.Screenplay.IPerformance.html": {
    "href": "api/CSF.Screenplay.IPerformance.html",
    "title": "Interface IPerformance | Screenplay docs",
    "keywords": "Interface IPerformance Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A performance represents a self-contained scope of performables which typically results in overall success or failure. public interface IPerformance : IHasPerformanceIdentity, IHasServiceProvider, IDisposable, IBeginsAndEndsPerformance Inherited Members IHasPerformanceIdentity.PerformanceIdentity IHasServiceProvider.ServiceProvider IDisposable.Dispose() IBeginsAndEndsPerformance.BeginPerformance() IBeginsAndEndsPerformance.FinishPerformance(bool?) Remarks In .NET code which uses Screenplay, a performance is .NET logic involving one or more Actor instances, executing one or more performable items. A Screenplay will be comprised of one or more performances. In practice this means that a performance is a method which would match the delegate Func<IServiceProvider, CancellationToken, Task<bool?>>, such as the following. public Task<bool?> SamplePerformance(IServiceProvider services, CancellationToken cancellationToken) { // Performance logic goes here ... } The performance method is comprised of a series of of performables, performed by one or more actors. Particularly when using Screenplay for automated testing, these performables are organised into a beginning, middle and end, corresponding with the phases declared in PerformancePhase. A performance should complete in either success or failure, as indicated by a true or false return value. Where Screenplay is being used for automated testing, a performance corresponds to a single test. In the testing framework that might be called a \"scenario\", a \"test\", a \"test case\", or a \"theory\". When using Screenplay within a testing integration, the performance corresponds very closely to the current Scenario. This interface is the representation of the scope of such a performance method in the Screenplay architecture. One instance of an object implementing this interface - \"the performance object\" - corresponds to one execution of such a method. The performance object also corresponds to the lifetime of the dependency injection scope; a new scope is created for each performance. Within a DI scope, the performance object is an injectable service. You may wish to read a diagram showing how screenplays, performances, actors and performables relate to one another. Properties NamingHierarchy Gets an ordered list of identifiers which indicate the current performance's name within an organisational hierarchy. List<IdentifierAndName> NamingHierarchy { get; } Property Value List<IdentifierAndName> Examples If the current performance is to be named Joe can take out the Trash, and it is part of a parent name, named Joe can do his chores then the first identifier in the list will be named Joe can do his chores and the second will be named Joe can take out the Trash. Remarks A Screenplay typically contains more than one performance and may contain many. It is normal to organise performances into a hierarchical structure based upon their purpose, role or relationship. The position of the current performance in that naming structure is represented by the value of this property. The ordered list of IdentifierAndName instances indicate a path from the 'root' of the hierarchy (which has no inherent name) to the current performance. Identifier/name pairs which are earlier in the collection are considered to be closer to the root, whereas latter identifier/names are branch & leaf names. In this manner, they work very similarly to .NET namespaces. The earlier in the list that a name appears, the more general it should be, representing a wider category. When using Screenplay with Integration, this hierarchy of names would typically correspond to the naming convention used by the testing framework. That might be based upon .NET namespaces, classes and test methods for a more traditional unit testing framework. Alternatively, for a BDD-style testing framework, it could be named based upon human-readable feature & scenario names. Ideally this property would be immutable after a Performance is created. Unfortunately, some testing frameworks do not expose relevant naming information about a test until after the point of execution where the Performance must be created. Thus, this property is mutable, so that it is possible to 'backfill' missing naming information after the performance has been created. Wherever possible, it is recommended to avoid updating this list of identifier/names and to only set them up when creating the performance, via ICreatesPerformance. PerformanceState Gets a value which indicates the state of the current performance. PerformanceState PerformanceState { get; } Property Value PerformanceState See Also PerformanceState"
  },
  "api/CSF.Screenplay.IPersona.html": {
    "href": "api/CSF.Screenplay.IPersona.html",
    "title": "Interface IPersona | Screenplay docs",
    "keywords": "Interface IPersona Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A persona is a factory for a commonly-used actor public interface IPersona : IHasName Inherited Members IHasName.Name Remarks In Screenplay is is recommended to use memorable actors which are widely understood and recognisable by the team. This is easier if the composition of an actor is the same across every IPerformance in which they participate. By using a separate persona implementation for each named actor, the developer can ensure consistent creation for instances of those actors. Methods GetActor(Guid) Gets the actor which is associated with the current persona Actor GetActor(Guid performanceIdentity) Parameters performanceIdentity Guid A unique identity for the currently-executing performance Returns Actor Remarks Implementors should not only create and return the actor from this method, but also configure the actor with the standard abilities associated with this persona."
  },
  "api/CSF.Screenplay.IStage.html": {
    "href": "api/CSF.Screenplay.IStage.html",
    "title": "Interface IStage | Screenplay docs",
    "keywords": "Interface IStage Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll The stage facilitates a contextual Actor who is 'in the spotlight' - a currently-active actor public interface IStage Extension Methods StageExtensions.Spotlight<TPersona>(IStage) Examples Consider a IPerformance which is based upon the following, which is described in Gherkin BDD syntax: https://cucumber.io/docs/gherkin/. Given Jack can wash dishes And Jack has filled a basin with hot water When Jack washes a dinner plate Then Jack should have one clean dinner plate This format of test is perfectly functional, but each performable item needed to be qualified with the actor's name: \"Jack\". This could be more human-readable but also more reusable from a code perspective if we had a context of a 'current' actor, who we could refer to with a pronoun. With such a concept, our gherkin could read \"he has\" or \"he washes\" and could accept any one of a variety of pronouns. Remarks The Stage is an optional but recommended component of Screenplay, useful when a IPerformance involves repeated use of an Actor. It facilitates the use of passive voice and the use of pronouns within the logic of performances without needing to frequently repeat the Name of the actor. It is often more consise and easier to understand performances when some of the steps use the passive voice. In order to do this, there must be a concept which allows us to discern \"which actor is acting at the moment\". The stage provides this via the concept of a Spotlight. Either zero or one actor may be in the spotlight at any given time. If a new actor is placed in the spotlight then the previous actor is removed from it. Spotlighting an actor facilitates performance steps which use 'the current actor' instead of a specific named actor. The lifetime of a stage instance is equal to the lifetime of the current IPerformance. An actor in the spotlight will be consistent across the lifetime of the performance but will be independent of other performances. In a Screenplay the stage is a dependency-injectable service which may be used within your performances. The stage implicitly consumes some functionality from the ICast. If Spotlight(IPersona) is used, then the Actor to put in the spotlight will implicitly be retrieved using the cast, via GetActor(IPersona). Properties Cast Gets the cast to which the current stage is linked. ICast Cast { get; } Property Value ICast Methods GetSpotlitActor() Gets the actor which is currently in the spotlight. Actor GetSpotlitActor() Returns Actor The actor who has previously been placed in the spotlight, or a null reference if there is presently no actor in the spotlight. Spotlight(Actor) Places the specified actor into the spotlight, making them 'the current actor' on this stage. void Spotlight(Actor actor) Parameters actor Actor Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the specified actor. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If the specified actor is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Exceptions ArgumentNullException If the actor is null. Spotlight(IPersona) Places an actor matching the specified persona into the spotlight, making them 'the current actor' on this stage. Actor Spotlight(IPersona persona) Parameters persona IPersona Returns Actor The actor instance which was placed into the spotlight. Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the actor derived from the persona. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If actor indicated by the persona is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. When spotlighting a persona, the actor instance is retrieved from an ICast based upon that same persona. See GetActor(IPersona) for more information. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Consider using Spotlight<TPersona>(IStage) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. Exceptions ArgumentNullException If the actor is null. TurnSpotlightOff() Removes any existing actor from the spotlight, ensuring that no actor is in the spotlight. Actor TurnSpotlightOff() Returns Actor If an actor was previously in the spotlight, and has now been removed, then this method returns that actor; otherwise it will return a null reference. Remarks If there was already no actor in the spotlight when this method is executed then it will have no effect, the spotlight will remain empty and this method will return null. See Also ICast"
  },
  "api/CSF.Screenplay.PerformableExtensions.html": {
    "href": "api/CSF.Screenplay.PerformableExtensions.html",
    "title": "Class PerformableExtensions | Screenplay docs",
    "keywords": "Class PerformableExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Extension methods for performable types public static class PerformableExtensions Inheritance object PerformableExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetReportFragment(IPerformable, IHasName) Gets a report fragment for the specified performable and actor public static string GetReportFragment(this IPerformable performable, IHasName actor) Parameters performable IPerformable The performable item actor IHasName The actor Returns string Remarks If the performable item does not implement ICanReport then a default fallback report will be produced and returned. Exceptions ArgumentNullException If performable is null GetReportFragment(IPerformableWithResult, IHasName) Gets a report fragment for the specified performable and actor public static string GetReportFragment(this IPerformableWithResult performable, IHasName actor) Parameters performable IPerformableWithResult The performable item actor IHasName The actor Returns string Remarks If the performable item does not implement ICanReport then a default fallback report will be produced and returned. Exceptions ArgumentNullException If performable is null GetReportFragment<T>(IPerformableWithResult<T>, IHasName) Gets a report fragment for the specified performable and actor public static string GetReportFragment<T>(this IPerformableWithResult<T> performable, IHasName actor) Parameters performable IPerformableWithResult<T> The performable item actor IHasName The actor Returns string Type Parameters T The result type returned by the performable Remarks If the performable item does not implement ICanReport then a default fallback report will be produced and returned. Exceptions ArgumentNullException If performable is null"
  },
  "api/CSF.Screenplay.Performables.IGetsPerformable.html": {
    "href": "api/CSF.Screenplay.Performables.IGetsPerformable.html",
    "title": "Interface IGetsPerformable | Screenplay docs",
    "keywords": "Interface IGetsPerformable Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An object which can get an IPerformable instance, such as a performable builder. public interface IGetsPerformable Methods GetPerformable() Gets the performable object from the current instance. IPerformable GetPerformable() Returns IPerformable A performable object"
  },
  "api/CSF.Screenplay.Performables.IGetsPerformableWithResult-1.html": {
    "href": "api/CSF.Screenplay.Performables.IGetsPerformableWithResult-1.html",
    "title": "Interface IGetsPerformableWithResult<TResult> | Screenplay docs",
    "keywords": "Interface IGetsPerformableWithResult<TResult> Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An object which can get an IPerformableWithResult<TResult> instance, such as a performable builder. public interface IGetsPerformableWithResult<TResult> Type Parameters TResult Methods GetPerformable() Gets the performable object from the current instance. IPerformableWithResult<TResult> GetPerformable() Returns IPerformableWithResult<TResult> A performable object"
  },
  "api/CSF.Screenplay.Performables.IGetsPerformableWithResult.html": {
    "href": "api/CSF.Screenplay.Performables.IGetsPerformableWithResult.html",
    "title": "Interface IGetsPerformableWithResult | Screenplay docs",
    "keywords": "Interface IGetsPerformableWithResult Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An object which can get a non-generic IPerformableWithResult instance, such as a performable builder. public interface IGetsPerformableWithResult Methods GetPerformable() Gets the performable object from the current instance. IPerformableWithResult GetPerformable() Returns IPerformableWithResult A performable object"
  },
  "api/CSF.Screenplay.Performables.IProvidesTimeSpan.html": {
    "href": "api/CSF.Screenplay.Performables.IProvidesTimeSpan.html",
    "title": "Interface IProvidesTimeSpan | Screenplay docs",
    "keywords": "Interface IProvidesTimeSpan Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll A type which may provide a TimeSpan. public interface IProvidesTimeSpan Remarks Many performables make use of time; this interface provides a common abstraction for objects that provide time spans. Methods GetTimeSpan() Gets the TimeSpan which is exposed by the current instance. TimeSpan GetTimeSpan() Returns TimeSpan The time span See Also TimeSpanBuilder<TOtherBuilder> TimeSpanBuilder"
  },
  "api/CSF.Screenplay.Performables.PerformableException.html": {
    "href": "api/CSF.Screenplay.Performables.PerformableException.html",
    "title": "Class PerformableException | Screenplay docs",
    "keywords": "Class PerformableException Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll Thrown when a Performable fails with an unexpected exception. public class PerformableException : Exception, ISerializable Inheritance object Exception PerformableException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Remarks This exception type is rethrown from the Actor when they are executing the performable, in order to provide further context about where the error has occurred. Constructors PerformableException() Initialises a new instance of PerformableException. public PerformableException() PerformableException(string) Initialises a new instance of PerformableException. public PerformableException(string message) Parameters message string The exception message PerformableException(string, Exception) Initialises a new instance of PerformableException. public PerformableException(string message, Exception inner) Parameters message string The exception message inner Exception The inner exception Properties Performable Gets or sets a reference to the Performable object which was the cause of the exception. public object Performable { get; set; } Property Value object"
  },
  "api/CSF.Screenplay.Performables.ReadTheStopwatch.html": {
    "href": "api/CSF.Screenplay.Performables.ReadTheStopwatch.html",
    "title": "Class ReadTheStopwatch | Screenplay docs",
    "keywords": "Class ReadTheStopwatch Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An action which reads the current value of the stopwatch. public class ReadTheStopwatch : IPerformableWithResult<TimeSpan>, ICanReport Inheritance object ReadTheStopwatch Implements IPerformableWithResult<TimeSpan> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods PerformableExtensions.GetReportFragment<T>(IPerformableWithResult<T>, IHasName) Remarks This performable requires the actor has the ability UseAStopwatch. Use this performable via the builder method ReadTheStopwatch(). Methods GetReportFragment(IHasName) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public string GetReportFragment(IHasName actor) Parameters actor IHasName An actor for whom to write the report fragment Returns string A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<TimeSpan> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TimeSpan> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Performables.ResetTheStopwatch.html": {
    "href": "api/CSF.Screenplay.Performables.ResetTheStopwatch.html",
    "title": "Class ResetTheStopwatch | Screenplay docs",
    "keywords": "Class ResetTheStopwatch Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An action which resets the stopwatch. public class ResetTheStopwatch : IPerformable, ICanReport Inheritance object ResetTheStopwatch Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods PerformableExtensions.GetReportFragment(IPerformable, IHasName) Remarks This performable requires the actor has the ability UseAStopwatch. Use this performable via the builder method ResetTheStopwatch(). Methods GetReportFragment(IHasName) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public string GetReportFragment(IHasName actor) Parameters actor IHasName An actor for whom to write the report fragment Returns string A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Performables.StartTheStopwatch.html": {
    "href": "api/CSF.Screenplay.Performables.StartTheStopwatch.html",
    "title": "Class StartTheStopwatch | Screenplay docs",
    "keywords": "Class StartTheStopwatch Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An action which starts the stopwatch. public class StartTheStopwatch : IPerformable, ICanReport Inheritance object StartTheStopwatch Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods PerformableExtensions.GetReportFragment(IPerformable, IHasName) Remarks This performable requires the actor has the ability UseAStopwatch. Use this performable via the builder method StartTheStopwatch(). Methods GetReportFragment(IHasName) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public string GetReportFragment(IHasName actor) Parameters actor IHasName An actor for whom to write the report fragment Returns string A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Performables.StopTheStopwatch.html": {
    "href": "api/CSF.Screenplay.Performables.StopTheStopwatch.html",
    "title": "Class StopTheStopwatch | Screenplay docs",
    "keywords": "Class StopTheStopwatch Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An action which stops the stopwatch. public class StopTheStopwatch : IPerformable, ICanReport Inheritance object StopTheStopwatch Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods PerformableExtensions.GetReportFragment(IPerformable, IHasName) Remarks This performable requires the actor has the ability UseAStopwatch. Use this performable via the builder method StopTheStopwatch(). Methods GetReportFragment(IHasName) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public string GetReportFragment(IHasName actor) Parameters actor IHasName An actor for whom to write the report fragment Returns string A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Performables.StopwatchBuilder.html": {
    "href": "api/CSF.Screenplay.Performables.StopwatchBuilder.html",
    "title": "Class StopwatchBuilder | Screenplay docs",
    "keywords": "Class StopwatchBuilder Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll A builder for actions relating to the UseAStopwatch ability. public static class StopwatchBuilder Inheritance object StopwatchBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks When using this class it is recommended to include using static CSF.Screenplay.Performables.StopwatchBuilder; in the source file which uses it. This will allow you use the method names in this class in a more human-readable fashion. The actions and the question exposed by this builder allow an actor to accurately track and measure time elapsed during a Performance. Methods ReadTheStopwatch() Gets a performable which reads the stopwatch. public static ReadTheStopwatch ReadTheStopwatch() Returns ReadTheStopwatch Remarks Use of this performable requires the actor has the UseAStopwatch ability. ResetTheStopwatch() Gets a performable which resets the stopwatch to zero. public static ResetTheStopwatch ResetTheStopwatch() Returns ResetTheStopwatch Remarks Use of this performable requires the actor has the UseAStopwatch ability. StartTheStopwatch() Gets a performable which starts the stopwatch. public static StartTheStopwatch StartTheStopwatch() Returns StartTheStopwatch Remarks Use of this performable requires the actor has the UseAStopwatch ability. StopTheStopwatch() Gets a performable which stops the stopwatch. public static StopTheStopwatch StopTheStopwatch() Returns StopTheStopwatch Remarks Use of this performable requires the actor has the UseAStopwatch ability."
  },
  "api/CSF.Screenplay.Performables.TimeSpanBuilder-1.html": {
    "href": "api/CSF.Screenplay.Performables.TimeSpanBuilder-1.html",
    "title": "Class TimeSpanBuilder<TOtherBuilder> | Screenplay docs",
    "keywords": "Class TimeSpanBuilder<TOtherBuilder> Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll A supplementary builder type which enables the collection of TimeSpan instances. public class TimeSpanBuilder<TOtherBuilder> : IProvidesTimeSpan where TOtherBuilder : class Type Parameters TOtherBuilder The builder type for which this builder will supplement Inheritance object TimeSpanBuilder<TOtherBuilder> Implements IProvidesTimeSpan Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples The example below shows how the time span builder is intended to be used. It is consumed from within another builder, which needs to include a developer-configurable time span. See the documentation for writing performable builders for more information about the makeup of the EatLunchPerformableBuilder. public class EatLunchPerformableBuilder : IGetsPerformable { IProvidesTimeSpan? timeSpanBuilder; protected string? FoodName { get; init; } IPerformable IGetsPerformable.GetPerformable() => new EatLunch(FoodName, timeSpanBuilder?.GetTimeSpan() ?? TimeSpan.Zero); public TimeSpanBuilder<EatLunchPerformableBuilder> For(int howMany) { var builder = TimeSpanBuilder.Create(this, howMany); timeSpanBuilder = builder; return builder; } public static EatLunchPerformableBuilder Eat(string foodName) => new EatLunchPerformableBuilder() { FoodName = foodName }; } The sample builder above would be used to build an instance of a (fictitious) EachLunch performable, which derives from IPerformable. The fictitious performable requires two parameters; the name of the food being eaten for lunch and how long the lunch break lasts. The time span builder is used for that second parameter. A consumer which uses this builder in an IPerformance, or another performable, might consume it as follows. using static EatLunchPerformableBuilder; // ... actor.PerformAsync(Eat(\"Sandwiches\").For(30).Minutes(), cancellationToken); A note for developers with access to the source code for this library. There is a small integration test which sets up and exercises the example above; it is named TimeSpanBuilderTests. Remarks When consuming Performable objects it is recommended to use the builder pattern to create them. A commonly-used 'parameter' which may be specified in builders is 'an amount of time', IE a TimeSpan. This builder is intended to supplement another builder, for the purpose of specifying an amount of time. The 'other' builder is passed as a constructor parameter to this builder, along with an absolute amount. The consumer should then execute one of the methods of this type, which selects the unit of time and thus determines the TimeSpan value. The method which determines the units then returns that other builder instance, allowing the building process to continue with that other builder. Whilst it is possible to create instances of this type via its public constructor, it is often easier to create instances using the staticTimeSpanBuilder class. Constructors TimeSpanBuilder(TOtherBuilder, int) Initializes a new instance of TimeSpanBuilder<TOtherBuilder>. public TimeSpanBuilder(TOtherBuilder otherBuilder, int value) Parameters otherBuilder TOtherBuilder The other builder which shall be supplemented by this value int The absolute value of time, but without units Exceptions ArgumentNullException If otherBuilder is null. ArgumentOutOfRangeException If value is less than zero. Methods Days() Configures the contained time span to be measured in days, then returns the contained builder. public TOtherBuilder Days() Returns TOtherBuilder Hours() Configures the contained time span to be measured in hours, then returns the contained builder. public TOtherBuilder Hours() Returns TOtherBuilder Milliseconds() Configures the contained time span to be measured in milliseconds, then returns the contained builder. public TOtherBuilder Milliseconds() Returns TOtherBuilder Minutes() Configures the contained time span to be measured in minutes, then returns the contained builder. public TOtherBuilder Minutes() Returns TOtherBuilder Seconds() Configures the contained time span to be measured in seconds, then returns the contained builder. public TOtherBuilder Seconds() Returns TOtherBuilder See Also Create<TOtherBuilder>(TOtherBuilder, int)"
  },
  "api/CSF.Screenplay.Performables.TimeSpanBuilder.html": {
    "href": "api/CSF.Screenplay.Performables.TimeSpanBuilder.html",
    "title": "Class TimeSpanBuilder | Screenplay docs",
    "keywords": "Class TimeSpanBuilder Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll Static helper class for creating instances of TimeSpanBuilder<TOtherBuilder>. public static class TimeSpanBuilder Inheritance object TimeSpanBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks See the documentation for TimeSpanBuilder<TOtherBuilder> for more information about how this class is to be used. Methods Create<TOtherBuilder>(TOtherBuilder, int) Creates and returns a TimeSpanBuilder<TOtherBuilder> which can hold time span information and then continue the building process associated with the other builder. public static TimeSpanBuilder<TOtherBuilder> Create<TOtherBuilder>(TOtherBuilder otherBuilder, int value) where TOtherBuilder : class Parameters otherBuilder TOtherBuilder An instance of another performable builder value int The absolute time span value, without any units Returns TimeSpanBuilder<TOtherBuilder> Type Parameters TOtherBuilder The type of the other performable builder Remarks See the documentation for TimeSpanBuilder<TOtherBuilder> for more information about how this method is to be used."
  },
  "api/CSF.Screenplay.Performables.html": {
    "href": "api/CSF.Screenplay.Performables.html",
    "title": "Namespace CSF.Screenplay.Performables | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.Performables Classes PerformableException Thrown when a Performable fails with an unexpected exception. ReadTheStopwatch An action which reads the current value of the stopwatch. ResetTheStopwatch An action which resets the stopwatch. StartTheStopwatch An action which starts the stopwatch. StopTheStopwatch An action which stops the stopwatch. StopwatchBuilder A builder for actions relating to the UseAStopwatch ability. TimeSpanBuilder Static helper class for creating instances of TimeSpanBuilder<TOtherBuilder>. TimeSpanBuilder<TOtherBuilder> A supplementary builder type which enables the collection of TimeSpan instances. Interfaces IGetsPerformable An object which can get an IPerformable instance, such as a performable builder. IGetsPerformableWithResult An object which can get a non-generic IPerformableWithResult instance, such as a performable builder. IGetsPerformableWithResult<TResult> An object which can get an IPerformableWithResult<TResult> instance, such as a performable builder. IProvidesTimeSpan A type which may provide a TimeSpan."
  },
  "api/CSF.Screenplay.Performance.html": {
    "href": "api/CSF.Screenplay.Performance.html",
    "title": "Class Performance | Screenplay docs",
    "keywords": "Class Performance Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Primary implementation type of IPerformance. public sealed class Performance : IPerformance, IHasPerformanceIdentity, IHasServiceProvider, IDisposable, IBeginsAndEndsPerformance, IEquatable<Performance> Inheritance object Performance Implements IPerformance IHasPerformanceIdentity IHasServiceProvider IDisposable IBeginsAndEndsPerformance IEquatable<Performance> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Performance(IServiceProvider, IList<IdentifierAndName>, Guid) Initialises a new instance of Performance public Performance(IServiceProvider serviceProvider, IList<IdentifierAndName> namingHierarchy = null, Guid performanceIdentity = default) Parameters serviceProvider IServiceProvider A dependency injection service provider namingHierarchy IList<IdentifierAndName> A collection of identifiers and names providing the hierarchical name of this performance; see NamingHierarchy for more information. performanceIdentity Guid A unique identifier for the performance; if omitted (equal to Empty) then a new Guid will be generated as the identity for this performance Exceptions ArgumentNullException If serviceProvider is null Properties NamingHierarchy Gets an ordered list of identifiers which indicate the current performance's name within an organisational hierarchy. public List<IdentifierAndName> NamingHierarchy { get; } Property Value List<IdentifierAndName> Examples If the current performance is to be named Joe can take out the Trash, and it is part of a parent name, named Joe can do his chores then the first identifier in the list will be named Joe can do his chores and the second will be named Joe can take out the Trash. Remarks A Screenplay typically contains more than one performance and may contain many. It is normal to organise performances into a hierarchical structure based upon their purpose, role or relationship. The position of the current performance in that naming structure is represented by the value of this property. The ordered list of IdentifierAndName instances indicate a path from the 'root' of the hierarchy (which has no inherent name) to the current performance. Identifier/name pairs which are earlier in the collection are considered to be closer to the root, whereas latter identifier/names are branch & leaf names. In this manner, they work very similarly to .NET namespaces. The earlier in the list that a name appears, the more general it should be, representing a wider category. When using Screenplay with Integration, this hierarchy of names would typically correspond to the naming convention used by the testing framework. That might be based upon .NET namespaces, classes and test methods for a more traditional unit testing framework. Alternatively, for a BDD-style testing framework, it could be named based upon human-readable feature & scenario names. Ideally this property would be immutable after a Performance is created. Unfortunately, some testing frameworks do not expose relevant naming information about a test until after the point of execution where the Performance must be created. Thus, this property is mutable, so that it is possible to 'backfill' missing naming information after the performance has been created. Wherever possible, it is recommended to avoid updating this list of identifier/names and to only set them up when creating the performance, via ICreatesPerformance. PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. PerformanceState Gets a value which indicates the state of the current performance. public PerformanceState PerformanceState { get; } Property Value PerformanceState See Also PerformanceState ServiceProvider Gets a service provider/resolver instance associated with this object. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods BeginPerformance() Begins the performance public void BeginPerformance() Dispose() public void Dispose() Equals(Performance) public bool Equals(Performance other) Parameters other Performance Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool FinishPerformance(bool?) Finishes the performance with a value indicating whether or not it was a success public void FinishPerformance(bool? success) Parameters success bool? If true then the performance is to be considered a success; if false then a failure. A value of null indicates that the performance did not succeed but should not be considered a failure either. GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/CSF.Screenplay.PerformanceStarter.html": {
    "href": "api/CSF.Screenplay.PerformanceStarter.html",
    "title": "Class PerformanceStarter | Screenplay docs",
    "keywords": "Class PerformanceStarter Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Helper class for beginning the functionality of a Screenplay IPerformance from your own logic, using a fluent interface public static class PerformanceStarter Inheritance object PerformanceStarter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples Here is an example of the recommended technique for consuming this class' functionality. using static CSF.Screenplay.ScreenplayStarter; // ... then in your top-level performance logic: await Given(joe).WasAbleTo(takeOutTheTrash); Remarks This class is a convenience to aid in the readability of top-level performance logic, providing a fluent entry-point into the performance methods. Each of the methods upon this class corresponds to a PerformancePhase within the overall performance. By using these methods, the actor is down-cast to the appropriate interface that is specific to that phase, which activates appropriate functionality of the fluent interface. It is recommended to consume this functionality in your own logic via the using static directive, so that you may use the Given(Actor), When(Actor) & Then(Actor) methods stand-alone. Do not use these methods in your own Performable implementations. Doing so would reduce their reusability; use these methods only in your top-level performance logic. Any performables which are executed by one of these three methods automatically inherits the performance phase from which its top-level performable was started. Methods Given(Actor) Returns the actor instance, down-cast to ICanPerformGiven, activating the fluent interface for the Given phase of the performance. public static ICanPerformGiven Given(Actor actor) Parameters actor Actor The actor. Returns ICanPerformGiven Then(Actor) Returns the actor instance, down-cast to ICanPerformThen, activating the fluent interface for the Then phase of the performance. public static ICanPerformThen Then(Actor actor) Parameters actor Actor The actor. Returns ICanPerformThen When(Actor) Returns the actor instance, down-cast to ICanPerformWhen, activating the fluent interface for the When phase of the performance. public static ICanPerformWhen When(Actor actor) Parameters actor Actor The actor. Returns ICanPerformWhen"
  },
  "api/CSF.Screenplay.Performances.IBeginsAndEndsPerformance.html": {
    "href": "api/CSF.Screenplay.Performances.IBeginsAndEndsPerformance.html",
    "title": "Interface IBeginsAndEndsPerformance | Screenplay docs",
    "keywords": "Interface IBeginsAndEndsPerformance Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll An object which controls the beginning and ending of a performance public interface IBeginsAndEndsPerformance Methods BeginPerformance() Begins the performance void BeginPerformance() FinishPerformance(bool?) Finishes the performance with a value indicating whether or not it was a success void FinishPerformance(bool? success) Parameters success bool? If true then the performance is to be considered a success; if false then a failure. A value of null indicates that the performance did not succeed but should not be considered a failure either."
  },
  "api/CSF.Screenplay.Performances.ICreatesPerformance.html": {
    "href": "api/CSF.Screenplay.Performances.ICreatesPerformance.html",
    "title": "Interface ICreatesPerformance | Screenplay docs",
    "keywords": "Interface ICreatesPerformance Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll An object which creates instances of IPerformance; a factory service. public interface ICreatesPerformance Methods CreatePerformance() Creates a new performance instance. IPerformance CreatePerformance() Returns IPerformance A new performance instance"
  },
  "api/CSF.Screenplay.Performances.IHasPerformanceEvents.html": {
    "href": "api/CSF.Screenplay.Performances.IHasPerformanceEvents.html",
    "title": "Interface IHasPerformanceEvents | Screenplay docs",
    "keywords": "Interface IHasPerformanceEvents Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll An object which has events which are significant to the progress of a Screenplay. public interface IHasPerformanceEvents Remarks This object is used as an event publisher, such that events which originate from many separate objects may be aggregated to a single point of contact. This way, consumers of those events have only a single object to which they need subscribe. There should only be a single instance of an object which implements this interface, for the lifetime of a Screenplay. This type is closely related to IRelaysPerformanceEvents. This is the event publisher and IRelaysPerformanceEvents is event sink which collects them. Despite this, their APIs are not symmetrical, as many of the events published by this type are derived by subscribing to an Actor instance from the event sink. Events ActorCreated Occurs when a new Actor is created and added to the IPerformance. event EventHandler<ActorEventArgs> ActorCreated Event Type EventHandler<ActorEventArgs> ActorSpotlit Occurs when an Actor is placed into the Spotlight of an IStage. event EventHandler<ActorEventArgs> ActorSpotlit Event Type EventHandler<ActorEventArgs> BeginPerformable Occurs when an Actor begins the execution of a performable object. event EventHandler<PerformableEventArgs> BeginPerformable Event Type EventHandler<PerformableEventArgs> EndPerformable Occurs when an Actor ends the execution of a performable object. event EventHandler<PerformableEventArgs> EndPerformable Event Type EventHandler<PerformableEventArgs> GainedAbility Occurs when an Actor gains a new ability. event EventHandler<GainAbilityEventArgs> GainedAbility Event Type EventHandler<GainAbilityEventArgs> PerformableFailed Occurs when a performable object fails with an exception. event EventHandler<PerformableFailureEventArgs> PerformableFailed Event Type EventHandler<PerformableFailureEventArgs> PerformableResult Occurs when an Actor receives a result from a perfperformable objectrmance. event EventHandler<PerformableResultEventArgs> PerformableResult Event Type EventHandler<PerformableResultEventArgs> PerformanceBegun Occurs when a IPerformance begins executing. event EventHandler<PerformanceEventArgs> PerformanceBegun Event Type EventHandler<PerformanceEventArgs> PerformanceFinished Occurs when a IPerformance has finished executing. event EventHandler<PerformanceFinishedEventArgs> PerformanceFinished Event Type EventHandler<PerformanceFinishedEventArgs> ScreenplayEnded Occurs when a Screenplay has ended. event EventHandler ScreenplayEnded Event Type EventHandler ScreenplayStarted Occurs when a Screenplay starts. event EventHandler ScreenplayStarted Event Type EventHandler SpotlightTurnedOff Occurs when the Spotlight of an IStage is 'turned off'; the Actor who is currently spotlit is removed without being replaced. event EventHandler<PerformanceScopeEventArgs> SpotlightTurnedOff Event Type EventHandler<PerformanceScopeEventArgs> See Also IRelaysPerformanceEvents"
  },
  "api/CSF.Screenplay.Performances.IRelaysPerformanceEvents.html": {
    "href": "api/CSF.Screenplay.Performances.IRelaysPerformanceEvents.html",
    "title": "Interface IRelaysPerformanceEvents | Screenplay docs",
    "keywords": "Interface IRelaysPerformanceEvents Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll An object which can relay events that relate to a IPerformance public interface IRelaysPerformanceEvents Remarks This object is used as an event sink; a single point of contact to which many objects may send events. This allows event consumers to receive events from many origins by subscribing to only a single object. There should only be a single instance of an object which implements this interface, for the lifetime of a Screenplay. This type is closely related to IHasPerformanceEvents. This is the event sink and IHasPerformanceEvents is the publisher of those events. Despite this, their APIs are not symmetrical, as many of the events published are derived by subscribing to an Actor instance. Methods InvokeActorCreated(string, Guid) Invokes an event indicating that a new Actor has been created and added to the IPerformance. void InvokeActorCreated(string actorName, Guid performanceIdentity) Parameters actorName string The actor's human-readable name. performanceIdentity Guid A unique identifier for the current IPerformance. InvokeActorSpotlit(string, Guid) Invokes an event indicating that an Actor has been placed into the Spotlight of an IStage. void InvokeActorSpotlit(string actorName, Guid performanceIdentity) Parameters actorName string The actor's human-readable name. performanceIdentity Guid A unique identifier for the current IPerformance. InvokeGainedAbility(string, Guid, object) Invokes an event indicating that a new Actor has gained an ability. void InvokeGainedAbility(string actorName, Guid performanceIdentity, object ability) Parameters actorName string The actor's human-readable name. performanceIdentity Guid A unique identifier for the current IPerformance. ability object The ability that the actor has gained. Remarks Use this method only when an actor gains one or more abilities before the the SubscribeTo(Actor) method has been used to subscribe to the actor. Once the actor has been subscribed-to by an implementation of this instance, their newly-added abilities will automatically be captured. In some circumstances where the actor is fully created and has their abilities granted BEFORE there has been an opportunity to subscribe to them, then this method is required to retrospectively trigger the abilitiy-granted event. This is applicable for actors who are created by an IPersona, which might grant the actors one or more abilities immediately, as part of their creation. InvokePerformanceBegun(Guid, IList<IdentifierAndName>) Invokes an event indicating that a IPerformance has begun. void InvokePerformanceBegun(Guid performanceIdentity, IList<IdentifierAndName> namingHierarchy) Parameters performanceIdentity Guid The performance identity namingHierarchy IList<IdentifierAndName> The performance's hierarchical name InvokePerformanceFinished(Guid, IList<IdentifierAndName>, bool?) Invokes an event indicating that a IPerformance has finished. void InvokePerformanceFinished(Guid performanceIdentity, IList<IdentifierAndName> namingHierarchy, bool? success) Parameters performanceIdentity Guid The performance identity namingHierarchy IList<IdentifierAndName> The performance's hierarchical name success bool? A value indicating whether or not the performance was a success InvokeScreenplayEnded() Invokes an event indicating that a Screenplay has ended. void InvokeScreenplayEnded() InvokeScreenplayStarted() Invokes an event indicating that a Screenplay has started. void InvokeScreenplayStarted() InvokeSpotlightTurnedOff(Guid) Invokes an event indicating that the Spotlight of the IStage has been 'turned off'. void InvokeSpotlightTurnedOff(Guid performanceIdentity) Parameters performanceIdentity Guid A unique identifier for the current IPerformance. SubscribeTo(Actor) Subscribes to (and relays) events from the specified actor. void SubscribeTo(Actor actor) Parameters actor Actor The actor to which this relay should subscribe. UnsubscribeFrom(Actor) Unsubscribes from events from the specified actor. void UnsubscribeFrom(Actor actor) Parameters actor Actor The actor from which this relay should unsubscribe. Remarks This method is typically used when the actor instance is about to be disposed, such as at the end of a IPerformance. UnsubscribeFromAllActors(Guid) Unsubscribes from all of the events for all of the actors who are part of the the IPerformance, indicated by its identity. void UnsubscribeFromAllActors(Guid performanceIdentity) Parameters performanceIdentity Guid The identity of a performance. Remarks Using this method is equivalent to calling UnsubscribeFrom(Actor) for every Actor which is participating in the specified performance. Use this method when ending a performance, as a convenience to unsubscribe from all of its actors at once. See Also IHasPerformanceEvents"
  },
  "api/CSF.Screenplay.Performances.IdentifierAndName.html": {
    "href": "api/CSF.Screenplay.Performances.IdentifierAndName.html",
    "title": "Class IdentifierAndName | Screenplay docs",
    "keywords": "Class IdentifierAndName Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll A model which indicates a unique identifier and a corresponding human-readable name. public sealed class IdentifierAndName : IEquatable<IdentifierAndName>, IHasName Inheritance object IdentifierAndName Implements IEquatable<IdentifierAndName> IHasName Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors IdentifierAndName(string, string, bool) Initialises a new instance of IdentifierAndName public IdentifierAndName(string identifier, string name = null, bool wasIdentifierAutoGenerated = false) Parameters identifier string The identifier for this item, which might not be human-readable name string A human-readable name for this item wasIdentifierAutoGenerated bool A value that indicates whether or not identifier is an auto-generated value Exceptions ArgumentNullException If identifier is null Properties Identifier Gets the identifier for the current item public string Identifier { get; } Property Value string Remarks The identifier for an item might not be a human-readable value. It is required to uniquely identify the current item, however. Name Gets a human-readable name for the current item public string Name { get; } Property Value string Remarks The human-readable name in this context is not mandatory, and so this property might return a null reference if no name was specified. WasIdentifierAutoGenerated Gets a value indicating whether or not the Identifier is an automatically-generated value or not. public bool WasIdentifierAutoGenerated { get; } Property Value bool Remarks Some integrations with Screenplay do not provide a suitable unique identifier for this position. In that case, because a unique identifier is required, Screenplay generates a unique identifier (the string representation of a GUID) automatically and uses it as the Identifier. Obviously, if that is the case then the identifier will have no meaning or correspondence to anything in the logic consuming Screenplay. This property is used to indicate when this is the case; if it is true then the Identifier was randomly-generated by Screenplay. Methods Equals(IdentifierAndName) public bool Equals(IdentifierAndName other) Parameters other IdentifierAndName Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string"
  },
  "api/CSF.Screenplay.Performances.PerformanceEventArgs.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceEventArgs.html",
    "title": "Class PerformanceEventArgs | Screenplay docs",
    "keywords": "Class PerformanceEventArgs Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to a scope of a IPerformance. public class PerformanceEventArgs : PerformanceScopeEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs PerformanceEventArgs Implements IHasPerformanceIdentity Derived PerformanceFinishedEventArgs Inherited Members PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformanceEventArgs(Guid, IReadOnlyList<IdentifierAndName>) Initialises a new instance of PerformanceEventArgs public PerformanceEventArgs(Guid performanceIdentity, IReadOnlyList<IdentifierAndName> namingHierarchy) Parameters performanceIdentity Guid The performance identity namingHierarchy IReadOnlyList<IdentifierAndName> The screenplay naming hierarchy Exceptions ArgumentNullException If the scenario hierarchy is null Properties NamingHierarchy Gets an ordered list of identifiers which indicate the IPerformance's name within an organisational hierarchy. public IReadOnlyList<IdentifierAndName> NamingHierarchy { get; } Property Value IReadOnlyList<IdentifierAndName> Remarks This hierarchical name has the exact same meaning and corresponds directly to NamingHierarchy. See Also IPerformance NamingHierarchy See Also IPerformance PerformanceScopeEventArgs"
  },
  "api/CSF.Screenplay.Performances.PerformanceEventBus.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceEventBus.html",
    "title": "Class PerformanceEventBus | Screenplay docs",
    "keywords": "Class PerformanceEventBus Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.dll Implementation of an event bus for performance-related events. public class PerformanceEventBus : IHasPerformanceEvents, IRelaysPerformanceEvents Inheritance object PerformanceEventBus Implements IHasPerformanceEvents IRelaysPerformanceEvents Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This object should be used as a singleton across the lifetime of a Screenplay. As an event bus object, it is both a subscriber (a sink) which can receive events. It is also a publisher, which emits events. The purpose of this object is to aggregate events from many instances of Performance and Actor over the duration/lifetime of the Screenplay. This way, consumers have only a single object to which they should subscribe in order to receive those events. As you will see from the API of this object, the implementations of IHasPerformanceEvents and IRelaysPerformanceEvents are not symmetrical. Many events are published by subscribing to the events upon an Actor. Methods InvokeActorCreated(string, Guid) Invokes an event indicating that a new Actor has been created and added to the IPerformance. public void InvokeActorCreated(string actorName, Guid performanceIdentity) Parameters actorName string The actor's human-readable name. performanceIdentity Guid A unique identifier for the current IPerformance. InvokeActorSpotlit(string, Guid) Invokes an event indicating that an Actor has been placed into the Spotlight of an IStage. public void InvokeActorSpotlit(string actorName, Guid performanceIdentity) Parameters actorName string The actor's human-readable name. performanceIdentity Guid A unique identifier for the current IPerformance. InvokeGainedAbility(string, Guid, object) Invokes an event indicating that a new Actor has gained an ability. public void InvokeGainedAbility(string actorName, Guid performanceIdentity, object ability) Parameters actorName string The actor's human-readable name. performanceIdentity Guid A unique identifier for the current IPerformance. ability object The ability that the actor has gained. Remarks Use this method only when an actor gains one or more abilities before the the SubscribeTo(Actor) method has been used to subscribe to the actor. Once the actor has been subscribed-to by an implementation of this instance, their newly-added abilities will automatically be captured. In some circumstances where the actor is fully created and has their abilities granted BEFORE there has been an opportunity to subscribe to them, then this method is required to retrospectively trigger the abilitiy-granted event. This is applicable for actors who are created by an IPersona, which might grant the actors one or more abilities immediately, as part of their creation. InvokePerformanceBegun(Guid, IList<IdentifierAndName>) Invokes an event indicating that a IPerformance has begun. public void InvokePerformanceBegun(Guid performanceIdentity, IList<IdentifierAndName> namingHierarchy) Parameters performanceIdentity Guid The performance identity namingHierarchy IList<IdentifierAndName> The performance's hierarchical name InvokePerformanceFinished(Guid, IList<IdentifierAndName>, bool?) Invokes an event indicating that a IPerformance has finished. public void InvokePerformanceFinished(Guid performanceIdentity, IList<IdentifierAndName> namingHierarchy, bool? success) Parameters performanceIdentity Guid The performance identity namingHierarchy IList<IdentifierAndName> The performance's hierarchical name success bool? A value indicating whether or not the performance was a success InvokeScreenplayEnded() Invokes an event indicating that a Screenplay has ended. public void InvokeScreenplayEnded() InvokeScreenplayStarted() Invokes an event indicating that a Screenplay has started. public void InvokeScreenplayStarted() InvokeSpotlightTurnedOff(Guid) Invokes an event indicating that the Spotlight of the IStage has been 'turned off'. public void InvokeSpotlightTurnedOff(Guid performanceIdentity) Parameters performanceIdentity Guid A unique identifier for the current IPerformance. SubscribeTo(Actor) Subscribes to (and relays) events from the specified actor. public void SubscribeTo(Actor actor) Parameters actor Actor The actor to which this relay should subscribe. UnsubscribeFrom(Actor) Unsubscribes from events from the specified actor. public void UnsubscribeFrom(Actor actor) Parameters actor Actor The actor from which this relay should unsubscribe. Remarks This method is typically used when the actor instance is about to be disposed, such as at the end of a IPerformance. UnsubscribeFromAllActors(Guid) Unsubscribes from all of the events for all of the actors who are part of the the IPerformance, indicated by its identity. public void UnsubscribeFromAllActors(Guid performanceIdentity) Parameters performanceIdentity Guid The identity of a performance. Remarks Using this method is equivalent to calling UnsubscribeFrom(Actor) for every Actor which is participating in the specified performance. Use this method when ending a performance, as a convenience to unsubscribe from all of its actors at once. Events ActorCreated Occurs when a new Actor is created and added to the IPerformance. public event EventHandler<ActorEventArgs> ActorCreated Event Type EventHandler<ActorEventArgs> ActorSpotlit Occurs when an Actor is placed into the Spotlight of an IStage. public event EventHandler<ActorEventArgs> ActorSpotlit Event Type EventHandler<ActorEventArgs> BeginPerformable Occurs when an Actor begins the execution of a performable object. public event EventHandler<PerformableEventArgs> BeginPerformable Event Type EventHandler<PerformableEventArgs> EndPerformable Occurs when an Actor ends the execution of a performable object. public event EventHandler<PerformableEventArgs> EndPerformable Event Type EventHandler<PerformableEventArgs> GainedAbility Occurs when an Actor gains a new ability. public event EventHandler<GainAbilityEventArgs> GainedAbility Event Type EventHandler<GainAbilityEventArgs> PerformableFailed Occurs when a performable object fails with an exception. public event EventHandler<PerformableFailureEventArgs> PerformableFailed Event Type EventHandler<PerformableFailureEventArgs> PerformableResult Occurs when an Actor receives a result from a perfperformable objectrmance. public event EventHandler<PerformableResultEventArgs> PerformableResult Event Type EventHandler<PerformableResultEventArgs> PerformanceBegun Occurs when a IPerformance begins executing. public event EventHandler<PerformanceEventArgs> PerformanceBegun Event Type EventHandler<PerformanceEventArgs> PerformanceFinished Occurs when a IPerformance has finished executing. public event EventHandler<PerformanceFinishedEventArgs> PerformanceFinished Event Type EventHandler<PerformanceFinishedEventArgs> ScreenplayEnded Occurs when a Screenplay has ended. public event EventHandler ScreenplayEnded Event Type EventHandler ScreenplayStarted Occurs when a Screenplay starts. public event EventHandler ScreenplayStarted Event Type EventHandler SpotlightTurnedOff Occurs when the Spotlight of an IStage is 'turned off'; the Actor who is currently spotlit is removed without being replaced. public event EventHandler<PerformanceScopeEventArgs> SpotlightTurnedOff Event Type EventHandler<PerformanceScopeEventArgs>"
  },
  "api/CSF.Screenplay.Performances.PerformanceFactory.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceFactory.html",
    "title": "Class PerformanceFactory | Screenplay docs",
    "keywords": "Class PerformanceFactory Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.dll A factory service for instances of Performance public class PerformanceFactory : ICreatesPerformance Inheritance object PerformanceFactory Implements ICreatesPerformance Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformanceFactory(IServiceProvider) Initialises a new instance of PerformanceFactory public PerformanceFactory(IServiceProvider services) Parameters services IServiceProvider Dependency injection services Exceptions ArgumentNullException If services is null Methods CreatePerformance() Creates a new performance instance. public IPerformance CreatePerformance() Returns IPerformance A new performance instance"
  },
  "api/CSF.Screenplay.Performances.PerformanceFinishedEventArgs.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceFinishedEventArgs.html",
    "title": "Class PerformanceFinishedEventArgs | Screenplay docs",
    "keywords": "Class PerformanceFinishedEventArgs Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to a finishing of a IPerformance. public class PerformanceFinishedEventArgs : PerformanceEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs PerformanceEventArgs PerformanceFinishedEventArgs Implements IHasPerformanceIdentity Inherited Members PerformanceEventArgs.NamingHierarchy PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformanceFinishedEventArgs(Guid, IReadOnlyList<IdentifierAndName>, bool?) Initialises a new instance of PerformanceEventArgs public PerformanceFinishedEventArgs(Guid performanceIdentity, IReadOnlyList<IdentifierAndName> namingHierarchy, bool? success) Parameters performanceIdentity Guid The performance identity namingHierarchy IReadOnlyList<IdentifierAndName> The scenario hierarchy success bool? A value indicating whether or not the scenario completed with a succeess result Exceptions ArgumentNullException If the scenario hierarchy is null Properties Success Gets a value indicating whether the finished IPerformance was a success or not public bool? Success { get; } Property Value bool? Remarks The three possible values for this property correspond to three possible values of PerformanceState which represent a performance that has finished. Value Corresponding state true Success false Failed null Completed When using Screenplay with Integration, these three performance states may go on to correspond to a test pass, failure or skipped/ignored test, respectively. See Also IPerformance PerformanceScopeEventArgs PerformanceEventArgs"
  },
  "api/CSF.Screenplay.Performances.PerformanceScopeEventArgs.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceScopeEventArgs.html",
    "title": "Class PerformanceScopeEventArgs | Screenplay docs",
    "keywords": "Class PerformanceScopeEventArgs Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to a scope of a IPerformance. public class PerformanceScopeEventArgs : EventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs Implements IHasPerformanceIdentity Derived ActorEventArgs PerformanceEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This event arguments class is often used as a base for models which identify a IPerformance. Constructors PerformanceScopeEventArgs(Guid) Initializes a new instance of PerformanceScopeEventArgs public PerformanceScopeEventArgs(Guid performanceIdentity) Parameters performanceIdentity Guid The performance identity Properties PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. See Also IPerformance"
  },
  "api/CSF.Screenplay.Performances.PerformanceState.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceState.html",
    "title": "Enum PerformanceState | Screenplay docs",
    "keywords": "Enum PerformanceState Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll Enumerates the states of a IPerformance. public enum PerformanceState Fields Completed = 4 The performance has completed but it has neither succeeded or failed. Failed = 3 The performance has completed but it has failed. InProgress = 1 The performance has been started but is not yet complete; use FinishPerformance(bool?) to complete it. NotStarted = 0 The performance is not yet started; use BeginPerformance() to begin it. Success = 2 The performance has completed and was a success. Remarks When Screenplay is being used with Integration then this will also closely correspond to the state & outcome of the corresponding Scenario"
  },
  "api/CSF.Screenplay.Performances.html": {
    "href": "api/CSF.Screenplay.Performances.html",
    "title": "Namespace CSF.Screenplay.Performances | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.Performances Classes IdentifierAndName A model which indicates a unique identifier and a corresponding human-readable name. PerformanceEventArgs A model for event arguments which relate to a scope of a IPerformance. PerformanceEventBus Implementation of an event bus for performance-related events. PerformanceFactory A factory service for instances of Performance PerformanceFinishedEventArgs A model for event arguments which relate to a finishing of a IPerformance. PerformanceScopeEventArgs A model for event arguments which relate to a scope of a IPerformance. Interfaces IBeginsAndEndsPerformance An object which controls the beginning and ending of a performance ICreatesPerformance An object which creates instances of IPerformance; a factory service. IHasPerformanceEvents An object which has events which are significant to the progress of a Screenplay. IRelaysPerformanceEvents An object which can relay events that relate to a IPerformance Enums PerformanceState Enumerates the states of a IPerformance."
  },
  "api/CSF.Screenplay.ScopeAndPerformance.html": {
    "href": "api/CSF.Screenplay.ScopeAndPerformance.html",
    "title": "Class ScopeAndPerformance | Screenplay docs",
    "keywords": "Class ScopeAndPerformance Namespace CSF.Screenplay Assembly CSF.Screenplay.dll A model which contains both an IPerformance and a dependency injection IServiceScope. public sealed class ScopeAndPerformance : IDisposable Inheritance object ScopeAndPerformance Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors ScopeAndPerformance(IPerformance, IServiceScope) Initialises a new instance of ScopeAndPerformance. public ScopeAndPerformance(IPerformance performance, IServiceScope scope) Parameters performance IPerformance The performance scope IServiceScope The scope Exceptions ArgumentNullException If any parameter is null. Properties Performance Gets the performance. public IPerformance Performance { get; } Property Value IPerformance Scope Gets the DI scope. public IServiceScope Scope { get; } Property Value IServiceScope Methods Dispose() public void Dispose()"
  },
  "api/CSF.Screenplay.Screenplay.html": {
    "href": "api/CSF.Screenplay.Screenplay.html",
    "title": "Class Screenplay | Screenplay docs",
    "keywords": "Class Screenplay Namespace CSF.Screenplay Assembly CSF.Screenplay.dll An object which represents a complete execution of Screenplay logic, which should include one or more Performance instances. public sealed class Screenplay : IHasServiceProvider Inheritance object Screenplay Implements IHasServiceProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods ScreenplayExtensions.CreateScopedPerformance(Screenplay, IList<IdentifierAndName>) ScreenplayExtensions.ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, int) ScreenplayExtensions.ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, CancellationToken) Remarks A Screenplay, when used as a noun (an instance of this class), refers to a complete execution of the Screenplay software. A Screenplay is composed of at least one Performance and typically contains many performances. When the Screenplay architecture is applied to automated testing, an instance of this class corresponds to a complete test run, where each test corresponds to a performance. End-user logic, such as test logic, rarely interacts directly with this class. That is because the Screenplay object is generally consumed only by integration logic. It is recommended to create instances of this type by adding Screenplay to a dependency injection IServiceCollection via the extension method AddScreenplay(IServiceCollection) and then resolving an instance of this class from the service provider. Alternatively, if you do not wish to configure a service collection manually and just want an instance of this type then use the static Create(Action<IServiceCollection>) method. The Screenplay object is used to create instances of Performance via the PerformanceFactory. You may wish to read a diagram showing how screenplays, performances, actors and performables relate to one another. Constructors Screenplay(IServiceProvider) Initialises a new instance of Screenplay. public Screenplay(IServiceProvider serviceProvider) Parameters serviceProvider IServiceProvider A service provider Remarks It is unlikely that developers should be executing this constructor directly. Consider using the static factory method Create(Action<IServiceCollection>). Alternatively, add Screenplay to an IServiceCollection using AddScreenplay(IServiceCollection) and then resolve an instance of this class from the service provider built from that service collection. Exceptions ArgumentNullException If serviceProvider is null. Properties ServiceProvider Gets a service provider/resolver instance associated with this object. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods BeginScreenplay() Execute this method from the consuming logic in order to inform the Screenplay architecture that the Screenplay has begun. public void BeginScreenplay() CompleteScreenplay() Execute this method from the consuming logic in order to inform the Screenplay architecture that the Screenplay is now complete. public void CompleteScreenplay() Create(Action<IServiceCollection>) Creates and returns a Screenplay, optionally including some dependency injection service customisations. public static Screenplay Create(Action<IServiceCollection> serviceCollectionCustomisations = null) Parameters serviceCollectionCustomisations Action<IServiceCollection> Returns Screenplay A Screenplay instance created from a new service collection. Remarks Use this method to create an instance of Screenplay when you are not already using an IServiceCollection. This method creates a new service collection instance, adds Screenplay to it and then creates & returns the Screenplay object instance. If you already have an IServiceCollection and you wish to integrate Screenplay into it, then use the extension method AddScreenplay(IServiceCollection) instead. ExecuteAsPerformanceAsync(Func<IServiceProvider, CancellationToken, Task<bool?>>, IList<IdentifierAndName>, CancellationToken) Executes the specified logic as a Performance public Task ExecuteAsPerformanceAsync(Func<IServiceProvider, CancellationToken, Task<bool?>> performanceLogic, IList<IdentifierAndName> namingHierarchy = null, CancellationToken cancellationToken = default) Parameters performanceLogic Func<IServiceProvider, CancellationToken, Task<bool?>> The logic to be executed by the performance. namingHierarchy IList<IdentifierAndName> An optional naming hierarchy used to identify the performance. cancellationToken CancellationToken An optional cancellation token to abort the performance logic. Returns Task A task which completes when the performance's logic has completed. Remarks This method is the primary entry point for beginning a Screenplay Performance. This method begins a new Dependency Injection Scope, and within that scope starts the performance, which executes the specified performance logic: performanceLogic. The return value from the performance logic should conform to the semantics of the parameter value passed to FinishPerformance(bool?). The namingHierarchy may be used to give the performance a name, so that its results (and subsequent report) may be identified. This parameter has the same semantics as NamingHierarchy. Note that if the performanceLogic raises a PerformableException then this method will 'swallow' that exception and not rethrow. That's not particularly bad though because: An event will be raised with the event bus: IHasPerformanceEvents, specifically PerformableFailed. This will contain details of the exception which occurred. The performance will be immediately terminated and placed into the Failed state. Exceptions ArgumentNullException If the performanceLogic is null. See Also Performance ScreenplayServiceCollectionExtensions"
  },
  "api/CSF.Screenplay.ScreenplayAssemblyAttribute.html": {
    "href": "api/CSF.Screenplay.ScreenplayAssemblyAttribute.html",
    "title": "Class ScreenplayAssemblyAttribute | Screenplay docs",
    "keywords": "Class ScreenplayAssemblyAttribute Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll An attribute used to mark an assembly which contains Screenplay-based tests. [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false)] public class ScreenplayAssemblyAttribute : TestActionAttribute, ITestAction Inheritance object Attribute TestActionAttribute ScreenplayAssemblyAttribute Implements ITestAction Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples Decorate your assembly with this attribute using the syntax [assembly: CSF.Screenplay.ScreenplayAssembly]. You may place this into any source file, outside of any type declaration. By convention it would be put into a dedicated source file within the Properties project directory. Remarks This attribute is the core of the NUnit3 test framework integration with Screenplay. In order to run tests with Screenplay, the assembly must be decorated with this attribute. This attribute has one mandatory parameter; that is the Type of a concrete implementation of IGetsScreenplay. That type will be instantiated by the NUnit3 integration and will be used to build and retrieve the Screenplay instance for running the Screenplay-based tests within the decorated assembly. Each test method must additionally be decorated with the ScreenplayAttribute in order to make it a Screenplay-based test. Constructors ScreenplayAssemblyAttribute(Type) Initializes a new instance of ScreenplayAssemblyAttribute. public ScreenplayAssemblyAttribute(Type factoryType) Parameters factoryType Type The concrete type of a class which implements IGetsScreenplay. Remarks The factoryType specified in this constructor must meet all of the following criteria: It must be a non-nullType which derives from IGetsScreenplay It must have a public parameterless constructor It must return a non-null instance of Screenplay from its GetScreenplay() method Properties Targets Provides the target for the action attribute public override ActionTargets Targets { get; } Property Value ActionTargets Methods AfterTest(ITest) Executed after each test is run public override void AfterTest(ITest test) Parameters test ITest The test that has just been run. BeforeTest(ITest) Executed before each test is run public override void BeforeTest(ITest test) Parameters test ITest The test that is going to be run. GetScreenplay() Gets the Screenplay which is to be used for tests contained in the current assembly. public Screenplay GetScreenplay() Returns Screenplay The Screenplay. Exceptions InvalidOperationException If the Screenplay factory used with the constructor to this attribute is invalid or fails to return a non-nullScreenplay instance. See Also ScreenplayAttribute"
  },
  "api/CSF.Screenplay.ScreenplayAttribute.html": {
    "href": "api/CSF.Screenplay.ScreenplayAttribute.html",
    "title": "Class ScreenplayAttribute | Screenplay docs",
    "keywords": "Class ScreenplayAttribute Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll Applied to a test method, indicates that decorated test is a Screenplay test. [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class ScreenplayAttribute : Attribute, ITestAction, ITestBuilder Inheritance object Attribute ScreenplayAttribute Implements ITestAction ITestBuilder Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks When a test method is decorated with this attribute then the test corresponding to that method will be executed via Screenplay. This means that the affected test method will be executed as an IPerformance. It also means that all parameters for the method will be provided by resolving them from the current performance's ServiceProvider. See the article on dependency injection in Screenplay for more information about what may be injected into test logic from DI, via the test method parameters. Remember that for this attribute to be effective, the Assembly which contains the test method must be decorated with ScreenplayAssemblyAttribute. If it is not, then the test will fail with an exception. Properties Targets Gets the targets for the attribute (when performing before/after test actions). public ActionTargets Targets { get; } Property Value ActionTargets The targets. Methods AfterTest(ITest) Executed after each test is run public void AfterTest(ITest test) Parameters test ITest The test that has just been run. BeforeTest(ITest) Executed before each test is run public void BeforeTest(ITest test) Parameters test ITest The test that is going to be run. BuildFrom(IMethodInfo, Test) Build one or more TestMethods from the provided MethodInfo. public IEnumerable<TestMethod> BuildFrom(IMethodInfo method, Test suite) Parameters method IMethodInfo The method to be used as a test suite Test The TestSuite to which the method will be added Returns IEnumerable<TestMethod> A TestMethod object See Also ScreenplayAssemblyAttribute"
  },
  "api/CSF.Screenplay.ScreenplayBinding.html": {
    "href": "api/CSF.Screenplay.ScreenplayBinding.html",
    "title": "Class ScreenplayBinding | Screenplay docs",
    "keywords": "Class ScreenplayBinding Namespace CSF.Screenplay Assembly CSF.Screenplay.SpecFlowPlugin.dll SpecFlow binding which uses hooks to coordinate the relevant Screenplay & IPerformance event invokers. [Binding] public class ScreenplayBinding Inheritance object ScreenplayBinding Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ScreenplayBinding(IServiceProvider) Initialises a new instance of ScreenplayBinding. public ScreenplayBinding(IServiceProvider serviceProvider) Parameters serviceProvider IServiceProvider The service provider Exceptions ArgumentNullException If the serviceProvider is null. Methods AfterScenario() Executed after each scenario. [AfterScenario(new string[] { })] public void AfterScenario() AfterTestRun() Executed after a test run. [AfterTestRun] public static void AfterTestRun() BeforeScenario() Executed before each scenario. [BeforeScenario(new string[] { })] public void BeforeScenario() BeforeTestRun() Executed before a test run. [BeforeTestRun] public static void BeforeTestRun()"
  },
  "api/CSF.Screenplay.ScreenplayExtensions.html": {
    "href": "api/CSF.Screenplay.ScreenplayExtensions.html",
    "title": "Class ScreenplayExtensions | Screenplay docs",
    "keywords": "Class ScreenplayExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Extension methods for the Screenplay type. public static class ScreenplayExtensions Inheritance object ScreenplayExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CreateScopedPerformance(Screenplay, IList<IdentifierAndName>) Creates a new IPerformance within its own newly-created Dependency Injection scope. public static ScopeAndPerformance CreateScopedPerformance(this Screenplay screenplay, IList<IdentifierAndName> namingHierarchy = null) Parameters screenplay Screenplay The Screenplay from which to create the performance namingHierarchy IList<IdentifierAndName> An optional collection of identifiers and names providing the hierarchical name of this performance; see NamingHierarchy for more information. Returns ScopeAndPerformance A ScopeAndPerformance containing the newly-created performance as well as the newly-started DI scope. Remarks This method includes the consequence/side-effect of creating a new dependency injection scope from the ServiceProvider associated with the specified Screenplay. That scope will be associated with the created performance and will be returned as part of the return of this method. Please use the Dispose() method the returned object when you are finished with the performance. This ensures that the DI scope and all associated resources (including the performance) will also be properly disposed-of. Exceptions ArgumentNullException If screenplay is null. ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, int) Executes the specified logic as a Performance, synchronously. public static void ExecuteAsPerformance(this Screenplay screenplay, Func<IServiceProvider, bool?> performanceLogic, IList<IdentifierAndName> namingHierarchy = null, int timeoutMiliseconds = 0) Parameters screenplay Screenplay The screenplay with which to execute the logic. performanceLogic Func<IServiceProvider, bool?> The logic to be executed by the performance. namingHierarchy IList<IdentifierAndName> An optional naming hierarchy used to identify the performance. timeoutMiliseconds int If set to a non-zero positive value, then the performance logic will be aborted after the specified timeout in milliseconds. Remarks This method is the primary entry point for beginning a Screenplay Performance. This method begins a new Dependency Injection Scope, and within that scope starts the performance, which executes the specified performance logic: performanceLogic. The return value from the performance logic should conform to the semantics of the parameter value passed to FinishPerformance(bool?). The namingHierarchy may be used to give the performance a name, so that its results (and subsequent report) may be identified. This parameter has the same semantics as NamingHierarchy. Use this method only if ExecuteAsPerformanceAsync(Func<IServiceProvider, CancellationToken, Task<bool?>>, IList<IdentifierAndName>, CancellationToken) is not viable. This method executes the logic asynchronously, as is the architecture of Screenplay, but then uses Wait(CancellationToken) to convert the asynchronous result into a synchronous one. If timeoutMiliseconds is not specified, or specified with a zero value then there will be no timeout applied to the performance's logic. If specified with a positive integer then the performance logic will be aborted if the specified timeout (in milliseconds) is exceeded. Please be aware that - as with Wait(CancellationToken) - if the timeout duration is exceded, the synchronous performance logic is not actually aborted. The thread on which this method is executed will stop waiting for the thread on which the performance logic is running, but the performance logic thread will still continue, typically to completion. All this means is that when the performance logic eventually does complete, its results are discarded because the Screenplay 'gave up waiting' for it. Exceptions ArgumentNullException If either screenplay or performanceLogic is null. ArgumentOutOfRangeException If timeoutMiliseconds is a negative number. See Also ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, CancellationToken) ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, CancellationToken) Executes the specified logic as a Performance, synchronously. public static void ExecuteAsPerformance(this Screenplay screenplay, Func<IServiceProvider, bool?> performanceLogic, IList<IdentifierAndName> namingHierarchy, CancellationToken cancellationToken) Parameters screenplay Screenplay The screenplay with which to execute the logic. performanceLogic Func<IServiceProvider, bool?> The logic to be executed by the performance. namingHierarchy IList<IdentifierAndName> A naming hierarchy used to identify the performance; if null then an empty name will be used. cancellationToken CancellationToken A cancellation token, which if cancelled will abort waiting for performanceLogic to complete. Remarks This method is the primary entry point for beginning a Screenplay Performance. This method begins a new Dependency Injection Scope, and within that scope starts the performance, which executes the specified performance logic: performanceLogic. The return value from the performance logic should conform to the semantics of the parameter value passed to FinishPerformance(bool?). The namingHierarchy may be used to give the performance a name, so that its results (and subsequent report) may be identified. This parameter has the same semantics as NamingHierarchy. Use this method only if ExecuteAsPerformanceAsync(Func<IServiceProvider, CancellationToken, Task<bool?>>, IList<IdentifierAndName>, CancellationToken) is not viable. This method executes the logic asynchronously, as is the architecture of Screenplay, but then uses Wait(CancellationToken) to convert the asynchronous result into a synchronous one. If cancellationToken is not specified then no cancellation/abort logic will be applied. If specified, and the token is cancelled, then the Screenplay will abort waiting for the performance logic to complete. Please be aware that - as with Wait(CancellationToken) - if the token is cancelled, the synchronous performance logic is not actually aborted. The thread on which this method is executed will stop waiting for the thread on which the performance logic is running, but the performance logic thread will still continue, typically to completion. All this means is that when the performance logic eventually does complete, its results are discarded because the Screenplay 'gave up waiting' for it. Exceptions ArgumentNullException If either screenplay or performanceLogic is null."
  },
  "api/CSF.Screenplay.ScreenplayLocator.html": {
    "href": "api/CSF.Screenplay.ScreenplayLocator.html",
    "title": "Class ScreenplayLocator | Screenplay docs",
    "keywords": "Class ScreenplayLocator Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll A small static service locator of sorts, dedicated to getting an appropriate instance of Screenplay for a specified test object. public static class ScreenplayLocator Inheritance object ScreenplayLocator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This type uses reflection to find the ScreenplayAssemblyAttribute which decorates the assembly in which the specified object (a test, a test method or the assembly itself) resides. It additionally caches the results in-memory to avoid repetitive reflection, only to retrieve the same results. Methods GetScreenplay(IMethodInfo) Gets a Screenplay instance from the specified test method. public static Screenplay GetScreenplay(IMethodInfo method) Parameters method IMethodInfo The test method for which to get a Screenplay object. Returns Screenplay The Screenplay object for the specified test method. Remarks This method makes use of the ScreenplayAssemblyAttribute which decorates the assembly in which the specified method was declared, to get a Screenplay object instance applicable to the test method. If the method's assembly is not decorated with the Screenplay assembly attribute then this method will raise an exception. Exceptions ArgumentNullException If method is null. ArgumentException If the method's assembly is null or is not decorated with ScreenplayAssemblyAttribute. GetScreenplay(ITest) Gets a Screenplay instance from the specified test. public static Screenplay GetScreenplay(ITest test) Parameters test ITest The test for which to get a Screenplay object. Returns Screenplay The Screenplay object for the specified test. Remarks This method makes use of the ScreenplayAssemblyAttribute which decorates the assembly in which the specified test's method was declared, to get a Screenplay object instance applicable to the test method. If the test's method's assembly is not decorated with the Screenplay assembly attribute then this method will raise an exception. Exceptions ArgumentNullException If test is null. ArgumentException If the test's method's assembly is null or is not decorated with ScreenplayAssemblyAttribute. GetScreenplay(Assembly) Gets a Screenplay instance from the specified Assembly. public static Screenplay GetScreenplay(Assembly assembly) Parameters assembly Assembly The test assembly for which to get a Screenplay object. Returns Screenplay The Screenplay object for the specified assembly. Remarks This method makes use of the ScreenplayAssemblyAttribute which decorates the assembly to get a Screenplay object instance for that assembly. If the specified assembly is not decorated with the Screenplay assembly attribute then this method will raise an exception. Exceptions ArgumentNullException If assembly is null. ArgumentException If the assembly is not decorated with ScreenplayAssemblyAttribute."
  },
  "api/CSF.Screenplay.ScreenplayPlugin.html": {
    "href": "api/CSF.Screenplay.ScreenplayPlugin.html",
    "title": "Class ScreenplayPlugin | Screenplay docs",
    "keywords": "Class ScreenplayPlugin Namespace CSF.Screenplay Assembly CSF.Screenplay.SpecFlowPlugin.dll The Screenplay plugin for SpecFlow. public class ScreenplayPlugin : IRuntimePlugin Inheritance object ScreenplayPlugin Implements IRuntimePlugin Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This plugin class is the test framework integration for SpecFlow. Crucially it adds the Screenplay architecture to the SpecFlow architecture. Becuase this plugin leverages the SpecFlow/BoDi IObjectContainer, it is likely incompatible with other plugins which integrate with third party Dependency Injection libraries. This may be easily worked-around, though. If you are using a third-party DI plugin then do not use this plugin. Instead use the AddScreenplay(IServiceCollection) method to add Screenplay to that third-party DI system, when customising the dependency registrations. Adding Screenplay in that way is equivalent to the work done by this plugin. If you wish to further customise the dependency injection, such as adding injectable services for abilities or implementations of IPersona, add them to the relevant DI container. When using SpecFlow's default BoDi container this is described in the following article https://docs.specflow.org/projects/specflow/en/latest/Bindings/Context-Injection.html#advanced-options. If using a third-party DI container then you should use that container's appropriate mechanism of adding services. Properties Screenplay Provides static access to the Screenplay instance. public static Screenplay Screenplay { get; } Property Value Screenplay Remarks This is required because the bindings for beginning/ending the Screenplay in ScreenplayBinding must be static: https://docs.specflow.org/projects/specflow/en/latest/Bindings/Hooks.html#supported-hook-attributes. Methods Initialize(RuntimePluginEvents, RuntimePluginParameters, UnitTestProviderConfiguration) public void Initialize(RuntimePluginEvents runtimePluginEvents, RuntimePluginParameters runtimePluginParameters, UnitTestProviderConfiguration unitTestProviderConfiguration) Parameters runtimePluginEvents RuntimePluginEvents runtimePluginParameters RuntimePluginParameters unitTestProviderConfiguration UnitTestProviderConfiguration"
  },
  "api/CSF.Screenplay.ScreenplayServiceCollectionExtensions.html": {
    "href": "api/CSF.Screenplay.ScreenplayServiceCollectionExtensions.html",
    "title": "Class ScreenplayServiceCollectionExtensions | Screenplay docs",
    "keywords": "Class ScreenplayServiceCollectionExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Extension methods for IServiceCollection relating to Screenplay. public static class ScreenplayServiceCollectionExtensions Inheritance object ScreenplayServiceCollectionExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddScreenplay(IServiceCollection) Adds the Screenplay framework to the specified service collection. public static IServiceCollection AddScreenplay(this IServiceCollection services) Parameters services IServiceCollection An IServiceCollection Returns IServiceCollection The service collection, so that calls may be chained Remarks Use this method to add Screenplay to an existing service collection; if you just want an instance of Screenplay and do not care for integrating it with a service collection of your own then consider the convenience method Create(Action<IServiceCollection>). Exceptions ArgumentNullException If services is null."
  },
  "api/CSF.Screenplay.ScreenplaySteps.html": {
    "href": "api/CSF.Screenplay.ScreenplaySteps.html",
    "title": "Class ScreenplaySteps | Screenplay docs",
    "keywords": "Class ScreenplaySteps Namespace CSF.Screenplay Assembly CSF.Screenplay.SpecFlowPlugin.dll A subclass of TechTalk.SpecFlow.Steps provided for convenience of SpecFlow 3.x users to avoid naming conflicts. public abstract class ScreenplaySteps : Steps, IContainerDependentObject Inheritance object Steps ScreenplaySteps Implements IContainerDependentObject Inherited Members Steps.AssertInitialized() Steps.TestRunner Steps.ScenarioContext Steps.FeatureContext Steps.TestThreadContext Steps.StepContext object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks In SpecFlow 3.x, the Steps class has three methods named Given, When & Then which can cause a naming conflict with the same-named methods of PerformanceStarter. If you using the performance starter in the recommended way, then the methods of these two types can become ambiguous and force the developer to write additional boilerplate which spoils the ease-of-comprehension for Screenplay-based test logic. This subclass of Steps provides a workaround to that situation. Instead of deriving from the SpecFlow Steps class and including using static CSF.Screenplay.PerformanceStarter; at the top of your source file, have your bindings derive from this class instead. This provides Given, When, Then methods which have the same functionality as those in PerformanceStarter but in a manner which will not cause a name-resolution conflict. Note that in SpecFlow 4.x and up, this problem is irrelevant; there is no gain in using this subclass over the using static technique. As noted here https://docs.specflow.org/projects/specflow/en/latest/Bindings/Calling-Steps-from-Step-Definitions.html and here https://github.com/SpecFlowOSS/SpecFlow/issues/1733 the Give, When & Then methods upon the SpecFlow Steps class were removed in v4.x. This means that the naming conflict won't be present and that there is no need for your bindings to derive from this class instead of the official Steps class. Indeed, Screenplay could be described as a specific implementation of the 'driver pattern', which is noted in the linked Github issue as a best-practice alternative to calling-steps-from-steps. Methods Given(Actor) Returns the actor instance, as an ICanPerformGiven, in order to perform precondition actions. public static ICanPerformGiven Given(Actor actor) Parameters actor Actor The actor. Returns ICanPerformGiven Remarks This method is equivalent to Given(Actor) but is provided as a convenience method in a subclass of TechTalk.SpecFlow.Steps to avoid method-name resolution conflicts. See the remarks on ScreenplaySteps for more info. Then(Actor) Returns the actor instance, as an ICanPerformThen, in order to get information which are required to make assertions that the scenario has completed successfully. public static ICanPerformThen Then(Actor actor) Parameters actor Actor The actor. Returns ICanPerformThen Remarks This method is equivalent to Then(Actor) but is provided as a convenience method in a subclass of TechTalk.SpecFlow.Steps to avoid method-name resolution conflicts. See the remarks on ScreenplaySteps for more info. When(Actor) Returns the actor instance, as an ICanPerformWhen, in order to perform actions which exercise the system under test. public static ICanPerformWhen When(Actor actor) Parameters actor Actor The actor. Returns ICanPerformWhen Remarks This method is equivalent to When(Actor) but is provided as a convenience method in a subclass of TechTalk.SpecFlow.Steps to avoid method-name resolution conflicts. See the remarks on ScreenplaySteps for more info."
  },
  "api/CSF.Screenplay.ServiceCollectionAdapter.html": {
    "href": "api/CSF.Screenplay.ServiceCollectionAdapter.html",
    "title": "Class ServiceCollectionAdapter | Screenplay docs",
    "keywords": "Class ServiceCollectionAdapter Namespace CSF.Screenplay Assembly CSF.Screenplay.SpecFlowPlugin.dll Adapter class which allows a SpecFlow/BoDi IObjectContainer to be used as an IServiceCollection. public class ServiceCollectionAdapter : IServiceCollection, IList<ServiceDescriptor>, ICollection<ServiceDescriptor>, IEnumerable<ServiceDescriptor>, IEnumerable Inheritance object ServiceCollectionAdapter Implements IServiceCollection IList<ServiceDescriptor> ICollection<ServiceDescriptor> IEnumerable<ServiceDescriptor> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods ScreenplayServiceCollectionExtensions.AddScreenplay(IServiceCollection) Remarks This adapter class is highly limited and supports only a tiny subset of IServiceCollection's functionality. For many methods, and the indexer for ServiceDescriptor, it will raise NotSupportedException. The only functionality supported is IsReadOnly and Add(ServiceDescriptor). Constructors ServiceCollectionAdapter(IObjectContainer) Initialises an instance of ServiceCollectionAdapter. public ServiceCollectionAdapter(IObjectContainer wrapped) Parameters wrapped IObjectContainer The BoDi object container Exceptions ArgumentNullException If wrapped is null. Properties Count Not supported, always returns zero. public int Count { get; } Property Value int IsReadOnly Partially supported, always returns false public bool IsReadOnly { get; } Property Value bool this[int] Not supported; always throws NotSupportedException. public ServiceDescriptor this[int index] { get; set; } Parameters index int Property Value ServiceDescriptor Exceptions NotSupportedException Always thrown Methods Add(ServiceDescriptor) Partially-supported, will add the specified service descriptor to the current object container. public void Add(ServiceDescriptor item) Parameters item ServiceDescriptor The service descriptor Remarks This method supports only transient or singleton services. If the Lifetime present on the item specified is Scoped then the service descriptor will not be added and will be silently ignored. In reality, the Specflow BoDi object container only really supports singleton services at this level. So, any services added as Transient will actually become singletons here. Whilst the BoDi container does support scoped services, they must be added directly to the scope instance and cannot be added in advance. Exceptions ArgumentNullException If item is null. ArgumentException If the item has a nullServiceType. Clear() Not supported; always throws NotSupportedException. public void Clear() Exceptions NotSupportedException Always thrown Contains(ServiceDescriptor) Not supported; always throws NotSupportedException. public bool Contains(ServiceDescriptor item) Parameters item ServiceDescriptor Returns bool Exceptions NotSupportedException Always thrown CopyTo(ServiceDescriptor[], int) Not supported; always throws NotSupportedException. public void CopyTo(ServiceDescriptor[] array, int arrayIndex) Parameters array ServiceDescriptor[] arrayIndex int Exceptions NotSupportedException Always thrown GetEnumerator() Not supported; always throws NotSupportedException. public IEnumerator<ServiceDescriptor> GetEnumerator() Returns IEnumerator<ServiceDescriptor> Exceptions NotSupportedException Always thrown IndexOf(ServiceDescriptor) Not supported; always throws NotSupportedException. public int IndexOf(ServiceDescriptor item) Parameters item ServiceDescriptor Returns int Exceptions NotSupportedException Always thrown Insert(int, ServiceDescriptor) Not supported; always throws NotSupportedException. public void Insert(int index, ServiceDescriptor item) Parameters index int item ServiceDescriptor Exceptions NotSupportedException Always thrown Remove(ServiceDescriptor) Not supported; always throws NotSupportedException. public bool Remove(ServiceDescriptor item) Parameters item ServiceDescriptor Returns bool Exceptions NotSupportedException Always thrown RemoveAt(int) Not supported; always throws NotSupportedException. public void RemoveAt(int index) Parameters index int Exceptions NotSupportedException Always thrown"
  },
  "api/CSF.Screenplay.ServiceProviderAdapter.html": {
    "href": "api/CSF.Screenplay.ServiceProviderAdapter.html",
    "title": "Class ServiceProviderAdapter | Screenplay docs",
    "keywords": "Class ServiceProviderAdapter Namespace CSF.Screenplay Assembly CSF.Screenplay.SpecFlowPlugin.dll Adapter class which allows a SpecFlow/BoDi IObjectContainer to be used as an IServiceProvider. public class ServiceProviderAdapter : IServiceProvider Inheritance object ServiceProviderAdapter Implements IServiceProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ServiceProviderAdapter(IObjectContainer) Initialises an instance of ServiceProviderAdapter. public ServiceProviderAdapter(IObjectContainer wrapped) Parameters wrapped IObjectContainer The BoDi object container Exceptions ArgumentNullException If wrapped is null. Methods GetService(Type) public object GetService(Type serviceType) Parameters serviceType Type Returns object"
  },
  "api/CSF.Screenplay.StageExtensions.html": {
    "href": "api/CSF.Screenplay.StageExtensions.html",
    "title": "Class StageExtensions | Screenplay docs",
    "keywords": "Class StageExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Extension methods for IStage. public static class StageExtensions Inheritance object StageExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Spotlight<TPersona>(IStage) Places an actor matching the specified persona into the spotlight, making them 'the current actor' on this stage. public static Actor Spotlight<TPersona>(this IStage stage) where TPersona : class, IPersona Parameters stage IStage The stage on which to spotlight the actor. Returns Actor The actor instance which was placed into the spotlight. Type Parameters TPersona A concrete type of IPersona from which to get an actor. Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the actor derived from the persona. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If actor indicated by the persona is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. When spotlighting a persona, the actor instance is retrieved from an ICast based upon that same persona. See GetActor(IPersona) for more information. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). This method is the recommended way of putting an actor based upon a persona in the spotlight, as it takes care of resolving the persona from dependency injection automatically. Exceptions ArgumentNullException If the actor is null."
  },
  "api/CSF.Screenplay.WebApis.Endpoint-1.html": {
    "href": "api/CSF.Screenplay.WebApis.Endpoint-1.html",
    "title": "Class Endpoint<TResult> | Screenplay docs",
    "keywords": "Class Endpoint<TResult> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll A Web API endpoint which has no expected request payload and which is expected to return a response body that exposes a strongly-typed object. public class Endpoint<TResult> : EndpointBase, IHasName Type Parameters TResult The type of object which is expected to be exposed by the HTTP response content Inheritance object EndpointBase Endpoint<TResult> Implements IHasName Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. The manner in which this endpoint exposes the strongly typed response object is undefined within the endpoint itself. It is down to a performable implementation to deserialize the result object from the HTTP response content. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should overrideGetHttpRequestMessageBuilder() with a method that calls the base implementation and then further manipulates the message builder before returning it. When using or deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors Endpoint(string, HttpMethod) Initializes a new instance of Endpoint<TResult> with a relative URI and an optional HTTP method. public Endpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Endpoint(Uri, HttpMethod) Initializes a new instance of Endpoint<TResult> with a URI and an optional HTTP method. public Endpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder() Gets a HttpRequestMessageBuilder from the state of the current instance. public virtual HttpRequestMessageBuilder<TResult> GetHttpRequestMessageBuilder() Returns HttpRequestMessageBuilder<TResult> An HTTP request message builder See Also EndpointBase Endpoint ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResponse> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.Endpoint.html": {
    "href": "api/CSF.Screenplay.WebApis.Endpoint.html",
    "title": "Class Endpoint | Screenplay docs",
    "keywords": "Class Endpoint Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll A Web API endpoint which has no expected request payload and which is not expected to return a response body. public class Endpoint : EndpointBase, IHasName Inheritance object EndpointBase Endpoint Implements IHasName Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should overrideGetHttpRequestMessageBuilder() with a method that calls the base implementation and then further manipulates the message builder before returning it. When using or deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors Endpoint(string, HttpMethod) Initializes a new instance of Endpoint with a relative URI and an optional HTTP method. public Endpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Endpoint(Uri, HttpMethod) Initializes a new instance of Endpoint with a URI and an optional HTTP method. public Endpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder() Gets a HttpRequestMessageBuilder from the state of the current instance. public virtual HttpRequestMessageBuilder GetHttpRequestMessageBuilder() Returns HttpRequestMessageBuilder An HTTP request message builder See Also EndpointBase Endpoint<TResult> ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResponse> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.EndpointBase.html": {
    "href": "api/CSF.Screenplay.WebApis.EndpointBase.html",
    "title": "Class EndpointBase | Screenplay docs",
    "keywords": "Class EndpointBase Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Abstract base class for types which represent web API endpoints. public abstract class EndpointBase : IHasName Inheritance object EndpointBase Implements IHasName Derived Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResponse> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks An endpoint is broadly a description of a Web API URL and the corresponding HTTP method (aka \"verb\") such as GET or POST. Instances of endpoints (types which derive from this base class) are typically stored as static readonly values in Screenplay-based logic. Here, they can be reused by tasks or other performables. Choose an appropriate implementation of this type based upon your intended use case. Endpoints which expect the API to return a strongly-typed result within the response body include a generic type parameter for the type of that result object. Also, endpoints which expect a request body: \"parameterized endpoints\" include a generic type parameter for the type of that request payload. There are also specialisations of these parameterized endpoint classes for those which expect an object serialized to JSON as their request payload. When writing custom endpoints, do not derive directly from this type. Usually one of the following pre-written endpoint types will be suitable for your use case. If not, pick the one which most closely matches your use-case and derive from that. Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResponse> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult> For more information, see the documentation article for using web APIs. Constructors EndpointBase(string, HttpMethod) Initializes a new instance of a type which derives from EndpointBase with a relative URI and an optional HTTP method. protected EndpointBase(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). EndpointBase(Uri, HttpMethod) Initializes a new instance of a type which derives from EndpointBase with a URI and an optional HTTP method. protected EndpointBase(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Properties Name Gets the human-readable name of the current object. public string Name { get; init; } Property Value string Remarks null is strongly discouraged here. All types which implement this interface should return a non-null response from this property. Timeout Gets or sets an optional timeout duration for requests built from this endpoint. public TimeSpan? Timeout { get; init; } Property Value TimeSpan? Remarks If this set to a non-null value, then the HTTP client used to make the request will include cancellation after an amount of time (equal to this timespan) has passed. This logic is handled within the MakeWebApiRequests action. If this action is not used then this timeout might not be honoured. The logic for honouring this timeout is contained within the performables which are shipped with this library: SendTheHttpRequest SendTheHttpRequestAndGetTheResponse<TResponse> SendTheHttpRequestAndGetJsonResponse<TResponse> If different performables are used to interact with the current endpoint then they must implement any timeout-related logic themselves, or else this value will not be honoured. Methods GetBaseHttpRequestMessageBuilder() Gets a HttpRequestMessageBuilder from the state of the current instance. protected HttpRequestMessageBuilder GetBaseHttpRequestMessageBuilder() Returns HttpRequestMessageBuilder An HTTP request message builder Remarks Derived types should make use of this method to get the request message builder from the state of this base class. They may then further-customize the message builder according to their own logic. The message builder returned from this method will respect the following state from the endpoint. The request URI specified via the constructor The request method, if specified via the constructor The Name of this endpoint The Timeout for requests to this endpoint, if specified GetBaseHttpRequestMessageBuilder<TResponse>() Gets a HttpRequestMessageBuilder<TResponse> from the state of the current instance, with information about the expected response type. protected HttpRequestMessageBuilder<TResponse> GetBaseHttpRequestMessageBuilder<TResponse>() Returns HttpRequestMessageBuilder<TResponse> An HTTP request message builder Type Parameters TResponse Remarks Derived types which expect a strongly-typed response from the API should make use of this method to get the request message builder from the state of this base class. They may then further-customize the message builder according to their own logic. The message builder returned from this method will respect the following state from the endpoint. The request URI specified via the constructor The request method, if specified via the constructor The Name of this endpoint The Timeout for requests to this endpoint, if specified See Also Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResponse> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.HttpRequestMessageBuilder-1.html": {
    "href": "api/CSF.Screenplay.WebApis.HttpRequestMessageBuilder-1.html",
    "title": "Class HttpRequestMessageBuilder<TResponse> | Screenplay docs",
    "keywords": "Class HttpRequestMessageBuilder<TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An object which can create an HttpRequestMessage for use with an HTTP client, which is expected to expose a response of a particular type. public record HttpRequestMessageBuilder<TResponse> : HttpRequestMessageBuilder, IHasName, IEquatable<HttpRequestMessageBuilder>, IEquatable<HttpRequestMessageBuilder<TResponse>> Type Parameters TResponse The type of the response expected from the endpoint to which this request would be sent. Inheritance object HttpRequestMessageBuilder HttpRequestMessageBuilder<TResponse> Implements IHasName IEquatable<HttpRequestMessageBuilder> IEquatable<HttpRequestMessageBuilder<TResponse>> Inherited Members HttpRequestMessageBuilder.RequestUri HttpRequestMessageBuilder.Method HttpRequestMessageBuilder.Content HttpRequestMessageBuilder.Version HttpRequestMessageBuilder.Headers HttpRequestMessageBuilder.Name HttpRequestMessageBuilder.Timeout HttpRequestMessageBuilder.VersionPolicy HttpRequestMessageBuilder.Options HttpRequestMessageBuilder.CreateRequestMessage() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Please note that this type differs in form depending upon the .NET version under which it is consumed. If consuming this type from logic which targets .NET Standard 2.0 or .NET Framework 4.6.2 then this type is a class. In that scenario its properties are mutable and the developer should take care to ensure that they do not mutate/alter its state inadvertently. Developers should ensure that they manually copy the state from the current instance into a new instance instead of modifying an existing instance. In these target frameworks, a Clone method has been provided to assist with this. When consuming this from .NET 5 or higher, this type is instead a record and is immutable by design. All properties are init-only. Additionally, in .NET 5+, some additional properties are available, supporting features of HttpRequestMessage which are unavailable in lower .NET versions. When using .NET 5, developers may use nondestructive mutation with the with keyword/expression to create a copy of the current instance but with some differences. This difference between this type and its non-generic counterpart is that this type includes generic information about the expected response type. This can aid subsequent type-safety in consuming logic."
  },
  "api/CSF.Screenplay.WebApis.HttpRequestMessageBuilder.html": {
    "href": "api/CSF.Screenplay.WebApis.HttpRequestMessageBuilder.html",
    "title": "Class HttpRequestMessageBuilder | Screenplay docs",
    "keywords": "Class HttpRequestMessageBuilder Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An object which can create an HttpRequestMessage for use with an HTTP client. public record HttpRequestMessageBuilder : IHasName, IEquatable<HttpRequestMessageBuilder> Inheritance object HttpRequestMessageBuilder Implements IHasName IEquatable<HttpRequestMessageBuilder> Derived HttpRequestMessageBuilder<TResponse> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Please note that this type differs in form depending upon the .NET version under which it is consumed. If consuming this type from logic which targets .NET Standard 2.0 or .NET Framework 4.6.2 then this type is a class. In that scenario its properties are mutable and the developer should take care to ensure that they do not mutate/alter its state inadvertently. Developers should ensure that they manually copy the state from the current instance into a new instance instead of modifying an existing instance. In these target frameworks, a Clone method has been provided to assist with this. When consuming this from .NET 5 or higher, this type is instead a record and is immutable by design. All properties are init-only. Additionally, in .NET 5+, some additional properties are available, supporting features of HttpRequestMessage which are unavailable in lower .NET versions. When using .NET 5, developers may use nondestructive mutation with the with keyword/expression to create a copy of the current instance but with some differences. Properties Content Gets or sets the content which will be sent with the request: the request body. public HttpContent Content { get; init; } Property Value HttpContent Headers Gets or sets the HTTP headers which will be sent with the request, corresponding to Headers. public NameValueRecordCollection<string, string> Headers { get; init; } Property Value NameValueRecordCollection<string, string> Method Gets or sets the HTTP method (aka \"verb\") which shall be used to send the request. public HttpMethod Method { get; init; } Property Value HttpMethod Name Gets the human-readable name of the current object. public string Name { get; init; } Property Value string Remarks null is strongly discouraged here. All types which implement this interface should return a non-null response from this property. Options Gets or sets the HTTP web request options, corresponding to Options. public NameValueRecordCollection<string, object> Options { get; init; } Property Value NameValueRecordCollection<string, object> Remarks Note that this property is supported only for .NET 5 and above. It is unavailable in lower .NET versions, including .NET Standard and .NET Framework. RequestUri Gets or sets the Uri to which the HTTP request shall be sent. public Uri RequestUri { get; init; } Property Value Uri Timeout Gets or sets an optional timeout duration for requests built from this builder. public TimeSpan? Timeout { get; init; } Property Value TimeSpan? Remarks If this set to a non-null value, then the HTTP client used to make the request will include cancellation after an amount of time (equal to this timespan) has passed. This logic is handled within the MakeWebApiRequests action. If this action is not used then this timeout might not be honoured. Version Gets or sets the HTTP version which shall be used by the message. public Version Version { get; init; } Property Value Version Remarks The documentation for the Version property notes that it would default to 2.0 for .NET Core 2.1 or 2.2, and defaults to 1.1 for all other versions of .NET or .NET Framework. This property will always default to 1.1 regardless of the target framework. VersionPolicy Gets or sets the HTTP version policy, corresponding to VersionPolicy. public HttpVersionPolicy VersionPolicy { get; init; } Property Value HttpVersionPolicy Remarks Note that this property is supported only for .NET 5 and above. It is unavailable in lower .NET versions, including .NET Standard and .NET Framework. Methods CreateRequestMessage() Creates and returns an HTTP request message. public HttpRequestMessage CreateRequestMessage() Returns HttpRequestMessage An HTTP request message Remarks The request message is typically created from the state of the current object instance. Multiple usages of this method must create a new request message each time. Unless some state has been altered between usages, though, each of these messages is likely to have the same data/property values. If the state of the current instance does not specify a Method; IE the method is null, then Get will be used."
  },
  "api/CSF.Screenplay.WebApis.HttpResponseMessageAndResponseType-1.html": {
    "href": "api/CSF.Screenplay.WebApis.HttpResponseMessageAndResponseType-1.html",
    "title": "Class HttpResponseMessageAndResponseType<TResponse> | Screenplay docs",
    "keywords": "Class HttpResponseMessageAndResponseType<TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Wraps an HttpResponseMessage but also provides information about the expected response type from that message. public class HttpResponseMessageAndResponseType<TResponse> Type Parameters TResponse The expected response type. Inheritance object HttpResponseMessageAndResponseType<TResponse> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HttpResponseMessageAndResponseType(HttpResponseMessage) Initializes a new instance of HttpResponseMessageAndResponseType<TResponse>. public HttpResponseMessageAndResponseType(HttpResponseMessage responseMessage) Parameters responseMessage HttpResponseMessage The HTTP response message. Exceptions ArgumentNullException If responseMessage is null. Properties ResponseMessage Gets the HTTP response message. public HttpResponseMessage ResponseMessage { get; } Property Value HttpResponseMessage"
  },
  "api/CSF.Screenplay.WebApis.JsonEndpoint-1.html": {
    "href": "api/CSF.Screenplay.WebApis.JsonEndpoint-1.html",
    "title": "Class JsonEndpoint<TParameters> | Screenplay docs",
    "keywords": "Class JsonEndpoint<TParameters> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Base type for a Web API endpoint which accepts a request payload in the form of a strongly typed object serialized to JSON string, but which is not expected to return a response body. public class JsonEndpoint<TParameters> : ParameterizedEndpoint<TParameters>, IHasName Type Parameters TParameters The type of the parameters object which is required to create an HTTP request message Inheritance object EndpointBase ParameterizedEndpoint<TParameters> JsonEndpoint<TParameters> Implements IHasName Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should overrideGetHttpRequestMessageBuilder(TParameters) with a method that calls the base implementation and then further manipulates the message builder before returning it. When deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors JsonEndpoint(string, HttpMethod) Initializes a new instance of JsonEndpoint<TParameters> with a relative URI and an optional HTTP method. public JsonEndpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). JsonEndpoint(Uri, HttpMethod) Initializes a new instance of JsonEndpoint<TParameters> with a URI and an optional HTTP method. public JsonEndpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder(TParameters) Gets a HttpRequestMessageBuilder from the state of the current instance and the specified parameters value. public override HttpRequestMessageBuilder GetHttpRequestMessageBuilder(TParameters parameters) Parameters parameters TParameters The parameters required to create an HTTP request builder Returns HttpRequestMessageBuilder An HTTP request message builder Remarks This method serializes the parameters value into a JSON string and sets it into the HTTP request content: Content. See Also EndpointBase Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters, TResponse> ParameterizedEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.JsonEndpoint-2.html": {
    "href": "api/CSF.Screenplay.WebApis.JsonEndpoint-2.html",
    "title": "Class JsonEndpoint<TParameters, TResult> | Screenplay docs",
    "keywords": "Class JsonEndpoint<TParameters, TResult> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Base type for a Web API endpoint which accepts a request payload in the form of a strongly typed object serialized to JSON string, and which is expected to return a response body that exposes a strongly-typed object. public class JsonEndpoint<TParameters, TResult> : ParameterizedEndpoint<TParameters, TResult>, IHasName Type Parameters TParameters The type of the parameters object which is required to create an HTTP request message TResult The type of response that the endpoint is expected to return. Inheritance object EndpointBase ParameterizedEndpoint<TParameters, TResult> JsonEndpoint<TParameters, TResult> Implements IHasName Inherited Members ParameterizedEndpoint<TParameters, TResult>.GetHttpRequestMessageBuilder(TParameters) EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. The manner in which this endpoint exposes the strongly typed response object is undefined within the endpoint itself. It is down to a performable implementation to deserialize the result object from the HTTP response content. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should overrideGetHttpRequestMessageBuilder(TParameters) with a method that calls the base implementation and then further manipulates the message builder before returning it. When deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors JsonEndpoint(string, HttpMethod) Initializes a new instance of JsonEndpoint<TParameters, TResult> with a relative URI and an optional HTTP method. public JsonEndpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). JsonEndpoint(Uri, HttpMethod) Initializes a new instance of JsonEndpoint<TParameters, TResult> with a URI and an optional HTTP method. public JsonEndpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder(TParameters) Gets a HttpRequestMessageBuilder<TResponse> from the state of the current instance and the specified parameters value. public override HttpRequestMessageBuilder<TResult> GetHttpRequestMessageBuilder(TParameters parameters) Parameters parameters TParameters The parameters required to create an HTTP request builder Returns HttpRequestMessageBuilder<TResult> An HTTP request message builder Remarks This method serializes the parameters value into a JSON string and sets it into the HTTP request content: Content. See Also EndpointBase Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters, TResponse> ParameterizedEndpoint<TParameters> JsonEndpoint<TParameters>"
  },
  "api/CSF.Screenplay.WebApis.MakeWebApiRequests.html": {
    "href": "api/CSF.Screenplay.WebApis.MakeWebApiRequests.html",
    "title": "Class MakeWebApiRequests | Screenplay docs",
    "keywords": "Class MakeWebApiRequests Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An ability class which allows Actors to make HTTP web API requests using HttpClient. public sealed class MakeWebApiRequests : IDisposable Inheritance object MakeWebApiRequests Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties DefaultClient Gets or sets the HTTP client, for scenarios in which the actor needs to use a single client. public HttpClient DefaultClient { get; set; } Property Value HttpClient Remarks If the actor needs to know about more than one HTTP client, then consider using the indexer instead, which allows storage of more than one client, using arbitrary names. this[string] Gets or sets an HTTP client with a specified name. public HttpClient this[string name] { get; set; } Parameters name string The name of the HTTP client for which this instance is getting or setting. Property Value HttpClient An HTTP client associated with the specified name, or null reference if no HTTP client has been configured for that name. Remarks Use this indexer if an actor needs to manage more than one HTTP client. The key to this index - a name - is completely arbitrary and may mean whatever your needs require. Names must not be null and should not be empty or whitespace-only strings. The name DefaultClient is reserved for the value of DefaultClient. If the actor needs to use only a single HTTP client then yoy may find the DefaultClient property easier to use, instead of this indexer. Exceptions ArgumentNullException If name is null. Methods AddClient(string, string) Adds a new HTTP client to the current instance, with an optional base URI and client name. public void AddClient(string baseUri = null, string clientName = null) Parameters baseUri string Optional, the base URI to which requests should be sent clientName string Optional, the name of the client. If omitted then the new client will be the DefaultClient Remarks This method is a shorthand for adding a new item to either DefaultClient or the class indexer. It allows the convenient configuration of a new HttpClient with just a base URI to which requests should be sent. Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() GetClient(string) Gets an HTTP client with the specified name. public HttpClient GetClient(string clientName = null) Parameters clientName string An optional client name, if omitted then the default client will be returned. Returns HttpClient An HTTP client Remarks If clientName is null then the DefaultClient will be returned. Exceptions InvalidOperationException If clientName is specified & non-null but the current instance has no client of that name."
  },
  "api/CSF.Screenplay.WebApis.NameValueRecordCollection-2.html": {
    "href": "api/CSF.Screenplay.WebApis.NameValueRecordCollection-2.html",
    "title": "Class NameValueRecordCollection<TKey, TValue> | Screenplay docs",
    "keywords": "Class NameValueRecordCollection<TKey, TValue> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll A simple name/value collection with an indexer, backed by a Dictionary<TKey, TValue>. public sealed class NameValueRecordCollection<TKey, TValue> : IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IEquatable<NameValueRecordCollection<TKey, TValue>> where TKey : notnull where TValue : class Type Parameters TKey The key type TValue The value type Inheritance object NameValueRecordCollection<TKey, TValue> Implements IEnumerable<KeyValuePair<TKey, TValue>> IEnumerable IEquatable<NameValueRecordCollection<TKey, TValue>> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Please note that this type differs in form depending upon the .NET version under which it is consumed. If consuming this type from logic which targets .NET Standard 2.0 or .NET Framework 4.6.2 then this type is mutable. In that scenario the developer should take care to ensure that they do not mutate/alter its state inadvertently. Developers should ensure that they manually copy the state from the current instance into a new instance instead of modifying an existing instance. In these target frameworks, a Clone method has been provided to assist with this. When consuming this from .NET 5 or higher, this type is immutable by design; the indexer is init-only. When using .NET 5, developers may use nondestructive mutation by using either the WithItem or WithItems methods to create a copy of the current instance, but with modified items. Constructors NameValueRecordCollection() Initialises a new instance of NameValueRecordCollection<TKey, TValue>. public NameValueRecordCollection() Properties this[TKey] Gets or sets the values within this collection, via an indexer. public TValue? this[TKey key] { get; init; } Parameters key TKey The key Property Value TValue The value Examples In order to set this property, particularly when using .NET 5 or higher (when this type is a record rather than a class, and this indexer is immutable), use the following syntax. var nvr = new NameValueRecordCollection<int,string> { [7] = \"seven\", [9] = \"nine\", [13] = \"thirteen\", } Remarks null may not be stored in this collection as a value. An attempt to store a null value will result in the removal of the item at the specified key. As a type which is intended to be immutable, it goes without saying that ideally both TKey and TValue should ideally also be immutable types. If they are not, developers must be careful to avoid mutating them, as doing so could adulterate the state of the current instance. Methods Equals(NameValueRecordCollection<TKey, TValue>?) Indicates whether the current object is equal to another object of the same type. public bool Equals(NameValueRecordCollection<TKey, TValue>? other) Parameters other NameValueRecordCollection<TKey, TValue> An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetEnumerator() Returns an enumerator that iterates through the collection. public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() Returns IEnumerator<KeyValuePair<TKey, TValue>> An enumerator that can be used to iterate through the collection. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. WithItem(TKey, TValue?) Gets a clone (shallow copy) of the current NameValueRecordCollection<TKey, TValue> containing the same items, as well as the specified item. public NameValueRecordCollection<TKey, TValue> WithItem(TKey key, TValue? value) Parameters key TKey The key at which to add, remove or update an item value TValue The value to store for the item, or null which indicates that the item is to be removed. Returns NameValueRecordCollection<TKey, TValue> A copy of the current instance, with a single item added, removed or altered in that copied instance. Remarks As with the indexer, if the value is null then this will result in the removal of the item in the returned copy. WithItems(IEnumerable<KeyValuePair<TKey, TValue?>>) Gets a clone (shallow copy) of the current NameValueRecordCollection<TKey, TValue> containing the same items, as well as the specified items. public NameValueRecordCollection<TKey, TValue> WithItems(IEnumerable<KeyValuePair<TKey, TValue?>> items) Parameters items IEnumerable<KeyValuePair<TKey, TValue>> A collection of key/value pairs, indicating the keys & values to add, remove or alter in the copied instance. Returns NameValueRecordCollection<TKey, TValue> A copy of the current instance, with the specified items added, removed or altered. Remarks As with indexer, if any value is null then this will result in the removal of the corresponding item in the returned copy."
  },
  "api/CSF.Screenplay.WebApis.ParameterizedEndpoint-1.html": {
    "href": "api/CSF.Screenplay.WebApis.ParameterizedEndpoint-1.html",
    "title": "Class ParameterizedEndpoint<TParameters> | Screenplay docs",
    "keywords": "Class ParameterizedEndpoint<TParameters> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Base type for a Web API endpoint which has a strongly-typed request payload but which is not expected to return a response body. public abstract class ParameterizedEndpoint<TParameters> : EndpointBase, IHasName Type Parameters TParameters The type of the parameters object which is required to create an HTTP request message Inheritance object EndpointBase ParameterizedEndpoint<TParameters> Implements IHasName Derived JsonEndpoint<TParameters> Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should overrideGetHttpRequestMessageBuilder(TParameters) with a method that calls the base implementation and then further manipulates the message builder before returning it. This particular class may only be used as a base type for specialized implementations. Implementing types must provide an implementation of GetHttpRequestMessageBuilder(TParameters) which includes whatever logic is required to serialize the parameters value into the HTTP request. For an example implementation which serializes the parameters as a JSON string, see JsonEndpoint<TParameters>. When deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors ParameterizedEndpoint(string, HttpMethod) Initializes a new instance of ParameterizedEndpoint<TParameters> with a relative URI and an optional HTTP method. protected ParameterizedEndpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). ParameterizedEndpoint(Uri, HttpMethod) Initializes a new instance of ParameterizedEndpoint<TParameters> with a URI and an optional HTTP method. protected ParameterizedEndpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder(TParameters) Gets a HttpRequestMessageBuilder from the state of the current instance and the specified parameters value. public abstract HttpRequestMessageBuilder GetHttpRequestMessageBuilder(TParameters parameters) Parameters parameters TParameters The parameters required to create an HTTP request builder Returns HttpRequestMessageBuilder An HTTP request message builder Remarks When overriding/implementing this method use GetBaseHttpRequestMessageBuilder() to get a builder from the base class. You should then further customize that builder instance according to the appropriate logic for this implementation, such as to add the parameter value. See Also EndpointBase Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters, TResponse> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.ParameterizedEndpoint-2.html": {
    "href": "api/CSF.Screenplay.WebApis.ParameterizedEndpoint-2.html",
    "title": "Class ParameterizedEndpoint<TParameters, TResponse> | Screenplay docs",
    "keywords": "Class ParameterizedEndpoint<TParameters, TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Base type for a Web API endpoint which has a strongly-typed request payload and which is expected to return a response body that exposes a strongly-typed object. public abstract class ParameterizedEndpoint<TParameters, TResponse> : EndpointBase, IHasName Type Parameters TParameters The type of the parameters object which is required to create an HTTP request message TResponse The type of response that the endpoint is expected to return. Inheritance object EndpointBase ParameterizedEndpoint<TParameters, TResponse> Implements IHasName Derived JsonEndpoint<TParameters, TResult> Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. The manner in which this endpoint exposes the strongly typed response object is undefined within the endpoint itself. It is down to a performable implementation to deserialize the result object from the HTTP response content. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should overrideGetHttpRequestMessageBuilder(TParameters) with a method that calls the base implementation and then further manipulates the message builder before returning it. This particular class may only be used as a base type for specialized implementations. Implementing types must provide an implementation of GetHttpRequestMessageBuilder(TParameters) which includes whatever logic is required to serialize the parameters value into the HTTP request. For an example implementation which serializes the parameters as a JSON string, see JsonEndpoint<TParameters, TResult>. When deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors ParameterizedEndpoint(string, HttpMethod) Initializes a new instance of ParameterizedEndpoint<TParameters, TResponse> with a relative URI and an optional HTTP method. protected ParameterizedEndpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). ParameterizedEndpoint(Uri, HttpMethod) Initializes a new instance of ParameterizedEndpoint<TParameters, TResponse> with a URI and an optional HTTP method. protected ParameterizedEndpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder(TParameters) Gets a HttpRequestMessageBuilder<TResponse> from the state of the current instance and the specified parameters value. public abstract HttpRequestMessageBuilder<TResponse> GetHttpRequestMessageBuilder(TParameters parameters) Parameters parameters TParameters The parameters required to create an HTTP request builder Returns HttpRequestMessageBuilder<TResponse> An HTTP request message builder Remarks When overriding/implementing this method use GetBaseHttpRequestMessageBuilder<TResponse>() to get a builder from the base class. You should then further customize that builder instance according to the appropriate logic for this implementation, such as to add the parameter value. See Also EndpointBase Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.SendTheHttpRequest.html": {
    "href": "api/CSF.Screenplay.WebApis.SendTheHttpRequest.html",
    "title": "Class SendTheHttpRequest | Screenplay docs",
    "keywords": "Class SendTheHttpRequest Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An action which creates & sends an HTTP request using the specification within an HttpRequestMessageBuilder. public class SendTheHttpRequest : IPerformableWithResult<HttpResponseMessage>, ICanReport Inheritance object SendTheHttpRequest Implements IPerformableWithResult<HttpResponseMessage> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SendTheHttpRequest(HttpRequestMessageBuilder, string) Initializes a new instance of SendTheHttpRequest. public SendTheHttpRequest(HttpRequestMessageBuilder messageBuilder, string clientName = null) Parameters messageBuilder HttpRequestMessageBuilder The HTTP request message builder. clientName string An optional client name, when actors must maintain more than one HTTP client. Exceptions ArgumentNullException If messageBuilder is null. Methods GetReportFragment(IHasName) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public string GetReportFragment(IHasName actor) Parameters actor IHasName An actor for whom to write the report fragment Returns string A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<HttpResponseMessage> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<HttpResponseMessage> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.WebApis.SendTheHttpRequestAndGetJsonResponse-1.html": {
    "href": "api/CSF.Screenplay.WebApis.SendTheHttpRequestAndGetJsonResponse-1.html",
    "title": "Class SendTheHttpRequestAndGetJsonResponse<TResponse> | Screenplay docs",
    "keywords": "Class SendTheHttpRequestAndGetJsonResponse<TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An action which creates & sends an HTTP request, using the specification within an HttpRequestMessageBuilder<TResponse> and returns a strongly-typed result deserialized from a JSON HTTP response. public class SendTheHttpRequestAndGetJsonResponse<TResponse> : IPerformableWithResult<TResponse>, ICanReport Type Parameters TResponse Inheritance object SendTheHttpRequestAndGetJsonResponse<TResponse> Implements IPerformableWithResult<TResponse> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SendTheHttpRequestAndGetJsonResponse(HttpRequestMessageBuilder<TResponse>, string) Initializes a new instance of SendTheHttpRequestAndGetJsonResponse<TResponse>. public SendTheHttpRequestAndGetJsonResponse(HttpRequestMessageBuilder<TResponse> messageBuilder, string clientName = null) Parameters messageBuilder HttpRequestMessageBuilder<TResponse> The HTTP request message builder. clientName string An optional client name, when actors must maintain more than one HTTP client. Exceptions ArgumentNullException If messageBuilder is null. Methods GetReportFragment(IHasName) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public string GetReportFragment(IHasName actor) Parameters actor IHasName An actor for whom to write the report fragment Returns string A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<TResponse> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TResponse> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.WebApis.SendTheHttpRequestAndGetTheResponse-1.html": {
    "href": "api/CSF.Screenplay.WebApis.SendTheHttpRequestAndGetTheResponse-1.html",
    "title": "Class SendTheHttpRequestAndGetTheResponse<TResponse> | Screenplay docs",
    "keywords": "Class SendTheHttpRequestAndGetTheResponse<TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An action which creates & sends an HTTP request using the specification within an HttpRequestMessageBuilder<TResponse> and returns a result which preserves the intended response type. public class SendTheHttpRequestAndGetTheResponse<TResponse> : IPerformableWithResult<HttpResponseMessageAndResponseType<TResponse>>, ICanReport Type Parameters TResponse Inheritance object SendTheHttpRequestAndGetTheResponse<TResponse> Implements IPerformableWithResult<HttpResponseMessageAndResponseType<TResponse>> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SendTheHttpRequestAndGetTheResponse(HttpRequestMessageBuilder<TResponse>, string) Initializes a new instance of SendTheHttpRequestAndGetTheResponse<TResponse>. public SendTheHttpRequestAndGetTheResponse(HttpRequestMessageBuilder<TResponse> messageBuilder, string clientName = null) Parameters messageBuilder HttpRequestMessageBuilder<TResponse> The HTTP request message builder. clientName string An optional client name, when actors must maintain more than one HTTP client. Exceptions ArgumentNullException If messageBuilder is null. Methods GetReportFragment(IHasName) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public string GetReportFragment(IHasName actor) Parameters actor IHasName An actor for whom to write the report fragment Returns string A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<HttpResponseMessageAndResponseType<TResponse>> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<HttpResponseMessageAndResponseType<TResponse>> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.WebApis.WebApiBuilder.html": {
    "href": "api/CSF.Screenplay.WebApis.WebApiBuilder.html",
    "title": "Class WebApiBuilder | Screenplay docs",
    "keywords": "Class WebApiBuilder Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll A builder for the performables SendTheHttpRequest and SendTheHttpRequestAndGetTheResponse<TResponse>. public static class WebApiBuilder Inheritance object WebApiBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetTheJsonResult<TResponse>(Endpoint<TResponse>, string) Gets an instance of SendTheHttpRequestAndGetJsonResponse<TResponse> from an endpoint and optional client name. public static SendTheHttpRequestAndGetJsonResponse<TResponse> GetTheJsonResult<TResponse>(Endpoint<TResponse> endpoint, string clientName = null) Parameters endpoint Endpoint<TResponse> The endpoint from which to get an action. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequestAndGetJsonResponse<TResponse> A performable that will send the HTTP request and await its result and deserialize that result as . Type Parameters TResponse The type of the expected result value GetTheJsonResult<TParameters, TResponse>(ParameterizedEndpoint<TParameters, TResponse>, TParameters, string) Gets an instance of SendTheHttpRequestAndGetJsonResponse<TResponse> from a parameterized endpoint, its parameters and an optional client name. public static SendTheHttpRequestAndGetJsonResponse<TResponse> GetTheJsonResult<TParameters, TResponse>(ParameterizedEndpoint<TParameters, TResponse> endpoint, TParameters parameters, string clientName = null) Parameters endpoint ParameterizedEndpoint<TParameters, TResponse> The endpoint from which to get an action. parameters TParameters The parameters required by the endpoint. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequestAndGetJsonResponse<TResponse> A performable that will send the HTTP request and await its result. Type Parameters TParameters The type of the parameters expected by the endpoint TResponse The type of the expected result value SendTheHttpRequest(Endpoint, string) Gets an instance of SendTheHttpRequest from an endpoint and optional client name. public static SendTheHttpRequest SendTheHttpRequest(Endpoint endpoint, string clientName = null) Parameters endpoint Endpoint The endpoint from which to get an action. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequest A performable that will send the HTTP request and await its result. SendTheHttpRequest<TResponse>(Endpoint<TResponse>, string) Gets an instance of SendTheHttpRequestAndGetTheResponse<TResponse> from an endpoint and optional client name. public static SendTheHttpRequestAndGetTheResponse<TResponse> SendTheHttpRequest<TResponse>(Endpoint<TResponse> endpoint, string clientName = null) Parameters endpoint Endpoint<TResponse> The endpoint from which to get an action. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequestAndGetTheResponse<TResponse> A performable that will send the HTTP request and await its result. Type Parameters TResponse The type of the expected result value SendTheHttpRequest<TParameters>(ParameterizedEndpoint<TParameters>, TParameters, string) Gets an instance of SendTheHttpRequest from a parameterized endpoint, its parameters and an optional client name. public static SendTheHttpRequest SendTheHttpRequest<TParameters>(ParameterizedEndpoint<TParameters> endpoint, TParameters parameters, string clientName = null) Parameters endpoint ParameterizedEndpoint<TParameters> The endpoint from which to get an action. parameters TParameters The parameters required by the endpoint. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequest A performable that will send the HTTP request and await its result. Type Parameters TParameters The type of the parameters expected by the endpoint SendTheHttpRequest<TParameters, TResponse>(ParameterizedEndpoint<TParameters, TResponse>, TParameters, string) Gets an instance of SendTheHttpRequestAndGetTheResponse<TResponse> from a parameterized endpoint, its parameters and an optional client name. public static SendTheHttpRequestAndGetTheResponse<TResponse> SendTheHttpRequest<TParameters, TResponse>(ParameterizedEndpoint<TParameters, TResponse> endpoint, TParameters parameters, string clientName = null) Parameters endpoint ParameterizedEndpoint<TParameters, TResponse> The endpoint from which to get an action. parameters TParameters The parameters required by the endpoint. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequestAndGetTheResponse<TResponse> A performable that will send the HTTP request and await its result. Type Parameters TParameters The type of the parameters expected by the endpoint TResponse The type of the expected result value"
  },
  "api/CSF.Screenplay.WebApis.html": {
    "href": "api/CSF.Screenplay.WebApis.html",
    "title": "Namespace CSF.Screenplay.WebApis | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay.WebApis Classes Endpoint A Web API endpoint which has no expected request payload and which is not expected to return a response body. EndpointBase Abstract base class for types which represent web API endpoints. Endpoint<TResult> A Web API endpoint which has no expected request payload and which is expected to return a response body that exposes a strongly-typed object. HttpRequestMessageBuilder An object which can create an HttpRequestMessage for use with an HTTP client. HttpRequestMessageBuilder<TResponse> An object which can create an HttpRequestMessage for use with an HTTP client, which is expected to expose a response of a particular type. HttpResponseMessageAndResponseType<TResponse> Wraps an HttpResponseMessage but also provides information about the expected response type from that message. JsonEndpoint<TParameters> Base type for a Web API endpoint which accepts a request payload in the form of a strongly typed object serialized to JSON string, but which is not expected to return a response body. JsonEndpoint<TParameters, TResult> Base type for a Web API endpoint which accepts a request payload in the form of a strongly typed object serialized to JSON string, and which is expected to return a response body that exposes a strongly-typed object. MakeWebApiRequests An ability class which allows Actors to make HTTP web API requests using HttpClient. NameValueRecordCollection<TKey, TValue> A simple name/value collection with an indexer, backed by a Dictionary<TKey, TValue>. ParameterizedEndpoint<TParameters> Base type for a Web API endpoint which has a strongly-typed request payload but which is not expected to return a response body. ParameterizedEndpoint<TParameters, TResponse> Base type for a Web API endpoint which has a strongly-typed request payload and which is expected to return a response body that exposes a strongly-typed object. SendTheHttpRequest An action which creates & sends an HTTP request using the specification within an HttpRequestMessageBuilder. SendTheHttpRequestAndGetJsonResponse<TResponse> An action which creates & sends an HTTP request, using the specification within an HttpRequestMessageBuilder<TResponse> and returns a strongly-typed result deserialized from a JSON HTTP response. SendTheHttpRequestAndGetTheResponse<TResponse> An action which creates & sends an HTTP request using the specification within an HttpRequestMessageBuilder<TResponse> and returns a result which preserves the intended response type. WebApiBuilder A builder for the performables SendTheHttpRequest and SendTheHttpRequestAndGetTheResponse<TResponse>."
  },
  "api/CSF.Screenplay.html": {
    "href": "api/CSF.Screenplay.html",
    "title": "Namespace CSF.Screenplay | Screenplay docs",
    "keywords": "Namespace CSF.Screenplay Classes Actor A representation of an autonomous, or at least seemingly-autonomous, person or system which directs the events of a IPerformance. ActorExtensions Extension methods for actor types CastExtensions Extension methods for ICast. DefaultStrings An object which provides default human readable strings PerformableExtensions Extension methods for performable types Performance Primary implementation type of IPerformance. PerformanceStarter Helper class for beginning the functionality of a Screenplay IPerformance from your own logic, using a fluent interface ScopeAndPerformance A model which contains both an IPerformance and a dependency injection IServiceScope. Screenplay An object which represents a complete execution of Screenplay logic, which should include one or more Performance instances. ScreenplayAssemblyAttribute An attribute used to mark an assembly which contains Screenplay-based tests. ScreenplayAttribute Applied to a test method, indicates that decorated test is a Screenplay test. ScreenplayBinding SpecFlow binding which uses hooks to coordinate the relevant Screenplay & IPerformance event invokers. ScreenplayExtensions Extension methods for the Screenplay type. ScreenplayLocator A small static service locator of sorts, dedicated to getting an appropriate instance of Screenplay for a specified test object. ScreenplayPlugin The Screenplay plugin for SpecFlow. ScreenplayServiceCollectionExtensions Extension methods for IServiceCollection relating to Screenplay. ScreenplaySteps A subclass of TechTalk.SpecFlow.Steps provided for convenience of SpecFlow 3.x users to avoid naming conflicts. ServiceCollectionAdapter Adapter class which allows a SpecFlow/BoDi IObjectContainer to be used as an IServiceCollection. ServiceProviderAdapter Adapter class which allows a SpecFlow/BoDi IObjectContainer to be used as an IServiceProvider. StageExtensions Extension methods for IStage. Interfaces ICanPerform An actor which may perform in the Screenplay. ICanReport A type which can provide a human-readable report fragment when it is used in a IPerformance. ICast A combined registry and factory for Actor instances, useful when coordinating multiple actors across a IPerformance IGetsScreenplay An object which can fully configure and get a Screenplay instance. IHasAbilities An object which has & is able to gain abilities. IHasName A part of a Screenplay performance which has a human-readable name. IHasPerformanceIdentity An object which provides a value which uniquely identifies the currently-executing IPerformance. IHasServiceProvider An object which has an associated IServiceProvider, which resolves services from dependency injection. IPerformable An object which represents something that a performer (typically an actor) may perform. IPerformableWithResult An object which represents something that a performer (typically an actor) may perform and which returns a result when it completes. IPerformableWithResult<TResult> An object which represents something that a performer (typically an actor) may perform and which returns a strongly-typed result when it completes. IPerformance A performance represents a self-contained scope of performables which typically results in overall success or failure. IPersona A persona is a factory for a commonly-used actor IStage The stage facilitates a contextual Actor who is 'in the spotlight' - a currently-active actor"
  },
  "docs/GettingReports.html": {
    "href": "docs/GettingReports.html",
    "title": "Screenplay reports | Screenplay docs",
    "keywords": "Screenplay reports TODO: Write this docco"
  },
  "docs/HowScreenplayAndPerformanceRelate.html": {
    "href": "docs/HowScreenplayAndPerformanceRelate.html",
    "title": "Top-down look at a screenplay | Screenplay docs",
    "keywords": "Top-down look at a screenplay The diagram below shows a top-down look at a Screenplay and how it relates to Performances, Actors and Performables. The Screenplay might itself be controlled by a Test Integration, if Screenplay is being used for automated tests. The lifetime shown, for the Performance also indicates the lifetime of the dependency injection scope. sequenceDiagram accDescr { A single instance of Screenplay runs each Performance. Each Performance contains scripts for one or more Actors. Within the Performance, the Actor(s) perform one or more Performables. The lifetime of a single performance is shown, to illustrate the DI lifetime scope. } Screenplay->>Performance: Runs each actor A as Actor activate Performance Performance->>A: Contains scripts for<br>one or more A->>Performable: Performs one<br>or more Performable-->>A: Complete A-->>Performance: Complete Performance-->>Screenplay: Complete deactivate Performance"
  },
  "docs/MakeupOfAScreenplay.html": {
    "href": "docs/MakeupOfAScreenplay.html",
    "title": "Makeup of a Screenplay | Screenplay docs",
    "keywords": "Makeup of a Screenplay A Screenplay, used as a verb, refers to a complete execution screenplay-based logic, written using this framework. Screenplay, when used as a noun, is a class which coordinates the scope & execution of that logic. A Screenplay is comprised or one or more Performances, usually many. The diagram below shows the basic building blocks of a performance and how they interact. block-beta columns 3 Screenplay:3 Performance[\"Performance<br>(each Screenplay may contain many)\"]:3 Actor(\"Actors\") space block:Perf columns 3 space Task[\"Tasks\"] space Action[\"Actions\"] space Question[\"Questions\"] end space:3 Ability[\"Abilities\"] Actor -- \"Perform\" --> Perf Ability -- \"Has\" --> Actor Action -- \"Use\" --> Ability Question -- \"Use\" --> Ability style Perf fill:#E0E0F0,stroke:#C0C0E0 Explanation A performance involves one or more Actors. Each actor usually has at least one Ability. The actor performs Performables, of which there are three fundamental types: Tasks Actions Questions Actions and questions make direct use of the actor's abilities to perform their work. Tasks, on the other hand, are compositions of any of actions, questions and/or other tasks. A full Screenplay comprises of one or more performances."
  },
  "docs/ScreenplayInTheTestingStack.html": {
    "href": "docs/ScreenplayInTheTestingStack.html",
    "title": "Screenplay in the testing stack | Screenplay docs",
    "keywords": "Screenplay in the testing stack Screenplay is often used as a tool for writing automated tests. It is not a complete testing framework, though. It serves as an extension/plugin to existing testing frameworks, enhancing them with Screenplay syntax and logic. The diagram below shows where Screenplay lies within the technology stack, when it is used as a tool for testing. The dark yellow/light brown blocks show the Screenplay-specific components. The explanation below uses the NUnit test framework as an example, but this could be substituted for counterparts applicable to any test framework. block-beta columns 2 Runner[\"Test runner\"]:2 FW[\"Test framework\"]:2 Int[\"Test integration\"]:2 Test Logic[\"Screenplay test logic\"] classDef sp fill:#f0f0bb,stroke:#cc7 class Int,Logic sp The test runner This is the executable tool which runs tests. Applied to NUnit, this could be the nunit3-console.exe application. The test framework All testing framework contain some framework-specific logic of their own, which provide the basis for writing tests. Applied to NUnit, this is the NUnit.Framework.dll which is included in the NUnit NuGet package. The Test integration The Test Integration is the extension to the test framework (above) which enables the use of Screenplay-based logic in tests. Each testing framework has its own test integration, as it must be developed for the test framework's syntax and extension points. Tests The tests are normal tests written for the chosen test framework. Whilst they might be decorated with additional Screenplay-specific attributes or use Screenplay syntax, they are normal tests in the context of the test framework. Applied to NUnit, this would be your methods which look similar to: [Test] public void MyFunctionShouldReturnTrueWhenItIsTuesday() { // Test logic omitted } Screenplay test logic The logic within tests (above) which use Screenplay will be written using Screenplay's test syntax. That it, it will use Actors, Abilities and Performables. In this context, each test is a Screenplay Performance."
  },
  "docs/StandaloneScreenplay.html": {
    "href": "docs/StandaloneScreenplay.html",
    "title": "Using Screenplay standalone | Screenplay docs",
    "keywords": "Using Screenplay standalone Screenplay is often used as a tool for automating software tests, but it is not limited to only this usage. Screenplay may be added to any application or library, via dependency injection. This is as simple as installing the CSF.Screenplay NuGet package and adding Screenplay to your service collection. For more information, see the documentation for ScreenplayServiceCollectionExtensions. using CSF.Screenplay; // IServiceCollection services; services.AddScreenplay(); Once Screenplay has been added to your DI, you may resolve and use Screenplay-related services from dependency injection. To execute some logic in the scope of a Performance, consider using the method Screenplay.ExecuteAsPerformanceAsync. Abstractions package If your solution is separated into multiple projects/assemblies then only your entry-point project needs the full CSF.Screenplay NuGet package. Once Screenplay has been added to DI, other projects in the solution may consume its logic, only requiring the CSF.Screenplay.Abstractions package."
  },
  "docs/SuitabilityAsATestingTool.html": {
    "href": "docs/SuitabilityAsATestingTool.html",
    "title": "Where Screenplay is suitable for testing | Screenplay docs",
    "keywords": "Where Screenplay is suitable for testing The Screenplay pattern is a recommended tool for writing automated tests for application software. Unlike NUnit or SpecFlow (or many others) Screenplay is not a complete testing framework. Rather, Screenplay integrates with your chosen testing framework to assist in the writing of test logic. Screenplay is not a silver bullet; some kinds of tests could benefit from Screenplay and others will not. Some testing scenarios are listed below, along with a brief consideration as to whether Screenplay is likely to be relevant. Terminology can differ between developers, so each type of test begins with a short definition. Ideal: System tests Also known as \"end-to-end tests\"; this kind of test exercises and tests the full deployed application without the use of any test fakes. The application might be set up/configured in a controlled environment but it runs and is exercised in the same way it would in production. System tests are an ideal candidate for the use of Screenplay. System tests are often written from a user's perspective and test meaningful, observable behaviour of the application, such as a complete user story. Screenplay excels in this area of test design. Unsuitable: Unit tests Unit tests test the functionality of a small unit of code in isolation. Typically this is a single class or function. Anything external to the tested unit is replaced with a test fake or a mock. Screenplay is not recommended for use in unit testing. Unit tests are rarely written from an end-user's perspective and often do not test complete application behaviour, such as a user story. A unit test will only test only a small aspect of some functionality. When this aspect is considered in isolation it may be meaningless, or too abstract to comprehend for an end-user. Additionally: The steps involved in unit tests should be short & simple, with minimal need for code reuse or composition The steps are typically difficult to describe in the application's 'behaviour domain', only with language that a software developer would understand Perhaps useful: Integration tests Integration tests live at a point in the spectrum of testing between unit & system tests. Like unit tests, they execute logic via its programming API instead of testing the deployed application. Unlike unit tests, each integration test exercises logic across many units of code/classes. Thus, it is common for integration tests to test high-level APIs which represent complete user stories. Integration tests might include some test fakes. Usually these are limited to things which are difficult or expensive to control. Asynchronous web services & databases are typically replaced with test fakes in integration tests. For integration tests, we recommend that you evaluate for yourself whether Screenplay is useful. In some projects/applications, Screenplay will be excellent for integration tests. In others it might not. You will find Screenplay most useful if your integration tests test complete user stories. This is particularly true if the test/sample scenarios would be recognisable to end users, even if described in an abstract manner, for example without reference to a user interface. Recommended: Use BDD-style tests Screenplay is a great tool when used alongside Behaviour Driven Development (BDD). Whilst the use of a BDD framework such as SpecFlow is not at all mandatory, those familiar with BDD will quickly see the synergies with Screenplay."
  },
  "docs/builderPattern/index.html": {
    "href": "docs/builderPattern/index.html",
    "title": "The builder pattern | Screenplay docs",
    "keywords": "The builder pattern TODO: Write this docco"
  },
  "docs/dependencyInjection/DependencyInjectionScope.html": {
    "href": "docs/dependencyInjection/DependencyInjectionScope.html",
    "title": "Dependency injection scope | Screenplay docs",
    "keywords": "Dependency injection scope Developers familiar with dependency injection are likely to be familiar with the concept of DI Scopes. That is - some services which are designated as scoped or instance per scope use a common/shared instance for the lifetime/duration of the scope. Within Screenplay logic, a DI scope is automatically created, with a lifetime matching that of the current Performance. Within a performance, when any of the scoped services (listed below) are injected, each point of injection will receive the same shared instance of that service. Instances are independent per-performance; each performance gets its own shared instance of each of the listed services. List of scoped services The Cast The Stage The current performance"
  },
  "docs/dependencyInjection/InjectingServices.html": {
    "href": "docs/dependencyInjection/InjectingServices.html",
    "title": "Injecting services | Screenplay docs",
    "keywords": "Injecting services"
  },
  "docs/dependencyInjection/index.html": {
    "href": "docs/dependencyInjection/index.html",
    "title": "Dependency injection | Screenplay docs",
    "keywords": "Dependency injection The Screenplay design pattern is fundamentally compatible with dependency injection, aka DI. Screenplay introduces a form of Simone DI of its own, though; that is the concept of Abilities. As you can see on the diagram of how Actors, Abilities and Performables relate to one another, Only a few object types should be constructor-injected as dependencies, though. TODO: Write this docco Injecting services"
  },
  "docs/nUnitTutorial/BestPractices.html": {
    "href": "docs/nUnitTutorial/BestPractices.html",
    "title": "NUnit & Screenplay best practices | Screenplay docs",
    "keywords": "NUnit & Screenplay best practices TODO: Write this docco Keep assertions out of performables Use the async test syntax"
  },
  "docs/nUnitTutorial/index.html": {
    "href": "docs/nUnitTutorial/index.html",
    "title": "Screenplay & NUnit tutorial | Screenplay docs",
    "keywords": "Screenplay & NUnit tutorial Begin writing NUnit tests using Screenplay by following these steps. Further detail is provided below. Ensure that your test project uses NUnit version 3.6.0 or higher Install the NuGet package CSF.Screenplay.NUnit to your test project Write a class which implements IGetsScreenplay Decorate your test assembly with ScreenplayAssemblyAttribute, referencing your implementation of IGetsScreenplay Write your tests, decorating each test method with ScreenplayAttribute Add parameters to your test methods to access the Screenplay architecture Tip Developers are encouraged to read these best practices for writing NUnit tests which use Screenplay. Decorating your test assembly with [ScreenplayAssembly] So that your tests may make use of a Screenplay, you must install the Screenplay extension to the NUnit testing framework. This is steps 3 & 4 in the list above. This is achieved using the ScreenplayAssemblyAttribute. Place a line of code somewhere in your test project, outside of any type definition like this: [assembly: CSF.Screenplay.ScreenplayAssembly(typeof(MyScreenplayFactory))] There is one other thing you must do, and that is to write a screenplay factory class, which configures how the Screenplay should be created for your tests. A screenplay factory is a class which must implement IGetsScreenplay. Consider the example below as a starting point for writing your own. using CSF.Screenplay; public class MyScreenplayFactory : IGetsScreenplay { public Screenplay GetScreenplay() { return Screenplay.Create(services => { // Add your own dependency injection service descriptors to the service collection here // For example, services which will be used by Screenplay Abilities. }); } } Important When using NUnit with Screenplay, every Screenplay-using test within a test assembly (thus, within a .NET project) must share the same instance of Screenplay. This is not expected to be problematic, as all the Screenplay object does is set-up the Screenplay architecture and dependency injection for the tests. Writing test methods When writing test methods, the test methods must be decorated with ScreenplayAttribute, which activates Screenplay for that particular test method. NUnit test methods which are decorated with [Screenplay] may have test parameters; these parameters will be provided by dependency injection. This covers steps 5 & 6 in the list above. Here is an example of an NUnit test method which is written using Screenplay; it assumes that the assembly has been decorated with ScreenplayAssemblyAttribute, as noted above. Tip The ability, performables and DishwashingBuilder used in this test, related to washing dishes, are all fictitious. See the documentation for writing performables to learn about how these could be written. using CSF.Screenplay; using static CSF.Screenplay.PerformanceStarter; using static WashingTheDishes.DishwashingBuilder; [Test, Screenplay] public async Task TheDishesShouldBeCleanAfterJoeWashesThem(ICast cast, IDishWashingAbility washTheDishes) { var joe = cast.GetActor(\"Joe\"); joe.IsAbleTo(washTheDishes); await Given(joe).WasAbleTo(GetSomeDirtyDishes()); await When(joe).AttemptsTo(WashTheDishes()); var dishesCondition = await Then(joe).Should(LookAtTheDishesCondition()); Assert.That(dishesCondition, Is.EqualTo(\"Clean\")); }"
  },
  "docs/performables/WebApis.html": {
    "href": "docs/performables/WebApis.html",
    "title": "Web APIs | Screenplay docs",
    "keywords": "Web APIs Screenplay may be used to interact with Web APIs. Key to this is Ability class MakeWebApiRequests, along with a number of performables and types which represent API endpoints. Use WebApiBuilder to simplify usage The section & table below indicates the combinations of 'endpoint' & performable to use for several common use cases. If the correct endpoint has been used though, the WebApiBuilder class will make it very easy to select the correct performable, by type inference. For any requests which are expecting to read a response as a JSON string, to be deserialized, use an overload of GetTheJsonResult from the static web API builder. For any other requests, use an overload of SendTheHttpRequest. The recommended way to use this builder is via using static CSF.Screenplay.WebApis.WebApiBuilder; in the source file for a custom performable. Combinations of endpoints & performables for common usages The performable which should be used, along with the approproate endpoint type depends upon your use case, summarised in the table below. The table is organised by the expected body/content of the HTTP request, the request payload and the expected type of the response body. Where None is listed, this usually means that either the request or response have no body, such as an HTTP GET request that does not send a body or an empty response. In the case of responses this might alternatively mean that the response body will be ignored or will not be interpreted as an instance of any particular type. Request payload Response type Endpoint type Performable type None None Endpoint SendTheHttpRequest None Deserialized with custom logic Endpoint<TResponse> SendTheHttpRequestAndGetTheResponse<T> None Deserialized from JSON Endpoint<TResponse> SendTheHttpRequestAndGetJsonResponse<T> Serialized with custom logic None Derive from ParameterizedEndpoint<TParameters> SendTheHttpRequest Serialized with custom logic Deserialized with custom logic Derive from ParameterizedEndpoint<TParameters,TResponse> SendTheHttpRequestAndGetTheResponse<T> Serialized with custom logic Deserialized from JSON Derive from ParameterizedEndpoint<TParameters,TResponse> SendTheHttpRequestAndGetJsonResponse<T> Serialized with JSON None JsonEndpoint<TParameters> SendTheHttpRequest Serialized with JSON Deserialized with custom logic JsonEndpoint<TParameters,TResponse> SendTheHttpRequestAndGetTheResponse<T> Serialized with JSON Deserialized from JSON JsonEndpoint<TParameters,TResponse> SendTheHttpRequestAndGetJsonResponse<T> Tip The rule to decide which types of endpoint & performable to choose is: Choose the endpoint type based upon the needs of the request, adding an extra generic type parameter if the response is to be strongly-typed. Choose the performable type based upon how you intend to read the response."
  },
  "docs/performables/index.html": {
    "href": "docs/performables/index.html",
    "title": "Performables | Screenplay docs",
    "keywords": "Performables Screenplay comes with a few pre-created Abilities, Performables and Builders, for common tasks. Using a Stopwatch When an actor needs to keep precise track of time, you may give them the UseAStopwatch ability. Actors with this ability may use Actions and Questions which relate to use of the stopwatch. These are all accessible from the builder class StopwatchBuilder. Interacting with web APIs The NuGet package CSF.Screenplay.WebApis provides an ability, performables and supporting types to interact with web API endpoints. Further information is available on the web API documentation page. TimeSpan builder The TimeSpanBuilder<TOtherBuilder> is not a complete performable builder; it is intended to supplement other builders such as those of your own design. It handles a commonly-used aspect of building performables in a reusable manner."
  },
  "docs/specFlowTutorial/index.html": {
    "href": "docs/specFlowTutorial/index.html",
    "title": "Screenplay & SpecFlow tutorial | Screenplay docs",
    "keywords": "Screenplay & SpecFlow tutorial Begin writing SpecFlow tests using Screenplay by following these steps. Further detail is provided below. Ensure that your test project uses SpecFlow version 3.4.3 or higher Install the NuGet package CSF.Screenplay.SpecFlow to the project which will contain your .feature files Optional: Add services to dependency injection which will be required by the Abilities you intend to use. If required, use SpecFlow context injection & hooks to add these to the DI container. Write step binding classes which dependency-inject and use Screenplay's architecture Writing step bindings Important When using SpecFlow with Screenplay, every Screenplay-using test within a test assembly (thus, within a .NET project) must share the same instance of Screenplay. This is not expected to be problematic, as all the Screenplay object does is set-up the Screenplay architecture and dependency injection for the tests. When using Screenplay with SpecFlow, .feature files are written as normal. The only difference in writing your tests is that Step Binding classes should inject Screenplay architecture and use it within the bindings. The recommended services to inject into your step binding classes are either IStage or ICast. If you are using Personas, which are the recommended way to get Actors for your performances, then most step binding classes will need only one of the two services above. If you are not using Personas to get actors, then you might also need to inject some services which relate to the Abilities that you wish to grant actors. Example Tip The implied ability, the performables, persona and DishwashingBuilder used in this test, related to washing dishes, are all fictitious. See the documentation for writing performables to learn about how these could be written. This example assumes that SpecFlow is writting using the NUnit runner, and thus it makes use of NUnit-style assertions. Feel free to replace the assertion with whichever assertion library you wish to use. using CSF.Screenplay; using static CSF.Screenplay.PerformanceStarter; using static WashingTheDishes.DishwashingBuilder; [Binding] public class WashTheDishesSteps(IStage stage) { [Given(@\"^Joe was able to get some dirty dishes$\")] public async Task GetDirtyDishes() { var joe = stage.Spotlight<Joe>(); await Given(joe).WasAbleTo(GetSomeDirtyDishes()); } [When(@\"^(?:he|she|they) attempts? to wash the dishes$\")] public async Task WashTheDishes() { var actor = stage.GetSpotlitActor(); await When(actor).AttemptsTo(WashTheDishes()); } [Then(@\"^(?:he|she|they) should see that the dishes are clean$\")] public async Task GetDirtyDishes() { var actor = stage.GetSpotlitActor(); var condition = await Then(actor).Should(LookAtTheDishesCondition()); Assert.That(condition, Is.EqualTo(\"Clean\")); } }"
  },
  "docs/writingPerformables/AllowCooperativeCancellation.html": {
    "href": "docs/writingPerformables/AllowCooperativeCancellation.html",
    "title": "Allow cooperative cancellation | Screenplay docs",
    "keywords": "Allow cooperative cancellation All Performables implement one of three interfaces and each of these interfaces exposes a PerformAsAsync method which accepts a CancellationToken as a parameter. This cancellation token is to facilitate cooperative cancellation, so that a Performance may be cancelled/terminated gracefully. If an Action or Question makes use of an asynchronous method from an Ability then pass the cancellation token as a parameter to the Ability method that is used. Any time a Performance or Task executes a performable, pass the cancellation token down to the consumed performable as a parameter. Consider the strategies below for dealing with long-running synchronous methods, which do not natively participate in cooperative cancellation. There is no need for every performable (particularly tasks) to execute ThrowIfCancellationRequested() as a matter of course. Many performables complete their logic in microseconds or less, so excess cancellation-checking will bloat the logic for no perceivable gain. So long as the cancellation token is passed from 'the top of the Performance' downwards, and any Actions or Questions which perform async or long-running logic are cancellation-enabled, cancellation should work in a timely fashion. Dealing with long-running synchronous methods Sometimes an Action or Question will need to make use of functionality from an Ability which does not support cooperative cancellation. If such functionality is long-running then this can interfere with cancellation. It can lead to performances which take a long time to respond to cancellation of/when it is requested. Perhaps it's legacy code which predates the asynchronous programming model Perhaps it doesn't conform to best practice and doesn't accept a cancellation token parameter Here are two suggestions to deal with this. Throw if cancellation requested Cancellation token objects have a method ThrowIfCancellationRequested() which will interrupt and throw an exception if cancellation has been requested. You may use this method directly before executing a long-running synchronous (non-cancelable) Ability method. This won't cancel the long-running method if cancellation is requested after it has started its work, but it will prevent it from being started if cancellation is already requested. Use this technique if it's more important that the long-running method is not interrupted than it is to support timely cancellation. Use Task.Wait to make the long-running method interruptible An alternative strategy for dealing with long-running synchronous methods is to wrap the method execution in a new Task and use Task.Wait() to interrupt the task if cancellation is requested. Here's an example of that technique in action, applied to the PerformAsAsync method of a performable. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken) { Task.Run(() => LongRunningMethod()).Wait(cancellationToken); return default; } Use this technique if it's acceptable to send the long-running method into a separate thread and to 'give up waiting' for it to complete if cancellation has been requested. This technique might provide better responsiveness to cancellation than the one above, albeit it is the most likely to produce unexpected impact on the behaviour of the performable. Note that, as is standard for usage of Task.Wait(), cancelling the wait does not abort the execution of the long-running method. The thread which is executing that logic will usually continue and run to completion. Interrupting the wait just means that the main performance thread stops waiting for the other thread to complete."
  },
  "docs/writingPerformables/AvoidBranchingLogic.html": {
    "href": "docs/writingPerformables/AvoidBranchingLogic.html",
    "title": "Avoid branching logic | Screenplay docs",
    "keywords": "Avoid branching logic Performances are written a lot like scripts. Where possible, Performables should avoid branching or looping logic. This is particularly true when Screenplay is being used as a tool for testing. Good test logic has a cyclomatic complexity of precisely one. Sometimes looping logic is unavoidable and desirable in a Screenplay, imagine a performable which has an Actor repeat a process N times. This is acceptable if used judiciously. Performables should always avoid branching logic like if or switch though, and should never contain such logic when being used for tests. If more than one mode of operation is required then write more than one performable. The path through a Performance should be completely deterministic, short of an unexpected error or failure."
  },
  "docs/writingPerformables/DoNotUseDiFrameworks.html": {
    "href": "docs/writingPerformables/DoNotUseDiFrameworks.html",
    "title": "Do not resolve performables from DI | Screenplay docs",
    "keywords": "Do not resolve performables from DI Dependency Injection using DI frameworks is usually a recommended best practice in modern software. Screenplay recommends the resolution of many services from DI, including Personas, the Cast, Stage and Abilities. It is not a good idea to resolve Performable object instances from DI, though. Because performables should be immutable but stateful, this requires all of their state to be set at the time of their construction, such as via constructor parameters or properties with init setters. Unfortunately, this state represents the configuration of how the performable will be used, so it will be entirely down to the particular usage of the performable. This would make the use of DI quite cumbersome, as many arbitrary parameter values must be passed to the resolution. What's more, performables should not depend upon anything which is resolved from DI. At most, Actions and Questions may depend upon an Actor's Abilities but they should access these from the first parameter of the PerformAsAsync method; the ICanPerform parameter (the actor). Instead, it is far better to use the builder pattern to create instances of performables."
  },
  "docs/writingPerformables/ImplementICanReport.html": {
    "href": "docs/writingPerformables/ImplementICanReport.html",
    "title": "Implement ICanReport | Screenplay docs",
    "keywords": "Implement ICanReport When writing a Performable class, implement the ICanReport interface a well as the relevant performable interface. This enables a performable to emit a formatted, human-readable fragment of a report for the current performable. If you plan to redistribute your performables as a library then consider making your report fragments localizable strings, so that they may be translated for other locales."
  },
  "docs/writingPerformables/ImplementOnePerformableInterface.html": {
    "href": "docs/writingPerformables/ImplementOnePerformableInterface.html",
    "title": "Implementing the performable interface | Screenplay docs",
    "keywords": "Implementing the performable interface A Performable is a class which implements one of the three performable interfaces: IPerformable IPerformableWithResult IPerformableWithResult<TResult> Performables must implement precisely one of these interfaces. Implementing more than one upon a single performable is not recommended or supported. Doing so is liable to cause difficulties. If you wish to share code then move the reusable logic into a Task and consume that from separate performable classes."
  },
  "docs/writingPerformables/ParameterizeLowLevelPerformables.html": {
    "href": "docs/writingPerformables/ParameterizeLowLevelPerformables.html",
    "title": "Parameterize low-level Performables | Screenplay docs",
    "keywords": "Parameterize low-level Performables When writing low-level Performables, these classes should expose parameters which allow the consumer to provide as many of the variables as make sense. This is especially important for Actions and/or Questions but also relevant for lower-level/reusable Tasks. Parameters should be accepted via the class' public constructor, the values to these parameters should then be held readonly. Accept as many parameters as are reasonable, although avoid going so far that parameterisation makes a Performable unclear as to what it does. An example Imagine we are writing a Task which makes a cup of coffee, ready to serve. It would make sense to include parameters which decide the strength of the coffee, how much milk and sweetener to add and similar. It would usually be a mistake to create a Task which can make any hot drink, where the parameters provided decide which hot drink to make. The processes for making various hot drinks are often fundamentally different; consider the process for making coffee and then that for brewing tea. In the most extreme case, where such a Task is required, separate the logic of making of each hot drink into Tasks of their own, and consume/execute the relevant one of these from the any hot drink Task."
  },
  "docs/writingPerformables/PureFunctionalTasks.html": {
    "href": "docs/writingPerformables/PureFunctionalTasks.html",
    "title": "'Pure functional' tasks | Screenplay docs",
    "keywords": "'Pure functional' tasks To maximise their reusability, developers are advised to write Tasks in a way which either: Changes the application's state Gets information from the application without changing its state This draws from the lessons that writing pure functions teaches us. If 'getting some information' has unwanted or unexpected side-effects then the task becomes less reusable. If a task must have side effects then consider separating the parts of it which do not require those side-effects into a lower-level task which is reusable without the side-effects. That lower-level task would then be consumed by a higher-level task which does include the side-effects."
  },
  "docs/writingPerformables/StatefulButImmutable.html": {
    "href": "docs/writingPerformables/StatefulButImmutable.html",
    "title": "Performables are stateful, but immutable | Screenplay docs",
    "keywords": "Performables are stateful, but immutable Instances of Performable classes are not intended to be reused. A single class may have many instances created, but each instance should be used only once. This is because the 'parameter values' for each performable are provided into that performable object instance. Parameters should ideally be provided into the performable class' public constructor. Another viable technique could be init-only property setters. Once these values are set, they should be readonly so that they may not be changed. Performable classes should also avoid the use of mutable class-level data such as fields or properties. Any temporary state should be scoped only to the relevant PerformAsAsync method."
  },
  "docs/writingPerformables/TasksDoNotUseAbilities.html": {
    "href": "docs/writingPerformables/TasksDoNotUseAbilities.html",
    "title": "Tasks should not use abilities | Screenplay docs",
    "keywords": "Tasks should not use abilities The logic of Task classes should not interact with the actor's Abilities. Logic which interacts with abilities should be limited to Action and/or Question classes. Move logic which needs to interact with Abilities into Action/Question classes and ensure that they are appropriately parameterized. Consume such actions or questions from your custom Task class."
  },
  "docs/writingPerformables/WriteABuilder.html": {
    "href": "docs/writingPerformables/WriteABuilder.html",
    "title": "Write builders for your performables | Screenplay docs",
    "keywords": "Write builders for your performables If you write a new performable class, it is strongly recommended to write a static builder for it. Benefits include: Ensuring that the performable may only be created in a valid state Making your performance logic more human-readable, almost like a domain specific language"
  },
  "docs/writingPerformables/index.html": {
    "href": "docs/writingPerformables/index.html",
    "title": "Writing Performables | Screenplay docs",
    "keywords": "Writing Performables Screenplay and add-on libraries will ship with pre-created Actions and Questions, two of the three types of Performable. Developers making use of Screenplay might not need to write new Actions or Questions, because they may use and compose the existing ones. On the other hand, it is very likely that developers will need to write Tasks, which are the kind of Performable which composes Actions, Questions and/or other Tasks. A sample Task Here is an annotated example of a Task which makes use of a fictitious Action and a fictitious Question. TODO: Write this docco Guidelines for writing performables The following list shows some guidelines for writing new performables. These apply equally across ask if the three types of performables, even though developers are mainly expected to be writing tasks. Implement precisely one performable interface Implement ICanReport Parameterize low-level performables Avoid branching logic Performables should be stateful but immutable Allow cooperative cancellation Write a builder Do not rely on a DI framework Aim for Pure Functional tasks Do not interact with Abilities from Tasks"
  },
  "glossary/Ability.html": {
    "href": "glossary/Ability.html",
    "title": "Ability | Screenplay docs",
    "keywords": "Ability An ability is an arbitrary object which may be granted to Actors in order to allow them to interact with the application as part of a Performance. Unlike many other Screenplay object-types, there is no particular interface which Abilities must implement, as their functionality, capabilities and very nature are specific to them alone. That said - it is recommended for Abilities to implement ICanReport if possible, as this allows for the production of a more pleasant human-readable report. Actions and/or Questions may interact directly with an actor's abilities in order to perform their functionality. Tasks, on the other hand, should not."
  },
  "glossary/Action.html": {
    "href": "glossary/Action.html",
    "title": "Action | Screenplay docs",
    "keywords": "Action An Action is a kind of Performable in which an Actor does something or interacts with the application in such as way as to change its state. Specifically, an action should be the smallest, most granular change or interaction possible; something which cannot reasonably be split into constituent parts. In an application of Screenplay which controls a web browser, an action might be a single mouse click, or entering some specified text into an input field. To create higher-level interactions, use Tasks to compose actions. Out of the kinds of performable, actions are the smallest building blocks available. Actions don't have a direct representation in Screenplay code because they are really just an arbitrary category of performable. Actions most commonly implement the IPerformable interface though, as they usually do not return any results. Generally, the logic of actions interacts directly with the actor's Abilities in order to provide the functionality required to perform the action."
  },
  "glossary/Feature.html": {
    "href": "glossary/Feature.html",
    "title": "Feature | Screenplay docs",
    "keywords": "Feature A Feature is a concept which is relevant when the Screenplay library is being used to perform automated tests. Each feature is a logical group of one or more related Scenarios. In Screenplay, features exist only for organising scenarios. They have no first-class representation in the code; their only appearance is within Reports. Everything related to features is handled automatically when consuming Screenplay from an appropriate Integration. Depending upon the testing framework in use, features might alternatively be named \"test fixture\" or \"test class\"."
  },
  "glossary/Integration.html": {
    "href": "glossary/Integration.html",
    "title": "Integration | Screenplay docs",
    "keywords": "Integration An Integration refers to an integration library between the Screenplay library and a framework for performing automated tests. The integration library performs the necessary scaffolding to make the Screenplay types available for dependency injection. It also deals with the association of Scenarios with Performances and the lifetime of the whole Screenplay, culminating with the production of the Report."
  },
  "glossary/Performable.html": {
    "href": "glossary/Performable.html",
    "title": "Performable | Screenplay docs",
    "keywords": "Performable A 'performable' is a verb in the language of Screenplay; performables are things that Actors do. Performables are logically grouped into one of the following three kinds. Do not be mistaken in believing that these three kinds of performable correspond to the three interfaces which are listed later on this page. This is entirely coincidental and there is no direct equivalence. Actions are the most granular of individual interactions with the application, composable to form higher-order interactions Questions are granular, like actions, but read the application's state to get information instead of making changes Tasks are higher-order interactions which are formed by composing actions, questions and/or other tasks Performables are not reusable Implementations of any of the performable interfaces (below) are stateful objects which must not be reused. Performable objects are often mutable and their mutable state forms the parameters by which they will operate. Typically, performables are created using a builder which configures their state. Each performable object is used precisely once by an actor and then discarded. Even if you would like to perform the same operation twice, do not attempt to reuse a performable; use the builder twice to create two (identical) instances of the same performable type. Developers using Screenplay will typically be writing Tasks Actions & Questions are the smallest/low-level building blocks of a Screenplay Performance. They are parameterized and should make as few assumptions as possible. As such, they should be highly reusable. Actions & Questions rarely need to be written by developers who are using Screenplay. That is because most likely, the Action, Question and corresponding Ability classes will have been provided in a library, such as a NuGet package. On the other hand, Tasks are higher-level performables which may compose Actions, Questions and/or other lower-level Tasks. Developers using Screenplay should write as many Tasks as they need. Tasks may represent any of the - possibly complex - interactions performed by the Actor. Actions & Questions should interact directly with the Actor's Abilities to perform their logic; in most cases Tasks should not directly use any Abilities. When writing your own performables, consider these best practices for the best results. The three performable interfaces, and ICanReport In Screenplay code, a Performance is a script of sorts, written from at least one performable, usually several. All performables must implement one of the following three interfaces, but it's also strongly recommended to implement ICanReport as well. As noted above, it is coincidence alone that there are three kinds of performable and three interfaces for performables. There is no direct correlation between these interfaces and the kinds of performable. IPerformable IPerformableWithResult IPerformableWithResult<TResult>"
  },
  "glossary/Persona.html": {
    "href": "glossary/Persona.html",
    "title": "Persona | Screenplay docs",
    "keywords": "Persona A Persona is a class which serves as a factory for a specific Actor. In Screenplay, it is strongly recommended to create and re-use well-known Actors across your Performances. That is, if an actor with a specified Name has a certain set of Abilities in one Performance, then ideally all actors of the same name should have that same set of abilities in other performances. This leads to the creation of well-known Actors which are well-understood by the team who are working with Screenplay. Personas help facilitate that by providing a reusable location at which to set the actor's name and to assign & configure their abilities. Personas in Screenplay are classes which implement the IPersona interface."
  },
  "glossary/Question.html": {
    "href": "glossary/Question.html",
    "title": "Question | Screenplay docs",
    "keywords": "Question A Question is a kind of Performable in which an Actor gets or reads some information from the application, ideally in such a way that does not change the application's state. Similar to Actions, questions should be as small in their scope as possible, to make them as reusable and composable as possible. In code, questions get a value and return it to the consuming logic, so they will always implement one of IPerformableWithResult<TResult> or its non-generic counterpart IPerformableWithResult. In an application of Screenplay which controls a web browser, a questions might represent reading the text from a single HTML element, or reading the enabled/disabled state of a button. To create higher-level questions with broader scope, compose them with Tasks. Generally, the logic of questions interacts directly with the actor's Abilities in order to provide the functionality required to get the requested information."
  },
  "glossary/Report.html": {
    "href": "glossary/Report.html",
    "title": "Report | Screenplay docs",
    "keywords": "Report After a Screenplay has completed, the Screenplay software may produce a machine-readable report of what occurred. This report may be read, processed, stored or transformed into an alternative format as desired. The report is hierarchical; at its topmost level are Features and within are Scenarios. The scenario directly corresponds to a single Performance, and within are contained all of the Performables for that performance. Performables in a report are also included hierarchically. This means that high-level Tasks contain information about the performables from which they are composed. Reports are useful to document what has been performed in a Screenplay. They help developers diagnose and debug issues when they arise."
  },
  "glossary/Scenario.html": {
    "href": "glossary/Scenario.html",
    "title": "Scenario | Screenplay docs",
    "keywords": "Scenario A Scenario is a concept which is relevant when the Screenplay library is being used to perform automated tests. A scenario refers to a lifetime within such a testing framework or Integration. That lifetime is that of a single test, which might be called a \"test case\" or \"theory\" or perhaps \"example\" in your chosen testing framework. The lifetime of a scenario very closely corresponds to that of a Performance. Every scenario is contained within a Feature."
  },
  "glossary/Spotlight.html": {
    "href": "glossary/Spotlight.html",
    "title": "Spotlight | Screenplay docs",
    "keywords": "Spotlight When the Stage is used to get an Actor, that actor is placed in the Spotlight. That same actor remains in the spotlight until a different actor is placed there. Note, though, that a Stage and thus its corresponding Spotlight is scoped to the current Performance. A different performance has a completely independent Stage and Spotlight. A stage may be used at any time to get the actor who is currently in the spotlight. Thus, it is possible to infer an actor in Performance logic without needing to use their name. See the documentation for the Stage for more information."
  },
  "glossary/Task.html": {
    "href": "glossary/Task.html",
    "title": "Task | Screenplay docs",
    "keywords": "Task A Task is a kind of Performable which represents a high-level interaction with the application. Where Actions or Questions are highly granular for maximum reusability, tasks may be as specific as the use-case warrants. Action & question classes are often shipped with Screenplay frameworks. Tasks are typically written by the developer who is making use of Screenplay. In practice, tasks are just compositions of actions, questions or other lower-level tasks. In a Screenplay which controls a web application, an example of a task is the completion of a registration form which involves entering data into multiple input fields. Writing tasks Tasks may implement any of the three performable interfaces. Developers are encouraged to follow these best practices when writing Task classes."
  },
  "glossary/index.html": {
    "href": "glossary/index.html",
    "title": "Glossary | Screenplay docs",
    "keywords": "Glossary Following is a glossary of Screenplay terminology; each term is a link to its own documentation. Many of these terms are implemented directly as .NET types in the Screenplay architecture. Where applicable, the glossary item links directly to the relevant type within the API documentation. Term Summary Screenplay A complete execution of the Screenplay software Performance A single end-to-end script of performables Performable A Screenplay verb; something that an actor can do Action A kind of peformable; the lowest-level interaction that changes the state of the application Question A kind of peformable; the lowest-level interrogation that reads application state Task A composition of actions, questions and/or other tasks to create higher-level performables Actor Typically a human user of the application, directs the use of performables Ability Something that an actor is able to do or has; provides the dependencies for actions/questions Persona A factory or template for consistently creating reusable, well-known actors Cast A factory & registry for actors which facilitates managing multiple actors in a performance Stage Provides situational context; a concept of 'the currently active actor' Spotlight The currently active actor, facilitated by the stage Report An output which details every performance/scenario and the outcomes of theie performables Scenario Typically similar to a performance, this is a single test within a testing framework Feature A logical group of related scenarios, this is a test class or test fixture in some testing frameworks Integration A consumer of the Screenplay framework, such as a testing framework"
  },
  "index.html": {
    "href": "index.html",
    "title": "Screenplay pattern | Screenplay docs",
    "keywords": "Screenplay pattern Screenplay is a software design pattern to assist in the automation of complex processes. It is particularly useful for writing tests which use a Behaviour Driven Development (BDD) style. CSF.Screenplay is a library and framework for using this design pattern. Learn about Screenplay's concepts Makeup of a Performance How a Screenplay runs Using dependency injection Glossary of Screenplay terminology As a testing tool Screenplay is useful for directing integration and system tests. It may be used for testing web applications via a web browser. In that context, Screenplay is a refinement of the Page Object Pattern. Screenplay in the testing stack NUnit & Screenplay tutorial SpecFlow & Screenplay tutorial Using Screenplay Writing performables, usually tasks Writing builders Getting reports Using pre-created Abilities & Performables Using Screenplay standalone"
  }
}