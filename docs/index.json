{
  "api/CSF.Screenplay.Abilities.GetAssetFilePaths.html": {
    "href": "api/CSF.Screenplay.Abilities.GetAssetFilePaths.html",
    "title": "Class GetAssetFilePaths | Screenplay",
    "summary": "Class GetAssetFilePaths Namespace CSF.Screenplay.Abilities Assembly CSF.Screenplay.Abstractions.dll Screenplay ability which gets the file system path for asset files generated by actors participating in the current performance. public class GetAssetFilePaths : ICanReport Inheritance object GetAssetFilePaths Implements ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GetAssetFilePaths(IGetsAssetFilePath) Initializes a new instance of the GetAssetFilePaths class. public GetAssetFilePaths(IGetsAssetFilePath pathProvider) Parameters pathProvider IGetsAssetFilePath The path provider used to get asset file paths. Methods GetAssetFilePath(string) Gets the file system path for the specified asset file. public string GetAssetFilePath(string baseName) Parameters baseName string A short descriptive file name fragment for the asset file, including the file extension. Returns string The asset file path. Remarks The returned file system path is an absolute path to which the asset file should be written. The path is determined by the logic of the service IGetsAssetFilePath. This means that the final filename will not be identical to the baseName but will include that base name within it. If this method returns null then the asset file should not be written to the file system. See Also GetAssetFilePath(string) GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose."
  },
  "api/CSF.Screenplay.Abilities.UseAStopwatch.html": {
    "href": "api/CSF.Screenplay.Abilities.UseAStopwatch.html",
    "title": "Class UseAStopwatch | Screenplay",
    "summary": "Class UseAStopwatch Namespace CSF.Screenplay.Abilities Assembly CSF.Screenplay.Abstractions.dll An ability that enables an actor to make use of a Stopwatch to accurately measure the passage of time. public class UseAStopwatch : ICanReport Inheritance object UseAStopwatch Implements ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Use this ability with the actions which exposed by StopwatchBuilder. This ability wraps a Stopwatch instance, allowing the actor to control & read it from the related actions. Properties Stopwatch Gets the stopwatch granted to the actor by this ability. public Stopwatch Stopwatch { get; } Property Value Stopwatch Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose."
  },
  "api/CSF.Screenplay.Abilities.html": {
    "href": "api/CSF.Screenplay.Abilities.html",
    "title": "Namespace CSF.Screenplay.Abilities | Screenplay",
    "summary": "Namespace CSF.Screenplay.Abilities Classes GetAssetFilePaths Screenplay ability which gets the file system path for asset files generated by actors participating in the current performance. UseAStopwatch An ability that enables an actor to make use of a Stopwatch to accurately measure the passage of time."
  },
  "api/CSF.Screenplay.Actor.html": {
    "href": "api/CSF.Screenplay.Actor.html",
    "title": "Class Actor | Screenplay",
    "summary": "Class Actor Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A representation of an autonomous, or at least seemingly-autonomous, person or system which directs the events of a IPerformance. public class Actor : IHasAbilities, IHasName, IHasPerformanceIdentity, IDisposable, IHasPerformableEvents, ICanPerform, ICanPerformGiven, ICanPerformWhen, ICanPerformThen Inheritance object Actor Implements IHasAbilities IHasName IHasPerformanceIdentity IDisposable IHasPerformableEvents ICanPerform ICanPerformGiven ICanPerformWhen ICanPerformThen Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods ActorExtensions.WasAbleTo(ICanPerformGiven, IGetsPerformable, CancellationToken) ActorExtensions.WasAbleTo(ICanPerformGiven, IGetsPerformableWithResult, CancellationToken) ActorExtensions.WasAbleTo<T>(ICanPerformGiven, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.Should(ICanPerformThen, IGetsPerformable, CancellationToken) ActorExtensions.Should(ICanPerformThen, IGetsPerformableWithResult, CancellationToken) ActorExtensions.Should<T>(ICanPerformThen, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.AttemptsTo(ICanPerformWhen, IGetsPerformable, CancellationToken) ActorExtensions.AttemptsTo(ICanPerformWhen, IGetsPerformableWithResult, CancellationToken) ActorExtensions.AttemptsTo<T>(ICanPerformWhen, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.GetAbility(ICanPerform, Type) ActorExtensions.GetAbility<T>(ICanPerform) ActorExtensions.HasAbility(ICanPerform, Type) ActorExtensions.HasAbility<T>(ICanPerform) ActorExtensions.IsAbleTo(ICanPerform, object) ActorExtensions.IsAbleTo<TAbility>(ICanPerform) ActorExtensions.PerformAsync(ICanPerform, IGetsPerformable, CancellationToken) ActorExtensions.PerformAsync(ICanPerform, IGetsPerformableWithResult, CancellationToken) ActorExtensions.PerformAsync<T>(ICanPerform, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.TryGetAbility(ICanPerform, Type, out object) ActorExtensions.TryGetAbility<T>(ICanPerform, out T) ActorExtensions.HasAbility(IHasAbilities, Type) ActorExtensions.HasAbility<T>(IHasAbilities) Examples A good example of an actor, aside from a person, could be task scheduling software which executes logic at specific times of day. That is - provided that the task scheduling software itself is not a part of the Screenplay Performance. Within the context of such a performance, the task scheduler executing its logic at the configured time would appear to be an autonomous action because nothing else within the scope of the performance prompted it. Conversely, a mouse trap would be a poor example of an actor; a mouse trap acts only reactively. The creature entering the trap would be the actor in such a performance. Remarks An actor should represent an autonomous or semi-autonomous system. Most commonly is a human being using a piece of software. An actor might also represent an automated system which acts according to policy, so long as configuring/initating that system is not a part of the IPerformance. Within a performance, each performable item is executed in the context of the actor which performed it. Actors have abilities which provide them the means by which to interact with the software. A single conceptual actor must be represented by a single instance of this type; two actors of the same name are not considered to be the same actor, nor will they behave as such. Instances of actor should have an object lifetime which lasts for the remainder of the performance in which they were created. Instances of actor must not be shared across performances. In other words, they should be scoped to only a single performance. A single performance might involve only one actor or it might involve many. If a performance makes use of multiple actors, the developer should consider making use of either or both of the ICast and/or IStage, which assist in the management of multiple actors. Constructors Actor(string, Guid) Initialises a new instance of Actor public Actor(string name, Guid performanceIdentity) Parameters name string The actor's name performanceIdentity Guid A unique identity for the performance Remarks In line with IHasName, it is strongly recommended that name is not null. Properties Abilities Gets a collection of the actor's abilities protected virtual HashSet<object> Abilities { get; } Property Value HashSet<object> Name Gets the actor's name public virtual string Name { get; } Property Value string See Also IHasName PerformanceIdentity Gets the unique identity for the performance in which this actor is participating protected virtual Guid PerformanceIdentity { get; } Property Value Guid Methods Dispose() public void Dispose() Dispose(bool) Disposes the current instance, via the Dispose Pattern. protected virtual void Dispose(bool disposing) Parameters disposing bool A value indicating wherher or not disposal should occur. InvokeBeginPerformable(object, PerformancePhase) Invokes the BeginPerformable event. protected virtual void InvokeBeginPerformable(object performable, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item phase PerformancePhase The performance phase to which this event relates InvokeEndPerformable(object, PerformancePhase) Invokes the EndPerformable event. protected virtual void InvokeEndPerformable(object performable, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item phase PerformancePhase The performance phase to which this event relates InvokeGainedAbility(object) Invokes the GainedAbility event. protected virtual void InvokeGainedAbility(object ability) Parameters ability object The ability which this actor gained InvokePerformableFailed(object, Exception, PerformancePhase) Invokes the PerformableFailed event. protected virtual void InvokePerformableFailed(object performable, Exception exception, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item exception Exception The exception which halted the performable phase PerformancePhase The performance phase to which this event relates InvokePerformableResult(object, object, PerformancePhase) Invokes the PerformableResult event. protected virtual void InvokePerformableResult(object performable, object result, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item result object The result value from the performable phase PerformancePhase The performance phase to which this event relates InvokeRecordsAsset(object, string, string, PerformancePhase) Invokes the RecordsAsset event. protected virtual void InvokeRecordsAsset(object performable, string filePath, string fileSummary = null, PerformancePhase phase = PerformancePhase.Unspecified) Parameters performable object The performable item filePath string The full absolute path to the asset file fileSummary string An optional human-readable summary of the asset file phase PerformancePhase The performance phase to which this event relates IsAbleTo(object) Adds a new ability to the actor protected virtual void IsAbleTo(object ability) Parameters ability object The ability to add Exceptions ArgumentNullException If the ability is null InvalidOperationException If the actor already has an ability of this type or a derived type PerformAsync(IPerformable, PerformancePhase, CancellationToken) Performs an action or task which returns no result. protected virtual ValueTask PerformAsync(IPerformable performable, PerformancePhase phase = PerformancePhase.Unspecified, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item phase PerformancePhase The performance phase to which the performable belongs cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete Exceptions ArgumentNullException If the performable is null PerformAsync(IPerformableWithResult, PerformancePhase, CancellationToken) Performs a question or question-like task which returns an untyped result. protected virtual ValueTask<object> PerformAsync(IPerformableWithResult performable, PerformancePhase phase = PerformancePhase.Unspecified, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item phase PerformancePhase The performance phase to which the performable belongs cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which completes when the performable is complete Exceptions ArgumentNullException If the performable is null PerformAsync<T>(IPerformableWithResult<T>, PerformancePhase, CancellationToken) Performs a question or question-like task which returns a strongly typed result. protected virtual ValueTask<T> PerformAsync<T>(IPerformableWithResult<T> performable, PerformancePhase phase = PerformancePhase.Unspecified, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item phase PerformancePhase The performance phase to which the performable belongs cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which completes when the performable is complete Type Parameters T Exceptions ArgumentNullException If the performable is null ToString() public override string ToString() Returns string Events BeginPerformable Occurs when the actor begins the execution of a performable object. public event EventHandler<PerformableEventArgs> BeginPerformable Event Type EventHandler<PerformableEventArgs> EndPerformable Occurs when an actor ends the execution of a performable object. public event EventHandler<PerformableEventArgs> EndPerformable Event Type EventHandler<PerformableEventArgs> GainedAbility Occurs when an actor gains a new ability. public event EventHandler<GainAbilityEventArgs> GainedAbility Event Type EventHandler<GainAbilityEventArgs> PerformableFailed Occurs when a performable object fails with an exception. public event EventHandler<PerformableFailureEventArgs> PerformableFailed Event Type EventHandler<PerformableFailureEventArgs> PerformableResult Occurs when an actor receives a result from a perfperformable objectrmance. public event EventHandler<PerformableResultEventArgs> PerformableResult Event Type EventHandler<PerformableResultEventArgs> RecordsAsset Occurs when an actor records the presence of a new file asset. public event EventHandler<PerformableAssetEventArgs> RecordsAsset Event Type EventHandler<PerformableAssetEventArgs> See Also IPerformance ICast IStage"
  },
  "api/CSF.Screenplay.ActorExtensions.html": {
    "href": "api/CSF.Screenplay.ActorExtensions.html",
    "title": "Class ActorExtensions | Screenplay",
    "summary": "Class ActorExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Extension methods for actor types public static class ActorExtensions Inheritance object ActorExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AttemptsTo(ICanPerformWhen, IGetsPerformable, CancellationToken) Performs an action or task which returns no result. public static ValueTask AttemptsTo(this ICanPerformWhen actor, IGetsPerformable performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformWhen An actor performableBuilder IGetsPerformable The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete AttemptsTo(ICanPerformWhen, IGetsPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. public static ValueTask<object> AttemptsTo(this ICanPerformWhen actor, IGetsPerformableWithResult performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformWhen An actor performableBuilder IGetsPerformableWithResult The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete AttemptsTo<T>(ICanPerformWhen, IGetsPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. public static ValueTask<T> AttemptsTo<T>(this ICanPerformWhen actor, IGetsPerformableWithResult<T> performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformWhen An actor performableBuilder IGetsPerformableWithResult<T> The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type GetAbility(ICanPerform, Type) Gets the first ability which the actor has of the specified type public static object GetAbility(this ICanPerform actor, Type abilityType) Parameters actor ICanPerform The actor from whom to get the ability abilityType Type The type of ability desired Returns object The ability instance Exceptions ArgumentNullException If any parameter is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor does not have an ability which is or derives from abilityType GetAbility<T>(ICanPerform) Gets the first ability which the actor has of the specified type public static T GetAbility<T>(this ICanPerform actor) Parameters actor ICanPerform The actor from whom to get the ability Returns T The ability instance Type Parameters T The type of ability desired Exceptions ArgumentNullException If the actor is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor does not have an ability which is or derives from T HasAbility(ICanPerform, Type) Gets a value which indicates if the actor has an ability of the specified type. public static bool HasAbility(this ICanPerform actor, Type abilityType) Parameters actor ICanPerform An actor abilityType Type The ability type for which to test Returns bool true if the actor has an ability of the specified abilityType; false if not. Remarks This method will also return false if the actor does not implement IHasAbilities. HasAbility(IHasAbilities, Type) Gets a value which indicates if the actor has an ability of the specified type. public static bool HasAbility(this IHasAbilities actor, Type abilityType) Parameters actor IHasAbilities An actor abilityType Type The ability type for which to test Returns bool true if the actor has an ability of the specified abilityType; false if not. HasAbility<T>(ICanPerform) Gets a value which indicates if the actor has an ability of the specified type. public static bool HasAbility<T>(this ICanPerform actor) Parameters actor ICanPerform An actor Returns bool true if the actor has an ability of the specified T; false if not. Type Parameters T The ability type for which to test Remarks This method will also return false if the actor does not implement IHasAbilities. HasAbility<T>(IHasAbilities) Gets a value which indicates if the actor has an ability of the specified type. public static bool HasAbility<T>(this IHasAbilities actor) Parameters actor IHasAbilities An actor Returns bool true if the actor has an ability of the specified T; false if not. Type Parameters T The ability type for which to test IsAbleTo(ICanPerform, object) Adds an ability to the specified actor public static void IsAbleTo(this ICanPerform actor, object ability) Parameters actor ICanPerform The actor from whom to get the ability ability object The ability to add to the actor Exceptions ArgumentNullException If any parameter is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor already has an ability of the same type as the ability to add, or which derives from the same type IsAbleTo<TAbility>(ICanPerform) Adds an ability to the specified actor, where the ability has a public parameterless constructor public static void IsAbleTo<TAbility>(this ICanPerform actor) where TAbility : new() Parameters actor ICanPerform The actor from whom to get the ability Type Parameters TAbility The type of the ability to add to the actor Remarks This method is a convenience for manually instantiating the ability instance and adding it to the actor in that manner. For abilities which do not have a public parameterless constructor, consider adding them to the actor via dependency injection. The recommended technique for accomplishing this is by implementing IPersona in a class of your own. Implementations of persona are eligible for dependency injection when the actor is retrieved from the persona type via the ICast: GetActor<TPersona>(ICast). Exceptions ArgumentNullException If any parameter is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor already has an ability of the same type as the TAbility to add, or which derives from the same type PerformAsync(ICanPerform, IGetsPerformable, CancellationToken) Performs an action or task which returns no result from the performable which is exposed by the specified builder object. public static ValueTask PerformAsync(this ICanPerform actor, IGetsPerformable performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerform An actor performableBuilder IGetsPerformable The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete PerformAsync(ICanPerform, IGetsPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result from the performable which is exposed by the specified builder object. public static ValueTask<object> PerformAsync(this ICanPerform actor, IGetsPerformableWithResult performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerform An actor performableBuilder IGetsPerformableWithResult The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete PerformAsync<T>(ICanPerform, IGetsPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result from the performable which is exposed by the specified builder object. public static ValueTask<T> PerformAsync<T>(this ICanPerform actor, IGetsPerformableWithResult<T> performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerform An actor performableBuilder IGetsPerformableWithResult<T> The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type Should(ICanPerformThen, IGetsPerformable, CancellationToken) Performs an action or task which returns no result. public static ValueTask Should(this ICanPerformThen actor, IGetsPerformable performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformThen An actor performableBuilder IGetsPerformable The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete Should(ICanPerformThen, IGetsPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. public static ValueTask<object> Should(this ICanPerformThen actor, IGetsPerformableWithResult performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformThen An actor performableBuilder IGetsPerformableWithResult The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete Should<T>(ICanPerformThen, IGetsPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. public static ValueTask<T> Should<T>(this ICanPerformThen actor, IGetsPerformableWithResult<T> performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformThen An actor performableBuilder IGetsPerformableWithResult<T> The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type TryGetAbility(ICanPerform, Type, out object) Gets the first ability which the actor has of the specified type public static bool TryGetAbility(this ICanPerform actor, Type abilityType, out object ability) Parameters actor ICanPerform The actor from whom to get the ability abilityType Type The type of ability desired ability object If this method returns true then this exposes the strongly-typed ability; if not then this value is undefined Returns bool true if the actor has an ability of the specified type; false if not. Exceptions ArgumentNullException If any parameter is null TryGetAbility<T>(ICanPerform, out T) Tries to get the first ability which the actor has of the specified type public static bool TryGetAbility<T>(this ICanPerform actor, out T ability) Parameters actor ICanPerform The actor from whom to get the ability ability T If this method returns true then this exposes the strongly-typed ability; if not then this value is undefined Returns bool true if the actor has an ability of the specified type; false if not. Type Parameters T The type of ability desired Exceptions ArgumentNullException If the actor is null ArgumentException If the actor does not implement IHasAbilities WasAbleTo(ICanPerformGiven, IGetsPerformable, CancellationToken) Performs an action or task which returns no result. public static ValueTask WasAbleTo(this ICanPerformGiven actor, IGetsPerformable performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformGiven An actor performableBuilder IGetsPerformable The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete WasAbleTo(ICanPerformGiven, IGetsPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. public static ValueTask<object> WasAbleTo(this ICanPerformGiven actor, IGetsPerformableWithResult performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformGiven An actor performableBuilder IGetsPerformableWithResult The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete WasAbleTo<T>(ICanPerformGiven, IGetsPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. public static ValueTask<T> WasAbleTo<T>(this ICanPerformGiven actor, IGetsPerformableWithResult<T> performableBuilder, CancellationToken cancellationToken = default) Parameters actor ICanPerformGiven An actor performableBuilder IGetsPerformableWithResult<T> The performable builder cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type"
  },
  "api/CSF.Screenplay.Actors.ActorEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.ActorEventArgs.html",
    "title": "Class ActorEventArgs | Screenplay",
    "summary": "Class ActorEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to an Actor. public class ActorEventArgs : PerformanceScopeEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs Implements IHasPerformanceIdentity Derived GainAbilityEventArgs PerformableEventArgs Inherited Members PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ActorEventArgs(Actor) Initializes a new instance of ActorEventArgs public ActorEventArgs(Actor actor) Parameters actor Actor The actor Properties Actor Gets the name of the actor to which these event arguments relate public Actor Actor { get; } Property Value Actor See Also Actor"
  },
  "api/CSF.Screenplay.Actors.Cast.html": {
    "href": "api/CSF.Screenplay.Actors.Cast.html",
    "title": "Class Cast | Screenplay",
    "summary": "Class Cast Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.dll The default implementation of ICast which serves as a registry/factory for Actor instances. public sealed class Cast : ICast, IHasServiceProvider, IHasPerformanceIdentity, IDisposable Inheritance object Cast Implements ICast IHasServiceProvider IHasPerformanceIdentity IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Cast(IServiceProvider, Guid) Initialises a new instance of Cast. public Cast(IServiceProvider serviceProvider, Guid performanceIdentity) Parameters serviceProvider IServiceProvider A service provider performanceIdentity Guid The identity of the current performance Exceptions ArgumentNullException If serviceProvider is null. Properties PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. ServiceProvider Gets a service provider/resolver instance associated with this object. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods Dispose() public void Dispose() GetActor(IPersona) Gets a single Actor based upon a persona, creating them if they do not already exist in the cast. public Actor GetActor(IPersona persona) Parameters persona IPersona The persona from which to get an actor Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, using the persona as a factory, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast, matched using the IPersona's Name. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified persona name differs only in case. Consider using GetActor<TPersona>(ICast) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. See Also IPersona GetActor(string) Gets a single Actor by their name, creating them if they do not already exist in the cast. public Actor GetActor(string name) Parameters name string The name of the actor to get Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified name differs only in case. If you make use of a same-named actor across multiple performances then it is highly recommended to use personas in order to consistently define the actor's attributes and abilities. You would then use the overload of this method which uses that persona to define the actor. See Also IPersona GetCastList() Gets a collection of string names, indicating the collection of actors which this cast object knows about. public IReadOnlyCollection<string> GetCastList() Returns IReadOnlyCollection<string> A collection of strings, corresponding to the actors which have been created in the lifetime of the current cast instance. Remarks Because a cast instance serves as both a registry and a factory, whenever it is used to get an Actor for the first time, that actor instance is cached within the cast which created it. This method may be used to get a collection of the names of actors which are cached within the current cast instance. Note that the collection returned by this method is a snapshot in time, correct as-at the time when this method is executed. The collection does not update automatically as new actors are added to the cast. You must execute this method again to get an updated collection."
  },
  "api/CSF.Screenplay.Actors.GainAbilityEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.GainAbilityEventArgs.html",
    "title": "Class GainAbilityEventArgs | Screenplay",
    "summary": "Class GainAbilityEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to an actor gaining a new ability. public class GainAbilityEventArgs : ActorEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs GainAbilityEventArgs Implements IHasPerformanceIdentity Inherited Members ActorEventArgs.Actor PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GainAbilityEventArgs(Actor, object) Initializes a new instance of GainAbilityEventArgs. public GainAbilityEventArgs(Actor actor, object ability) Parameters actor Actor The actor ability object The ability Properties Ability Gets the ability which the actor has gained public object Ability { get; } Property Value object"
  },
  "api/CSF.Screenplay.Actors.ICanPerformGiven.html": {
    "href": "api/CSF.Screenplay.Actors.ICanPerformGiven.html",
    "title": "Interface ICanPerformGiven | Screenplay",
    "summary": "Interface ICanPerformGiven Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll An actor which is able to perform in the Given phase of a IPerformance. public interface ICanPerformGiven Extension Methods ActorExtensions.WasAbleTo(ICanPerformGiven, IGetsPerformable, CancellationToken) ActorExtensions.WasAbleTo(ICanPerformGiven, IGetsPerformableWithResult, CancellationToken) ActorExtensions.WasAbleTo<T>(ICanPerformGiven, IGetsPerformableWithResult<T>, CancellationToken) Remarks This interface is conceptually identical to ICanPerform, except that the nomenclature of its methods is written in the past tense, as is best pratice for the Given phase of a performance. Methods WasAbleTo(IPerformable, CancellationToken) Performs an action or task which returns no result. ValueTask WasAbleTo(IPerformable performable, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete WasAbleTo(IPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. ValueTask<object> WasAbleTo(IPerformableWithResult performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete WasAbleTo<T>(IPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. ValueTask<T> WasAbleTo<T>(IPerformableWithResult<T> performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type See Also ICanPerform"
  },
  "api/CSF.Screenplay.Actors.ICanPerformThen.html": {
    "href": "api/CSF.Screenplay.Actors.ICanPerformThen.html",
    "title": "Interface ICanPerformThen | Screenplay",
    "summary": "Interface ICanPerformThen Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll An actor which is able to perform in the Then phase of a IPerformance. public interface ICanPerformThen Extension Methods ActorExtensions.Should(ICanPerformThen, IGetsPerformable, CancellationToken) ActorExtensions.Should(ICanPerformThen, IGetsPerformableWithResult, CancellationToken) ActorExtensions.Should<T>(ICanPerformThen, IGetsPerformableWithResult<T>, CancellationToken) Remarks This interface is conceptually identical to ICanPerform, except that the nomenclature of its methods is written in the future tense, as is best pratice for the Then phase of a performance. Methods Should(IPerformable, CancellationToken) Performs an action or task which returns no result. ValueTask Should(IPerformable performable, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete Should(IPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. ValueTask<object> Should(IPerformableWithResult performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete Should<T>(IPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. ValueTask<T> Should<T>(IPerformableWithResult<T> performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type See Also ICanPerform"
  },
  "api/CSF.Screenplay.Actors.ICanPerformWhen.html": {
    "href": "api/CSF.Screenplay.Actors.ICanPerformWhen.html",
    "title": "Interface ICanPerformWhen | Screenplay",
    "summary": "Interface ICanPerformWhen Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll An actor which is able to perform in the When phase of a IPerformance. public interface ICanPerformWhen Extension Methods ActorExtensions.AttemptsTo(ICanPerformWhen, IGetsPerformable, CancellationToken) ActorExtensions.AttemptsTo(ICanPerformWhen, IGetsPerformableWithResult, CancellationToken) ActorExtensions.AttemptsTo<T>(ICanPerformWhen, IGetsPerformableWithResult<T>, CancellationToken) Remarks This interface is conceptually identical to ICanPerform, except that the nomenclature of its methods is written in the present tense, as is best pratice for the When phase of a performance. In addition, the wording of these methods indicates that the actor is attempting something, which might fail. Methods AttemptsTo(IPerformable, CancellationToken) Performs an action or task which returns no result. ValueTask AttemptsTo(IPerformable performable, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete AttemptsTo(IPerformableWithResult, CancellationToken) Performs an action or task which returns an untyped result. ValueTask<object> AttemptsTo(IPerformableWithResult performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete AttemptsTo<T>(IPerformableWithResult<T>, CancellationToken) Performs an action or task which returns a strongly typed result. ValueTask<T> AttemptsTo<T>(IPerformableWithResult<T> performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type See Also ICanPerform"
  },
  "api/CSF.Screenplay.Actors.IHasPerformableEvents.html": {
    "href": "api/CSF.Screenplay.Actors.IHasPerformableEvents.html",
    "title": "Interface IHasPerformableEvents | Screenplay",
    "summary": "Interface IHasPerformableEvents Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll An actor which may emit events as they participate in a IPerformance public interface IHasPerformableEvents Events BeginPerformable Occurs when the actor begins the execution of a performable object. event EventHandler<PerformableEventArgs> BeginPerformable Event Type EventHandler<PerformableEventArgs> EndPerformable Occurs when an actor ends the execution of a performable object. event EventHandler<PerformableEventArgs> EndPerformable Event Type EventHandler<PerformableEventArgs> GainedAbility Occurs when an actor gains a new ability. event EventHandler<GainAbilityEventArgs> GainedAbility Event Type EventHandler<GainAbilityEventArgs> PerformableFailed Occurs when a performable object fails with an exception. event EventHandler<PerformableFailureEventArgs> PerformableFailed Event Type EventHandler<PerformableFailureEventArgs> PerformableResult Occurs when an actor receives a result from a perfperformable objectrmance. event EventHandler<PerformableResultEventArgs> PerformableResult Event Type EventHandler<PerformableResultEventArgs> RecordsAsset Occurs when an actor records the presence of a new file asset. event EventHandler<PerformableAssetEventArgs> RecordsAsset Event Type EventHandler<PerformableAssetEventArgs>"
  },
  "api/CSF.Screenplay.Actors.PerformableAssetEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.PerformableAssetEventArgs.html",
    "title": "Class PerformableAssetEventArgs | Screenplay",
    "summary": "Class PerformableAssetEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll Event arguments which represent the revealing of a file asset which relates to a performable. public class PerformableAssetEventArgs : PerformableEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs PerformableEventArgs PerformableAssetEventArgs Implements IHasPerformanceIdentity Inherited Members PerformableEventArgs.Performable PerformableEventArgs.Phase ActorEventArgs.Actor PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformableAssetEventArgs(Actor, object, string, string, PerformancePhase) Initializes a new instance of PerformableAssetEventArgs. public PerformableAssetEventArgs(Actor actor, object performable, string filePath, string fileSummary = null, PerformancePhase phase = PerformancePhase.Unspecified) Parameters actor Actor The actor performable object The performable item filePath string The full absolute path to the asset file fileSummary string An optional human-readable summary of the asset file phase PerformancePhase The phase of performance Properties FilePath Gets a full/absolute path to the asset file. public string FilePath { get; } Property Value string FileSummary Gets an optional human-readable summary of what this asset represents. This should be one sentence at most, suitable for display in a UI tool-tip. public string FileSummary { get; } Property Value string See Also RecordAsset(object, string, string)"
  },
  "api/CSF.Screenplay.Actors.PerformableEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.PerformableEventArgs.html",
    "title": "Class PerformableEventArgs | Screenplay",
    "summary": "Class PerformableEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to an actor's use of a performable. public class PerformableEventArgs : ActorEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs PerformableEventArgs Implements IHasPerformanceIdentity Derived PerformableAssetEventArgs PerformableFailureEventArgs PerformableResultEventArgs Inherited Members ActorEventArgs.Actor PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformableEventArgs(Actor, object, PerformancePhase) Initializes a new instance of PerformableEventArgs. public PerformableEventArgs(Actor actor, object performable, PerformancePhase phase = PerformancePhase.Unspecified) Parameters actor Actor The actor performable object The performable item phase PerformancePhase The phase of performance Properties Performable Gets the performable item to which these event arguments relate. public object Performable { get; } Property Value object Phase Gets the performance phase to which these event arguments relate. public PerformancePhase Phase { get; } Property Value PerformancePhase"
  },
  "api/CSF.Screenplay.Actors.PerformableFailureEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.PerformableFailureEventArgs.html",
    "title": "Class PerformableFailureEventArgs | Screenplay",
    "summary": "Class PerformableFailureEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A specialisation of PerformableEventArgs which describe the situation where an exception halted the execution of the performable item. public class PerformableFailureEventArgs : PerformableEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs PerformableEventArgs PerformableFailureEventArgs Implements IHasPerformanceIdentity Inherited Members PerformableEventArgs.Performable PerformableEventArgs.Phase ActorEventArgs.Actor PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformableFailureEventArgs(Actor, object, Exception, PerformancePhase) Initializes a new instance of PerformableFailureEventArgs. public PerformableFailureEventArgs(Actor actor, object performable, Exception exception, PerformancePhase phase = PerformancePhase.Unspecified) Parameters actor Actor The actor performable object The performable item which raised the exception exception Exception The exception which occurred phase PerformancePhase The phase of performance which was underway when the exception occurred Properties Exception Gets the exception which halted the performable item. public Exception Exception { get; } Property Value Exception"
  },
  "api/CSF.Screenplay.Actors.PerformableResultEventArgs.html": {
    "href": "api/CSF.Screenplay.Actors.PerformableResultEventArgs.html",
    "title": "Class PerformableResultEventArgs | Screenplay",
    "summary": "Class PerformableResultEventArgs Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll A specialisation of PerformableEventArgs which describe a scenario in which the performable completed and has returned a result value. public class PerformableResultEventArgs : PerformableEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs ActorEventArgs PerformableEventArgs PerformableResultEventArgs Implements IHasPerformanceIdentity Inherited Members PerformableEventArgs.Performable PerformableEventArgs.Phase ActorEventArgs.Actor PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformableResultEventArgs(Actor, object, object, PerformancePhase) Initializes a new instance of PerformableResultEventArgs. public PerformableResultEventArgs(Actor actor, object performable, object result, PerformancePhase phase = PerformancePhase.Unspecified) Parameters actor Actor The actor performable object The performable item result object The result from the performable phase PerformancePhase The phase of performance Properties Result Gets the result value which was returned by the performable public object Result { get; } Property Value object"
  },
  "api/CSF.Screenplay.Actors.PerformancePhase.html": {
    "href": "api/CSF.Screenplay.Actors.PerformancePhase.html",
    "title": "Enum PerformancePhase | Screenplay",
    "summary": "Enum PerformancePhase Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.Abstractions.dll Enumerates the phases of a performance public enum PerformancePhase Fields Given = 1 The 'Given' phase of a performance is for set-up and fulfilling preconditions In the \"Arrange\", \"Act\", \"Assert\" manner of describing test logic, this phase corresponds to \"Arrange\". In the Given phase, perform whatever tasks/actions are required to set up the test, or in other words, whatever needs to be done so that we can get to the When phase. In a test, if part of the Given performance fails, then it would be reasonable to expect that another test should also be failing. In the context of this single test/performance, the Given phase should be just that - taken as a given. Then = 3 The 'Then' phase of a performance is where the results of the When phase are as expected; is it a pass or a fail? In the \"Arrange\", \"Act\", \"Assert\" manner of describing test logic, this phase corresponds to \"Assert\". In the Then phase, perform whatever is required to conclusively determine whether or not the activity in the When phase was a success or not. Typically this involves using performables which return result values, in order to interrogate the app state. Unspecified = 0 Indicates that no phase has been specified When = 2 The 'When' phase of a performance describes the activity which is under test In the \"Arrange\", \"Act\", \"Assert\" manner of describing test logic, this phase corresponds to \"Act\". In the When phase, the actor(s) should perform the tasks/actions that are being tested; this is the part which matters to the test. Remarks It is common for a IPerformance to occur in phases. This is especially true when Screenplay is being used as a testing tool. This type enumerates the possible phases. If phases are irrelevant to your usage of Screenplay then feel free to use Unspecified, which is the default phase when no phase has been specified."
  },
  "api/CSF.Screenplay.Actors.Stage.html": {
    "href": "api/CSF.Screenplay.Actors.Stage.html",
    "title": "Class Stage | Screenplay",
    "summary": "Class Stage Namespace CSF.Screenplay.Actors Assembly CSF.Screenplay.dll The default implementation of IStage which provides a context for which actor is currently active. public sealed class Stage : IStage, IHasPerformanceIdentity Inheritance object Stage Implements IStage IHasPerformanceIdentity Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Stage(ICast, IRelaysPerformanceEvents) Initialises a new instance of Stage public Stage(ICast cast, IRelaysPerformanceEvents performanceEventBus) Parameters cast ICast The cast performanceEventBus IRelaysPerformanceEvents An event bus for collecting stage-related events Exceptions ArgumentNullException If any parameter value is null Properties Cast Gets the cast to which the current stage is linked. public ICast Cast { get; } Property Value ICast PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. Methods GetSpotlitActor() Gets the actor which is currently in the spotlight. public Actor GetSpotlitActor() Returns Actor The actor who has previously been placed in the spotlight, or a null reference if there is presently no actor in the spotlight. Spotlight(Actor) Places the specified actor into the spotlight, making them 'the current actor' on this stage. public void Spotlight(Actor actor) Parameters actor Actor Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the specified actor. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If the specified actor is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Exceptions ArgumentNullException If the actor is null. Spotlight(IPersona) Places an actor matching the specified persona into the spotlight, making them 'the current actor' on this stage. public Actor Spotlight(IPersona persona) Parameters persona IPersona Returns Actor The actor instance which was placed into the spotlight. Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the actor derived from the persona. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If actor indicated by the persona is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. When spotlighting a persona, the actor instance is retrieved from an ICast based upon that same persona. See GetActor(IPersona) for more information. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Consider using Spotlight<TPersona>(IStage) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. Exceptions ArgumentNullException If the actor is null. TurnSpotlightOff() Removes any existing actor from the spotlight, ensuring that no actor is in the spotlight. public Actor TurnSpotlightOff() Returns Actor If an actor was previously in the spotlight, and has now been removed, then this method returns that actor; otherwise it will return a null reference. Remarks If there was already no actor in the spotlight when this method is executed then it will have no effect, the spotlight will remain empty and this method will return null."
  },
  "api/CSF.Screenplay.Actors.html": {
    "href": "api/CSF.Screenplay.Actors.html",
    "title": "Namespace CSF.Screenplay.Actors | Screenplay",
    "summary": "Namespace CSF.Screenplay.Actors Classes ActorEventArgs A model for event arguments which relate to an Actor. Cast The default implementation of ICast which serves as a registry/factory for Actor instances. GainAbilityEventArgs A model for event arguments which relate to an actor gaining a new ability. PerformableAssetEventArgs Event arguments which represent the revealing of a file asset which relates to a performable. PerformableEventArgs A model for event arguments which relate to an actor's use of a performable. PerformableFailureEventArgs A specialisation of PerformableEventArgs which describe the situation where an exception halted the execution of the performable item. PerformableResultEventArgs A specialisation of PerformableEventArgs which describe a scenario in which the performable completed and has returned a result value. Stage The default implementation of IStage which provides a context for which actor is currently active. Interfaces ICanPerformGiven An actor which is able to perform in the Given phase of a IPerformance. ICanPerformThen An actor which is able to perform in the Then phase of a IPerformance. ICanPerformWhen An actor which is able to perform in the When phase of a IPerformance. IHasPerformableEvents An actor which may emit events as they participate in a IPerformance Enums PerformancePhase Enumerates the phases of a performance"
  },
  "api/CSF.Screenplay.CastAdapter.html": {
    "href": "api/CSF.Screenplay.CastAdapter.html",
    "title": "Class CastAdapter | Screenplay",
    "summary": "Class CastAdapter Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll An adapter which enables the use of ICast within an NUnit3 test, without needing to parameter-inject the instance as Lazy<ICast>. public sealed class CastAdapter : ICast, IHasServiceProvider, IHasPerformanceIdentity Inheritance object CastAdapter Implements ICast IHasServiceProvider IHasPerformanceIdentity Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Due to NUnit architectural limitations, injectable parameters cannot be resolved from DI at the point the test method is built. If we were to attempt this, then the parameter value would not be associated with the correct Screenplay/DI scope (and thus Event Bus). This is due to the two-process model which NUnit uses; one process for building the test methods and another process for running the tests. By using an adapter with Lazy resolution of the real implementation, we ensure that DI resolution is deferred into the test-run process and not the test-building process. Constructors CastAdapter(Guid) Creates a new instance of CastAdapter for the specified performance identity. public CastAdapter(Guid performanceIdentity) Parameters performanceIdentity Guid A performance identity, corresponding to PerformanceIdentity. Properties PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. ServiceProvider Gets a service provider/resolver instance associated with this object. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods GetActor(IPersona) Gets a single Actor based upon a persona, creating them if they do not already exist in the cast. public Actor GetActor(IPersona persona) Parameters persona IPersona The persona from which to get an actor Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, using the persona as a factory, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast, matched using the IPersona's Name. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified persona name differs only in case. Consider using GetActor<TPersona>(ICast) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. See Also IPersona GetActor(string) Gets a single Actor by their name, creating them if they do not already exist in the cast. public Actor GetActor(string name) Parameters name string The name of the actor to get Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified name differs only in case. If you make use of a same-named actor across multiple performances then it is highly recommended to use personas in order to consistently define the actor's attributes and abilities. You would then use the overload of this method which uses that persona to define the actor. See Also IPersona GetCastList() Gets a collection of string names, indicating the collection of actors which this cast object knows about. public IReadOnlyCollection<string> GetCastList() Returns IReadOnlyCollection<string> A collection of strings, corresponding to the actors which have been created in the lifetime of the current cast instance. Remarks Because a cast instance serves as both a registry and a factory, whenever it is used to get an Actor for the first time, that actor instance is cached within the cast which created it. This method may be used to get a collection of the names of actors which are cached within the current cast instance. Note that the collection returned by this method is a snapshot in time, correct as-at the time when this method is executed. The collection does not update automatically as new actors are added to the cast. You must execute this method again to get an updated collection."
  },
  "api/CSF.Screenplay.CastExtensions.html": {
    "href": "api/CSF.Screenplay.CastExtensions.html",
    "title": "Class CastExtensions | Screenplay",
    "summary": "Class CastExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Extension methods for ICast. public static class CastExtensions Inheritance object CastExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetActor<TPersona>(ICast) Gets a single Actor based upon a persona, creating them if they do not already exist in the cast. public static Actor GetActor<TPersona>(this ICast cast) where TPersona : class, IPersona Parameters cast ICast The cast from which to get an actor Returns Actor An actor based on the specified persona, either an existing instance or a newly-created actor. Type Parameters TPersona A concrete type of IPersona from which to get an actor. Remarks This method will create the actor within the current cast, using a resolved instance of the persona as a factory, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast, matched using the IPersona's Name. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified persona name differs only in case. This method is the recommended way of getting an actor from a persona, as it takes care of resolving the persona from dependency injection automatically. See Also IPersona"
  },
  "api/CSF.Screenplay.EnumerableResolutionAdapter-1.html": {
    "href": "api/CSF.Screenplay.EnumerableResolutionAdapter-1.html",
    "title": "Class EnumerableResolutionAdapter<T> | Screenplay",
    "summary": "Class EnumerableResolutionAdapter<T> Namespace CSF.Screenplay Assembly CSF.Screenplay.ReqnrollPlugin.dll Adapter class which - when added to DI - permits the BoDi DI container to resolve arbitrary IEnumerable<T> of service instances. public class EnumerableResolutionAdapter<T> : IEnumerable<T>, IEnumerable where T : class Type Parameters T Inheritance object EnumerableResolutionAdapter<T> Implements IEnumerable<T> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The BoDi DI container which is included in Reqnroll/SpecFlow does not fully support the functionality of Microsoft's DI standard. Notably, it cannot natively resolve an IEnumerable<T>, where type T is a service type which may have multiple implementations added to/registered with the container. BoDi does have conceptually identical functionality, in its ResolveAll<T>() function. The purpose of this type is to provide a mechanism by which BoDi may resolve enumerables of service types. This class wraps an instance of IObjectContainer and - in its GetEnumerator() method - redirects to the ResolveAll<T>() method. The limitation of this type (as a workaround) is that this type must be added to the container manually for each IEnumerable<T> type which could be resolved from the container. Constructors EnumerableResolutionAdapter(IObjectContainer) Initializes a new instance of EnumerableResolutionAdapter<T>. public EnumerableResolutionAdapter(IObjectContainer container) Parameters container IObjectContainer The BoDi object container. Exceptions ArgumentNullException container is null. Methods GetEnumerator() public IEnumerator<T> GetEnumerator() Returns IEnumerator<T>"
  },
  "api/CSF.Screenplay.ICanPerform.html": {
    "href": "api/CSF.Screenplay.ICanPerform.html",
    "title": "Interface ICanPerform | Screenplay",
    "summary": "Interface ICanPerform Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An actor which may perform in the Screenplay. public interface ICanPerform Extension Methods ActorExtensions.GetAbility(ICanPerform, Type) ActorExtensions.GetAbility<T>(ICanPerform) ActorExtensions.HasAbility(ICanPerform, Type) ActorExtensions.HasAbility<T>(ICanPerform) ActorExtensions.IsAbleTo(ICanPerform, object) ActorExtensions.IsAbleTo<TAbility>(ICanPerform) ActorExtensions.PerformAsync(ICanPerform, IGetsPerformable, CancellationToken) ActorExtensions.PerformAsync(ICanPerform, IGetsPerformableWithResult, CancellationToken) ActorExtensions.PerformAsync<T>(ICanPerform, IGetsPerformableWithResult<T>, CancellationToken) ActorExtensions.TryGetAbility(ICanPerform, Type, out object) ActorExtensions.TryGetAbility<T>(ICanPerform, out T) Methods PerformAsync(IPerformable, CancellationToken) Performs an action or task which returns no result. ValueTask PerformAsync(IPerformable performable, CancellationToken cancellationToken = default) Parameters performable IPerformable The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask A task which completes when the performable is complete PerformAsync(IPerformableWithResult, CancellationToken) Performs a question or question-like task which returns an untyped result. ValueTask<object> PerformAsync(IPerformableWithResult performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<object> A task which exposes a result when the performable is complete PerformAsync<T>(IPerformableWithResult<T>, CancellationToken) Performs a question or question-like task which returns a strongly typed result. ValueTask<T> PerformAsync<T>(IPerformableWithResult<T> performable, CancellationToken cancellationToken = default) Parameters performable IPerformableWithResult<T> The performable item cancellationToken CancellationToken An optional token to cancel the performable Returns ValueTask<T> A task which exposes a result when the performable is complete Type Parameters T The result type RecordAsset(object, string, string) Records the existence of a new performable asset file at the specified path. void RecordAsset(object performable, string filePath, string fileSummary = null) Parameters performable object The performable item filePath string The full absolute path to the asset file fileSummary string An optional human-readable summary of the asset file Remarks File assets are sometimes created during a performance as a reporting/verification mechanism. For example a performable which controls the user interface of an application might take and save a screenshot of that UI so that a human may later verify that everything looked as it should. Alternatively, file assets might constitute part of the output of a performance. Imagine an application of Screenplay which captures video from a security camera; that video file would be an asset. This method may be used from performables which generate and save asset files. They ensure that appropriate events are called and passed 'upward' through the Screenplay architecture, such that subscribers may be notified. This will allow the presence and details of assets to be included in Screenplay artifacts such as reports. See Also IPerformable IPerformableWithResult IPerformableWithResult<TResult> IHasAbilities"
  },
  "api/CSF.Screenplay.ICanReport.html": {
    "href": "api/CSF.Screenplay.ICanReport.html",
    "title": "Interface ICanReport | Screenplay",
    "summary": "Interface ICanReport Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A type which can provide a human-readable report fragment when it is used in a IPerformance. public interface ICanReport Remarks It is recommended for all types for Actions, Questions, Tasks (broadly \"Performables\") as well as Abilities to implement this interface. Implementing this interface permits the type to emit a human-readable value for when the type is used in a Performance. For Performables implementing this interface, the report fragment indicates that the performable has been executed in the Performance. For abilities which implement this interface, the report fragment is used when an Actor gains/is granted the ability. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. See Also IPerformable IPerformableWithResult IPerformableWithResult<TResult>"
  },
  "api/CSF.Screenplay.ICast.html": {
    "href": "api/CSF.Screenplay.ICast.html",
    "title": "Interface ICast | Screenplay",
    "summary": "Interface ICast Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A combined registry and factory for Actor instances, useful when coordinating multiple actors across a IPerformance public interface ICast : IHasServiceProvider, IHasPerformanceIdentity Inherited Members IHasServiceProvider.ServiceProvider IHasPerformanceIdentity.PerformanceIdentity Extension Methods CastExtensions.GetActor<TPersona>(ICast) Remarks The cast is a strongly recommended component of Screenplay logic. It is used to manage Actor objects for the duration of a IPerformance. Cast objects are always scoped to a IPerformance and have the same lifetime. Any actors created or tracked by a cast will also automatically share this lifetime. In terms of design patterns, the cast operates as both a registry: https://martinfowler.com/eaaCatalog/registry.html and as a factory: https://en.wikipedia.org/wiki/Factory_method_pattern for actors. During the cast's lifetime, subsequent calls to an overload of GetActor using the same actor/persona name will return the instance of Actor as was created the first time the method was called with that name. A cast, and the actors managed by a cast, are independent per IPerformance, though. Developers are strongly advised to configure their actors via classes which derive from IPersona. This allows for sharing of common actor-setup logic such as abilities. In a Screenplay the cast is a dependency-injectable service which may be used within your performances. Methods GetActor(IPersona) Gets a single Actor based upon a persona, creating them if they do not already exist in the cast. Actor GetActor(IPersona persona) Parameters persona IPersona The persona from which to get an actor Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, using the persona as a factory, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast, matched using the IPersona's Name. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified persona name differs only in case. Consider using GetActor<TPersona>(ICast) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. See Also IPersona GetActor(string) Gets a single Actor by their name, creating them if they do not already exist in the cast. Actor GetActor(string name) Parameters name string The name of the actor to get Returns Actor An actor of the specified name, either an existing instance or a newly-created actor. Remarks This method will create the actor within the current cast, if they do not already exist. Alternatively, this method will return the existing actor, if they already exist in the cast. Actor names are matched using a case-insensitive invariant culture string comparison. Cast implementations should match an existing actor if the specified name differs only in case. If you make use of a same-named actor across multiple performances then it is highly recommended to use personas in order to consistently define the actor's attributes and abilities. You would then use the overload of this method which uses that persona to define the actor. See Also IPersona GetCastList() Gets a collection of string names, indicating the collection of actors which this cast object knows about. IReadOnlyCollection<string> GetCastList() Returns IReadOnlyCollection<string> A collection of strings, corresponding to the actors which have been created in the lifetime of the current cast instance. Remarks Because a cast instance serves as both a registry and a factory, whenever it is used to get an Actor for the first time, that actor instance is cached within the cast which created it. This method may be used to get a collection of the names of actors which are cached within the current cast instance. Note that the collection returned by this method is a snapshot in time, correct as-at the time when this method is executed. The collection does not update automatically as new actors are added to the cast. You must execute this method again to get an updated collection. See Also IStage Actor IPerformance IPersona"
  },
  "api/CSF.Screenplay.IFormatsReportFragment.html": {
    "href": "api/CSF.Screenplay.IFormatsReportFragment.html",
    "title": "Interface IFormatsReportFragment | Screenplay",
    "summary": "Interface IFormatsReportFragment Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A service which produces formatted report fragments from a template and a collection of parameter values. public interface IFormatsReportFragment Methods Format(string, params object[]) Gets the formatted report fragment from the specified template and values. ReportFragment Format(string template, params object[] values) Parameters template string A string template for the report fragment values object[] A collection of values associated with the report fragment Returns ReportFragment A formatted report fragment Examples The following code will produce the final formatted string as noted below. var p1 = \"first\"; var p2 = \"second\"; formatter.Format(\"The values are {p2} and {p1}\", p1, p2); // This will yield the result \"The values are first and second\" Remarks The template should be a human-readable string (localized if you wish) which would be recorded in a Screenplay report. This string may contain any number of placeholder markers which are indicated by some text enclosed within braces, such as {Name}. This functions in a slightly similar fashion to .NET logging: https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-message-template or the Format(string, params object[]) method. Importantly, the placeholders are identified by names, rather than numeric index, in the same way that logging template strings work. Placeholders do not support any kind of format or alignment syntax. Developers are encouraged to choose meaningful names for their placeholders. The ReportFragment which is produced by this method will include the values associated with those placeholder names. This allows reporting infrastructure to work in a similar manner to the way in which structured logging is described in the article linked above. This provides a richer data model than simply a plain string. See Also ReportFragment"
  },
  "api/CSF.Screenplay.IGetsScreenplay.html": {
    "href": "api/CSF.Screenplay.IGetsScreenplay.html",
    "title": "Interface IGetsScreenplay | Screenplay",
    "summary": "Interface IGetsScreenplay Namespace CSF.Screenplay Assembly CSF.Screenplay.dll An object which can fully configure and get a Screenplay instance. public interface IGetsScreenplay Examples The smallest example of a valid implementation of this class, which just gets a default Screenplay with no customizations is: public class ScreenplayFactory : IGetsScreenplay { public Screenplay GetScreenplay() => Screenplay.Create(); } Feel free to customize this example to add a parameter to the Create method, which adds other services to the DI service collection which will be used with the Screenplay. Such services could be those Remarks This interface is particularly important when using Screenplay as a testing tool. Some test integrations do not have any inherent extension points for the placement of 'configuration' or startup logic which affects the entire test run. In those cases, a developer will need to implement this interface with a class of their own, in order to configure and get the Screenplay instance. Types which implement this interface need only implement the GetScreenplay() method, which should build and return a Screenplay instance. Developers are advised to use Create(Action<IServiceCollection>) to create and return the Screenplay. Note that implementations of this type must have a public parameterless constructor, because they will be instantiated via CreateInstance(Type) and not resolved from dependency injection. Methods GetScreenplay() Gets the configured Screenplay instance provided by the current type. Screenplay GetScreenplay() Returns Screenplay A Screenplay instance Remarks Implementors should create and return a new Screenplay instance from this method; they are strongly urged to consider the use of Create(Action<IServiceCollection>) for this purpose. As well as the creation of the Screenplay instance itself, they should also add to the service collection any services which relate to abilities which could be used in the Screenplay. It is recommended to use the parameter to the Create method (above) to configure such services into the DI container."
  },
  "api/CSF.Screenplay.IHasAbilities.html": {
    "href": "api/CSF.Screenplay.IHasAbilities.html",
    "title": "Interface IHasAbilities | Screenplay",
    "summary": "Interface IHasAbilities Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which has & is able to gain abilities. public interface IHasAbilities Extension Methods ActorExtensions.HasAbility(IHasAbilities, Type) ActorExtensions.HasAbility<T>(IHasAbilities) Remarks Abilities are the mechanism by which actors: ICanPerform interact with the application and system. They are arbitrary objects which provide functionality. Properties Abilities Gets the collection of the actor's abilities. IReadOnlyCollection<object> Abilities { get; } Property Value IReadOnlyCollection<object> Methods IsAbleTo(object) Adds an ability to the specified actor void IsAbleTo(object ability) Parameters ability object The ability to add to the actor Exceptions ArgumentNullException If ability is null InvalidOperationException If the actor already has an ability of the same type as ability, or which derives from the same type"
  },
  "api/CSF.Screenplay.IHasName.html": {
    "href": "api/CSF.Screenplay.IHasName.html",
    "title": "Interface IHasName | Screenplay",
    "summary": "Interface IHasName Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A part of a Screenplay performance which has a human-readable name. public interface IHasName Remarks Use this interface for any object within an IPerformance which could benefit from having a human-readable name. For example, static parameter values like Web API endpoints, web page URLs or elements on a web UI. By referring to an object by its name, and using that name in report-generating logic, reports generated from a Screenplay can become much easier to read and comprehend. The Name property is used to provide a human-readable string which represents the object in the report text. This interface is a part of the mechanism for formatting values in reports in Screenplay. Properties Name Gets the human-readable name of the current object. string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. See Also IFormattableValue IValueFormatter"
  },
  "api/CSF.Screenplay.IHasPerformanceIdentity.html": {
    "href": "api/CSF.Screenplay.IHasPerformanceIdentity.html",
    "title": "Interface IHasPerformanceIdentity | Screenplay",
    "summary": "Interface IHasPerformanceIdentity Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which provides a value which uniquely identifies the currently-executing IPerformance. public interface IHasPerformanceIdentity Properties PerformanceIdentity Gets the unique IPerformance identifier Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay."
  },
  "api/CSF.Screenplay.IHasServiceProvider.html": {
    "href": "api/CSF.Screenplay.IHasServiceProvider.html",
    "title": "Interface IHasServiceProvider | Screenplay",
    "summary": "Interface IHasServiceProvider Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which has an associated IServiceProvider, which resolves services from dependency injection. public interface IHasServiceProvider Properties ServiceProvider Gets a service provider/resolver instance associated with this object. IServiceProvider ServiceProvider { get; } Property Value IServiceProvider"
  },
  "api/CSF.Screenplay.IHostsPerformance.html": {
    "href": "api/CSF.Screenplay.IHostsPerformance.html",
    "title": "Interface IHostsPerformance | Screenplay",
    "summary": "Interface IHostsPerformance Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which encapsulates the logic of an IPerformance in a standalone Screenplay. public interface IHostsPerformance Remarks Implementors should inject any dependencies they require into their constructors. The ExecutePerformanceAsync(CancellationToken) method is used to execute the logic of an IPerformance, returning its result. Methods ExecutePerformanceAsync(CancellationToken) Executes the logic of a performance, returning the result. Task<bool?> ExecutePerformanceAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A cancellation token Returns Task<bool?> A task which exposes the result of the performance. Remarks The result of the performance has the same semantics as FinishPerformance(bool?). Implementors should use this method to execute the logic of the performance."
  },
  "api/CSF.Screenplay.IPerformable.html": {
    "href": "api/CSF.Screenplay.IPerformable.html",
    "title": "Interface IPerformable | Screenplay",
    "summary": "Interface IPerformable Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which represents something that a performer (typically an actor) may perform. public interface IPerformable Remarks Performable objects generally fall into one of three categories in Screenplay: An action, which is the most fine-grained type of performable, typically \"doing something which alters the state of the application\" A question, which is fine-grained like an action but instead reads state without changing it A task, which may be composed of actions, questions or even other tasks Objects which implement only this interface are the simplest types of performables; they simply 'do something' and then finish. In the list given above these are typically actions. They do not return any form of result except completion. If you wish to get a result from the performable then consider implementing an interface derived from this one, such as IPerformableWithResult or its strongly-typed counterpart IPerformableWithResult<TResult>. When implementing this interface, consider also implementing ICanReport. If a performable does not implement ICanReport then it will receive default text when the IPerformance report is generated. Implementing ICanReport allows a performable to provide a customised human-readable report fragment. Methods PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also IPerformableWithResult IPerformableWithResult<TResult>"
  },
  "api/CSF.Screenplay.IPerformableWithResult-1.html": {
    "href": "api/CSF.Screenplay.IPerformableWithResult-1.html",
    "title": "Interface IPerformableWithResult<TResult> | Screenplay",
    "summary": "Interface IPerformableWithResult<TResult> Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which represents something that a performer (typically an actor) may perform and which returns a strongly-typed result when it completes. public interface IPerformableWithResult<TResult> Type Parameters TResult Remarks Performable objects generally fall into one of three categories in Screenplay: An action, which is the most fine-grained type of performable, typically \"doing something which alters the state of the application\" A question, which is fine-grained like an action but instead reads state without changing it A task, which may be composed of actions, questions or even other tasks Objects which implement this interface are questions or tasks which are composed (at least in-part) from one or more questions. If you do not wish to get a result from the performable then implement only IPerformable instead. When implementing this interface, consider also implementing ICanReport. If a performable does not implement ICanReport then it will receive default text when the IPerformance report is generated. Implementing ICanReport allows a performable to provide a customised human-readable report fragment. Methods PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. ValueTask<TResult> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TResult> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete. See Also IPerformable IPerformableWithResult"
  },
  "api/CSF.Screenplay.IPerformableWithResult.html": {
    "href": "api/CSF.Screenplay.IPerformableWithResult.html",
    "title": "Interface IPerformableWithResult | Screenplay",
    "summary": "Interface IPerformableWithResult Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll An object which represents something that a performer (typically an actor) may perform and which returns a result when it completes. public interface IPerformableWithResult Remarks Performable objects generally fall into one of three categories in Screenplay: An action, which is the most fine-grained type of performable, typically \"doing something which alters the state of the application\" A question, which is fine-grained like an action but instead reads state without changing it A task, which may be composed of actions, questions or even other tasks Objects which implement this interface are questions or tasks which are composed (at least in-part) from one or more questions. If you do not wish to get a result from the performable then implement only IPerformable instead. Alternatively, if you wish to return a strongly-typed result then instead consider implementing IPerformableWithResult<TResult>. When implementing this interface, consider also implementing ICanReport. If a performable does not implement ICanReport then it will receive default text when the IPerformance report is generated. Implementing ICanReport allows a performable to provide a customised human-readable report fragment. Methods PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a value. ValueTask<object> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<object> A task which exposes a 'result' value when the performable represented by the current instance is complete. See Also IPerformable IPerformableWithResult<TResult>"
  },
  "api/CSF.Screenplay.IPerformance.html": {
    "href": "api/CSF.Screenplay.IPerformance.html",
    "title": "Interface IPerformance | Screenplay",
    "summary": "Interface IPerformance Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A Performance corresponds to a self-contained scope of Performables, performed by Actors, which results in success or failure. public interface IPerformance : IHasPerformanceIdentity, IHasServiceProvider, IDisposable, IBeginsAndEndsPerformance Inherited Members IHasPerformanceIdentity.PerformanceIdentity IHasServiceProvider.ServiceProvider IDisposable.Dispose() IBeginsAndEndsPerformance.BeginPerformance() IBeginsAndEndsPerformance.FinishPerformance(bool?) Remarks In Screenplay, a performance is .NET logic involving one or more Actor instances, executing one or more performable items. A Screenplay will be comprised of one or more performances. In practice a performance object, deriving from this interface, often corresponds to a .NET method in some manner. The method might be regular application logic or it might be a Test/Scenario, using the semantics of an applicable testing framework. The performance object (deriving from this interface) provides a name for the method (the performance name) as well as tracking its running-state. When using BDD-style testing frameworks, there might be a single .NET method to which the performance is linked. Nevertheless, a performance defines an execution scope (with a beginning and end). Even if that scope does not correspond neatly to a single method, it exists regardless. The body of a performance method typically creates one or more Actor via the IStage and then has the actor execute one or more performables. Particularly when using Screenplay for automated testing, these performables are organised into a beginning, middle and end, corresponding to the \"Given, When, Then\" design popular in testing. These three phases are included for use in Screenplay, declared in PerformancePhase. The use of performance phases is optional, although encouraged. Every performance method should return a result, indicating whether the performance was a success. A successful performance is one which progressed from beginning to end, and every step (performable) operated in the manner in which was expected. Additionally, when using Screenplay for software testing, a performance is a success if all its _assertions_ pass. A succesful performance should return true from its performance method. An unsuccessful one should return false. As noted above, when Screenplay is being used for automated testing, the performance method corresponds directly to a single test. In the testing framework that might be called a \"scenario\", a \"test\", a \"test case\", or a \"theory\". When using Screenplay within a testing integration, the performance corresponds very closely to the current Scenario. The object which implements this interface is the representation of the the method described above. One instance of this type - \"the performance object\" - corresponds to one execution of such a method. The performance object also corresponds to the lifetime of a dependency injection scope; a new scope is created for each performance. Within a DI scope, the performance object is an injectable service. You may wish to read a diagram showing how screenplays, performances, actors and performables relate to one another. Properties NamingHierarchy Gets an ordered list of identifiers which indicate the current performance's name within an organisational hierarchy. IReadOnlyList<IdentifierAndName> NamingHierarchy { get; } Property Value IReadOnlyList<IdentifierAndName> Examples If the current performance is to be named Joe can take out the Trash, and it is part of a parent name, named Joe can do his chores then the first identifier in the list will be named Joe can do his chores and the second will be named Joe can take out the Trash. Remarks A Screenplay typically contains more than one performance and may contain many. It is normal to organise performances into a hierarchical structure based upon their purpose, role or relationship. The position of the current performance in that naming structure is represented by the value of this property. The ordered list of IdentifierAndName instances indicate a path from the 'root' of the hierarchy (which has no inherent name) to the current performance. Identifier/name pairs which are earlier in the collection are considered to be closer to the root, whereas latter identifier/names are branch & leaf names. In this manner, they work very similarly to .NET namespaces. The earlier in the list that a name appears, the more general it should be, representing a wider category. When using Screenplay with Integration, this hierarchy of names would typically correspond to the naming convention used by the testing framework. That might be based upon .NET namespaces, classes and test methods for a more traditional unit testing framework. Alternatively, for a BDD-style testing framework, it could be named based upon human-readable feature & scenario names. PerformanceState Gets a value which indicates the state of the current performance. PerformanceState PerformanceState { get; } Property Value PerformanceState See Also PerformanceState"
  },
  "api/CSF.Screenplay.IPersona.html": {
    "href": "api/CSF.Screenplay.IPersona.html",
    "title": "Interface IPersona | Screenplay",
    "summary": "Interface IPersona Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A persona is a factory for a commonly-used Actor public interface IPersona : IHasName Inherited Members IHasName.Name Remarks In Screenplay is is recommended to use & reuse memorable actors, which are widely understood and recognisable to the development team. This is easier if the composition of an actor is the same across every IPerformance in which they participate. Personas facilitate this; the persona class serves as a consistent factory which creates the same named actor in the same manner every time. Developers should create an implementation of this interface for each actor which they wish to define, ideally named the same as the name as the Actor. Each persona implementation should name the actor and grant them the abilities which are appropriate. Instance of persona classes are resolved from the Dependency Injection container, so it is appropriate and correct to constructor-inject any services which are required in order to get the ability instances. Methods GetActor(Guid) Gets the actor which is associated with the current persona Actor GetActor(Guid performanceIdentity) Parameters performanceIdentity Guid A unique identity for the currently-executing performance Returns Actor Remarks Implementors should not only create and return the actor from this method, but also configure the actor with the standard abilities associated with this persona."
  },
  "api/CSF.Screenplay.IStage.html": {
    "href": "api/CSF.Screenplay.IStage.html",
    "title": "Interface IStage | Screenplay",
    "summary": "Interface IStage Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll The stage facilitates a contextual Actor who is 'in the spotlight' - a currently-active actor public interface IStage Extension Methods StageExtensions.Spotlight<TPersona>(IStage) Examples Consider a IPerformance which is based upon the following, which is described in Gherkin BDD syntax: https://cucumber.io/docs/gherkin/. Given Jack can wash dishes And Jack has filled a basin with hot water When Jack washes a dinner plate Then Jack should have one clean dinner plate This format of test is perfectly functional, but each performable item needed to be qualified with the actor's name: \"Jack\". This could be more human-readable but also more reusable from a code perspective if we had a context of a 'current' actor, who we could refer to with a pronoun. With such a concept, our gherkin could read \"he has\" or \"he washes\" and could accept any one of a variety of pronouns. Remarks The Stage is an optional but recommended component of Screenplay, useful when a IPerformance involves repeated use of an Actor. It facilitates the use of passive voice and the use of pronouns within the logic of performances without needing to frequently repeat the Name of the actor. It is often more consise and easier to understand performances when some of the steps use the passive voice. In order to do this, there must be a concept which allows us to discern \"which actor is acting at the moment\". The stage provides this via the concept of a Spotlight. Either zero or one actor may be in the spotlight at any given time. If a new actor is placed in the spotlight then the previous actor is removed from it. Spotlighting an actor facilitates performance steps which use 'the current actor' instead of a specific named actor. The lifetime of a stage instance is equal to the lifetime of the current IPerformance. An actor in the spotlight will be consistent across the lifetime of the performance but will be independent of other performances. In a Screenplay the stage is a dependency-injectable service which may be used within your performances. The stage implicitly consumes some functionality from the ICast. If Spotlight(IPersona) is used, then the Actor to put in the spotlight will implicitly be retrieved using the cast, via GetActor(IPersona). Properties Cast Gets the cast to which the current stage is linked. ICast Cast { get; } Property Value ICast Methods GetSpotlitActor() Gets the actor which is currently in the spotlight. Actor GetSpotlitActor() Returns Actor The actor who has previously been placed in the spotlight, or a null reference if there is presently no actor in the spotlight. Spotlight(Actor) Places the specified actor into the spotlight, making them 'the current actor' on this stage. void Spotlight(Actor actor) Parameters actor Actor Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the specified actor. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If the specified actor is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Exceptions ArgumentNullException If the actor is null. Spotlight(IPersona) Places an actor matching the specified persona into the spotlight, making them 'the current actor' on this stage. Actor Spotlight(IPersona persona) Parameters persona IPersona Returns Actor The actor instance which was placed into the spotlight. Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the actor derived from the persona. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If actor indicated by the persona is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. When spotlighting a persona, the actor instance is retrieved from an ICast based upon that same persona. See GetActor(IPersona) for more information. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Consider using Spotlight<TPersona>(IStage) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. Exceptions ArgumentNullException If the actor is null. TurnSpotlightOff() Removes any existing actor from the spotlight, ensuring that no actor is in the spotlight. Actor TurnSpotlightOff() Returns Actor If an actor was previously in the spotlight, and has now been removed, then this method returns that actor; otherwise it will return a null reference. Remarks If there was already no actor in the spotlight when this method is executed then it will have no effect, the spotlight will remain empty and this method will return null. See Also ICast"
  },
  "api/CSF.Screenplay.JsonToHtmlReport.IConvertsReportJsonToHtml.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.IConvertsReportJsonToHtml.html",
    "title": "Interface IConvertsReportJsonToHtml | Screenplay",
    "summary": "Interface IConvertsReportJsonToHtml Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll An object which can convert a JSON Screenplay report to an HTML format. public interface IConvertsReportJsonToHtml Methods ConvertAsync(ReportConverterOptions) Converts the JSON Screenplay report data to HTML asynchronously. Task ConvertAsync(ReportConverterOptions options) Parameters options ReportConverterOptions The options for the report conversion. Returns Task A task that represents the asynchronous operation."
  },
  "api/CSF.Screenplay.JsonToHtmlReport.IGetsHtmlTemplate.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.IGetsHtmlTemplate.html",
    "title": "Interface IGetsHtmlTemplate | Screenplay",
    "summary": "Interface IGetsHtmlTemplate Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll Provides functionality to read the HTML template. public interface IGetsHtmlTemplate Methods ReadTemplate() Reads the HTML template as a string. Task<string> ReadTemplate() Returns Task<string>"
  },
  "api/CSF.Screenplay.JsonToHtmlReport.Program.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.Program.html",
    "title": "Class Program | Screenplay",
    "summary": "Class Program Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll The main entry point class for the JSON to HTML report converter application. public static class Program Inheritance object Program Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Main(string[]) The main entry point method for the JSON to HTML report converter application. public static void Main(string[] args) Parameters args string[] The command-line arguments. Remarks This method scaffolds the application using the Generic Host pattern, then runs that host. This method is available only when the project is built as an executable. It is unavailable for the netstandard2.0 target framework."
  },
  "api/CSF.Screenplay.JsonToHtmlReport.ReportConverter.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.ReportConverter.html",
    "title": "Class ReportConverter | Screenplay",
    "summary": "Class ReportConverter Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll Provides functionality to convert JSON reports to HTML format. public class ReportConverter : IConvertsReportJsonToHtml Inheritance object ReportConverter Implements IConvertsReportJsonToHtml Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ReportConverter(IGetsHtmlTemplate) Initializes a new instance of the ReportConverter class. public ReportConverter(IGetsHtmlTemplate templateReader) Parameters templateReader IGetsHtmlTemplate The template reader used to get the HTML template. Methods ConvertAsync(ReportConverterOptions) Converts the JSON Screenplay report data to HTML asynchronously. public Task ConvertAsync(ReportConverterOptions options) Parameters options ReportConverterOptions The options for the report conversion. Returns Task A task that represents the asynchronous operation."
  },
  "api/CSF.Screenplay.JsonToHtmlReport.ReportConverterApplication.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.ReportConverterApplication.html",
    "title": "Class ReportConverterApplication | Screenplay",
    "summary": "Class ReportConverterApplication Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll An application/background service that begins the JSON to HTML report conversion process. public class ReportConverterApplication : IHostedService Inheritance object ReportConverterApplication Implements IHostedService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ReportConverterApplication(IOptions<ReportConverterOptions>, IConvertsReportJsonToHtml, IHostApplicationLifetime) Initializes a new instance of the ReportConverterApplication class. public ReportConverterApplication(IOptions<ReportConverterOptions> options, IConvertsReportJsonToHtml reportConverter, IHostApplicationLifetime lifetime) Parameters options IOptions<ReportConverterOptions> The options for performing the conversion. reportConverter IConvertsReportJsonToHtml The report converter instance to use for conversion. lifetime IHostApplicationLifetime The application lifetime Methods StartAsync(CancellationToken) Executes the application, to perform its work. public Task StartAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A cancellation token Returns Task A task StopAsync(CancellationToken) Unused, always returns a completed task. public Task StopAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A cancellation token Returns Task A task"
  },
  "api/CSF.Screenplay.JsonToHtmlReport.ReportConverterOptions.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.ReportConverterOptions.html",
    "title": "Class ReportConverterOptions | Screenplay",
    "summary": "Class ReportConverterOptions Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll Options for converting a JSON report to HTML. public class ReportConverterOptions Inheritance object ReportConverterOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties OutputPath Gets or sets the file system path where the HTML report will be saved. public string OutputPath { get; set; } Property Value string ReportPath Gets or sets the file system path to the JSON report which is to be converted to HTML. public string ReportPath { get; set; } Property Value string"
  },
  "api/CSF.Screenplay.JsonToHtmlReport.ServiceRegistrations.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.ServiceRegistrations.html",
    "title": "Class ServiceRegistrations | Screenplay",
    "summary": "Class ServiceRegistrations Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll Provides methods to register services for the JsonToHtmlReport application (or library). public static class ServiceRegistrations Inheritance object ServiceRegistrations Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This type is consumed by the JSON to HTML report converter when it is built as an application, but it may also be used when consuming this project as a library, for integrating it into other solutions. Methods RegisterServices(IServiceCollection) Registers the services required for the JsonToHtmlReport application (or library). public static void RegisterServices(IServiceCollection services) Parameters services IServiceCollection The service collection to which the services will be added."
  },
  "api/CSF.Screenplay.JsonToHtmlReport.TemplateReader.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.TemplateReader.html",
    "title": "Class TemplateReader | Screenplay",
    "summary": "Class TemplateReader Namespace CSF.Screenplay.JsonToHtmlReport Assembly CSF.Screenplay.JsonToHtmlReport.dll Provides functionality to read the HTML template which is embedded as a resource into the current assembly. public class TemplateReader : IGetsHtmlTemplate Inheritance object TemplateReader Implements IGetsHtmlTemplate Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ReadTemplate() Reads the HTML template which is embedded as a resource into the current assembly. public Task<string> ReadTemplate() Returns Task<string> The HTML template as a string."
  },
  "api/CSF.Screenplay.JsonToHtmlReport.html": {
    "href": "api/CSF.Screenplay.JsonToHtmlReport.html",
    "title": "Namespace CSF.Screenplay.JsonToHtmlReport | Screenplay",
    "summary": "Namespace CSF.Screenplay.JsonToHtmlReport Classes Program The main entry point class for the JSON to HTML report converter application. ReportConverter Provides functionality to convert JSON reports to HTML format. ReportConverterApplication An application/background service that begins the JSON to HTML report conversion process. ReportConverterOptions Options for converting a JSON report to HTML. ServiceRegistrations Provides methods to register services for the JsonToHtmlReport application (or library). TemplateReader Provides functionality to read the HTML template which is embedded as a resource into the current assembly. Interfaces IConvertsReportJsonToHtml An object which can convert a JSON Screenplay report to an HTML format. IGetsHtmlTemplate Provides functionality to read the HTML template."
  },
  "api/CSF.Screenplay.ObjectContainerExtensions.html": {
    "href": "api/CSF.Screenplay.ObjectContainerExtensions.html",
    "title": "Class ObjectContainerExtensions | Screenplay",
    "summary": "Class ObjectContainerExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.ReqnrollPlugin.dll Extension methods for the Reqnroll/SpecFlow \"BoDi\" DI container. public static class ObjectContainerExtensions Inheritance object ObjectContainerExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ToServiceCollection(IObjectContainer) Gets an adapter object which permits limited use of the BoDi IObjectContainer as if it were an IServiceCollection. public static IServiceCollection ToServiceCollection(this IObjectContainer bodiContainer) Parameters bodiContainer IObjectContainer A Reqnroll/SpecFlow BoDi DI container. Returns IServiceCollection An adapter object which implements some of the functionality of IServiceCollection Remarks Note that this is an imperfect solution. The BoDi container shipped with Reqnroll/SpecFlow does not support all the functionality which is expected from IServiceCollection. Many methods of the returned object will throw NotSupportedException if attempts are made to use them (a known LSP violation). Additionally, not all service collection DI behaviour will operate in the same manner when using this adapter. In short \"your mileage may vary\". However, for the most simple of usages, this enables the use of \"Add to DI\" logic which has been crafted for service collection, in such a way that services may be added to the BoDi container without additional logic. ToServiceProvider(IObjectContainer) Gets an adapter object which permits the use of the BoDi IObjectContainer as if it were an IServiceProvider. public static IServiceProvider ToServiceProvider(this IObjectContainer bodiContainer) Parameters bodiContainer IObjectContainer A Reqnroll/SpecFlow BoDi DI container. Returns IServiceProvider An adapter object which implements the functionality of IServiceProvider"
  },
  "api/CSF.Screenplay.Performables.IGetsPerformable.html": {
    "href": "api/CSF.Screenplay.Performables.IGetsPerformable.html",
    "title": "Interface IGetsPerformable | Screenplay",
    "summary": "Interface IGetsPerformable Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An object which can get an IPerformable instance, such as a performable builder. public interface IGetsPerformable Methods GetPerformable() Gets the performable object from the current instance. IPerformable GetPerformable() Returns IPerformable A performable object"
  },
  "api/CSF.Screenplay.Performables.IGetsPerformableWithResult-1.html": {
    "href": "api/CSF.Screenplay.Performables.IGetsPerformableWithResult-1.html",
    "title": "Interface IGetsPerformableWithResult<TResult> | Screenplay",
    "summary": "Interface IGetsPerformableWithResult<TResult> Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An object which can get an IPerformableWithResult<TResult> instance, such as a performable builder. public interface IGetsPerformableWithResult<TResult> Type Parameters TResult Methods GetPerformable() Gets the performable object from the current instance. IPerformableWithResult<TResult> GetPerformable() Returns IPerformableWithResult<TResult> A performable object"
  },
  "api/CSF.Screenplay.Performables.IGetsPerformableWithResult.html": {
    "href": "api/CSF.Screenplay.Performables.IGetsPerformableWithResult.html",
    "title": "Interface IGetsPerformableWithResult | Screenplay",
    "summary": "Interface IGetsPerformableWithResult Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An object which can get a non-generic IPerformableWithResult instance, such as a performable builder. public interface IGetsPerformableWithResult Methods GetPerformable() Gets the performable object from the current instance. IPerformableWithResult GetPerformable() Returns IPerformableWithResult A performable object"
  },
  "api/CSF.Screenplay.Performables.IProvidesTimeSpan.html": {
    "href": "api/CSF.Screenplay.Performables.IProvidesTimeSpan.html",
    "title": "Interface IProvidesTimeSpan | Screenplay",
    "summary": "Interface IProvidesTimeSpan Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll A type which may provide a TimeSpan. public interface IProvidesTimeSpan Remarks Many performables make use of time; this interface provides a common abstraction for objects that provide time spans. Methods GetTimeSpan() Gets the TimeSpan which is exposed by the current instance. TimeSpan GetTimeSpan() Returns TimeSpan The time span See Also TimeSpanBuilder<TOtherBuilder> TimeSpanBuilder"
  },
  "api/CSF.Screenplay.Performables.PerformableException.html": {
    "href": "api/CSF.Screenplay.Performables.PerformableException.html",
    "title": "Class PerformableException | Screenplay",
    "summary": "Class PerformableException Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll Thrown when a Performable fails with an unexpected exception. public class PerformableException : Exception, ISerializable Inheritance object Exception PerformableException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Remarks This exception type is rethrown from the Actor when they are executing the performable, in order to provide further context about where the error has occurred. Constructors PerformableException() Initialises a new instance of PerformableException. public PerformableException() PerformableException(string) Initialises a new instance of PerformableException. public PerformableException(string message) Parameters message string The exception message PerformableException(string, Exception) Initialises a new instance of PerformableException. public PerformableException(string message, Exception inner) Parameters message string The exception message inner Exception The inner exception Properties Performable Gets or sets a reference to the Performable object which was the cause of the exception. public object Performable { get; set; } Property Value object"
  },
  "api/CSF.Screenplay.Performables.ReadTheStopwatch.html": {
    "href": "api/CSF.Screenplay.Performables.ReadTheStopwatch.html",
    "title": "Class ReadTheStopwatch | Screenplay",
    "summary": "Class ReadTheStopwatch Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An action which reads the current value of the stopwatch. public class ReadTheStopwatch : IPerformableWithResult<TimeSpan>, ICanReport Inheritance object ReadTheStopwatch Implements IPerformableWithResult<TimeSpan> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This performable requires the actor has the ability UseAStopwatch. Use this performable via the builder method ReadTheStopwatch(). Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<TimeSpan> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TimeSpan> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Performables.ResetTheStopwatch.html": {
    "href": "api/CSF.Screenplay.Performables.ResetTheStopwatch.html",
    "title": "Class ResetTheStopwatch | Screenplay",
    "summary": "Class ResetTheStopwatch Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An action which resets the stopwatch. public class ResetTheStopwatch : IPerformable, ICanReport Inheritance object ResetTheStopwatch Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This performable requires the actor has the ability UseAStopwatch. Use this performable via the builder method ResetTheStopwatch(). Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Performables.StartTheStopwatch.html": {
    "href": "api/CSF.Screenplay.Performables.StartTheStopwatch.html",
    "title": "Class StartTheStopwatch | Screenplay",
    "summary": "Class StartTheStopwatch Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An action which starts the stopwatch. public class StartTheStopwatch : IPerformable, ICanReport Inheritance object StartTheStopwatch Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This performable requires the actor has the ability UseAStopwatch. Use this performable via the builder method StartTheStopwatch(). Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Performables.StopTheStopwatch.html": {
    "href": "api/CSF.Screenplay.Performables.StopTheStopwatch.html",
    "title": "Class StopTheStopwatch | Screenplay",
    "summary": "Class StopTheStopwatch Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll An action which stops the stopwatch. public class StopTheStopwatch : IPerformable, ICanReport Inheritance object StopTheStopwatch Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This performable requires the actor has the ability UseAStopwatch. Use this performable via the builder method StopTheStopwatch(). Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Performables.StopwatchBuilder.html": {
    "href": "api/CSF.Screenplay.Performables.StopwatchBuilder.html",
    "title": "Class StopwatchBuilder | Screenplay",
    "summary": "Class StopwatchBuilder Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll A builder for actions relating to the UseAStopwatch ability. public static class StopwatchBuilder Inheritance object StopwatchBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks When using this class it is recommended to include using static CSF.Screenplay.Performables.StopwatchBuilder; in the source file which uses it. This will allow you use the method names in this class in a more human-readable fashion. The actions and the question exposed by this builder allow an actor to accurately track and measure time elapsed during a Performance. Methods ReadTheStopwatch() Gets a performable which reads the stopwatch. public static ReadTheStopwatch ReadTheStopwatch() Returns ReadTheStopwatch Remarks Use of this performable requires the actor has the UseAStopwatch ability. ResetTheStopwatch() Gets a performable which resets the stopwatch to zero. public static ResetTheStopwatch ResetTheStopwatch() Returns ResetTheStopwatch Remarks Use of this performable requires the actor has the UseAStopwatch ability. StartTheStopwatch() Gets a performable which starts the stopwatch. public static StartTheStopwatch StartTheStopwatch() Returns StartTheStopwatch Remarks Use of this performable requires the actor has the UseAStopwatch ability. StopTheStopwatch() Gets a performable which stops the stopwatch. public static StopTheStopwatch StopTheStopwatch() Returns StopTheStopwatch Remarks Use of this performable requires the actor has the UseAStopwatch ability."
  },
  "api/CSF.Screenplay.Performables.TimeSpanBuilder-1.html": {
    "href": "api/CSF.Screenplay.Performables.TimeSpanBuilder-1.html",
    "title": "Class TimeSpanBuilder<TOtherBuilder> | Screenplay",
    "summary": "Class TimeSpanBuilder<TOtherBuilder> Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll A supplementary builder type which enables the collection of TimeSpan instances. public class TimeSpanBuilder<TOtherBuilder> : IProvidesTimeSpan where TOtherBuilder : class Type Parameters TOtherBuilder The builder type for which this builder will supplement Inheritance object TimeSpanBuilder<TOtherBuilder> Implements IProvidesTimeSpan Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples The example below shows how the time span builder is intended to be used. It is consumed from within another builder, which needs to include a developer-configurable time span. See the documentation for writing performable builders for more information about the makeup of the EatLunchPerformableBuilder. public class EatLunchPerformableBuilder : IGetsPerformable { IProvidesTimeSpan? timeSpanBuilder; protected string? FoodName { get; init; } IPerformable IGetsPerformable.GetPerformable() => new EatLunch(FoodName, timeSpanBuilder?.GetTimeSpan() ?? TimeSpan.Zero); public TimeSpanBuilder<EatLunchPerformableBuilder> For(int howMany) { var builder = TimeSpanBuilder.Create(this, howMany); timeSpanBuilder = builder; return builder; } public static EatLunchPerformableBuilder Eat(string foodName) => new EatLunchPerformableBuilder() { FoodName = foodName }; } The sample builder above would be used to build an instance of a (fictitious) EachLunch performable, which derives from IPerformable. The fictitious performable requires two parameters; the name of the food being eaten for lunch and how long the lunch break lasts. The time span builder is used for that second parameter. A consumer which uses this builder in an IPerformance, or another performable, might consume it as follows. using static EatLunchPerformableBuilder; // ... actor.PerformAsync(Eat(\"Sandwiches\").For(30).Minutes(), cancellationToken); A note for developers with access to the source code for this library. There is a small integration test which sets up and exercises the example above; it is named TimeSpanBuilderTests. Remarks When consuming Performable objects it is recommended to use the builder pattern to create them. A commonly-used 'parameter' which may be specified in builders is 'an amount of time', IE a TimeSpan. This builder is intended to supplement another builder, for the purpose of specifying an amount of time. The 'other' builder is passed as a constructor parameter to this builder, along with an absolute amount. The consumer should then execute one of the methods of this type, which selects the unit of time and thus determines the TimeSpan value. The method which determines the units then returns that other builder instance, allowing the building process to continue with that other builder. Whilst it is possible to create instances of this type via its public constructor, it is often easier to create instances using the static TimeSpanBuilder class. Constructors TimeSpanBuilder(TOtherBuilder, int) Initializes a new instance of TimeSpanBuilder<TOtherBuilder>. public TimeSpanBuilder(TOtherBuilder otherBuilder, int value) Parameters otherBuilder TOtherBuilder The other builder which shall be supplemented by this value int The absolute value of time, but without units Exceptions ArgumentNullException If otherBuilder is null. ArgumentOutOfRangeException If value is less than zero. Methods Days() Configures the contained time span to be measured in days, then returns the contained builder. public TOtherBuilder Days() Returns TOtherBuilder Hours() Configures the contained time span to be measured in hours, then returns the contained builder. public TOtherBuilder Hours() Returns TOtherBuilder Milliseconds() Configures the contained time span to be measured in milliseconds, then returns the contained builder. public TOtherBuilder Milliseconds() Returns TOtherBuilder Minutes() Configures the contained time span to be measured in minutes, then returns the contained builder. public TOtherBuilder Minutes() Returns TOtherBuilder Seconds() Configures the contained time span to be measured in seconds, then returns the contained builder. public TOtherBuilder Seconds() Returns TOtherBuilder See Also Create<TOtherBuilder>(TOtherBuilder, int)"
  },
  "api/CSF.Screenplay.Performables.TimeSpanBuilder.html": {
    "href": "api/CSF.Screenplay.Performables.TimeSpanBuilder.html",
    "title": "Class TimeSpanBuilder | Screenplay",
    "summary": "Class TimeSpanBuilder Namespace CSF.Screenplay.Performables Assembly CSF.Screenplay.Abstractions.dll Static helper class for creating instances of TimeSpanBuilder<TOtherBuilder>. public static class TimeSpanBuilder Inheritance object TimeSpanBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks See the documentation for TimeSpanBuilder<TOtherBuilder> for more information about how this class is to be used. Methods Create<TOtherBuilder>(TOtherBuilder, int) Creates and returns a TimeSpanBuilder<TOtherBuilder> which can hold time span information and then continue the building process associated with the other builder. public static TimeSpanBuilder<TOtherBuilder> Create<TOtherBuilder>(TOtherBuilder otherBuilder, int value) where TOtherBuilder : class Parameters otherBuilder TOtherBuilder An instance of another performable builder value int The absolute time span value, without any units Returns TimeSpanBuilder<TOtherBuilder> Type Parameters TOtherBuilder The type of the other performable builder Remarks See the documentation for TimeSpanBuilder<TOtherBuilder> for more information about how this method is to be used."
  },
  "api/CSF.Screenplay.Performables.html": {
    "href": "api/CSF.Screenplay.Performables.html",
    "title": "Namespace CSF.Screenplay.Performables | Screenplay",
    "summary": "Namespace CSF.Screenplay.Performables Classes PerformableException Thrown when a Performable fails with an unexpected exception. ReadTheStopwatch An action which reads the current value of the stopwatch. ResetTheStopwatch An action which resets the stopwatch. StartTheStopwatch An action which starts the stopwatch. StopTheStopwatch An action which stops the stopwatch. StopwatchBuilder A builder for actions relating to the UseAStopwatch ability. TimeSpanBuilder Static helper class for creating instances of TimeSpanBuilder<TOtherBuilder>. TimeSpanBuilder<TOtherBuilder> A supplementary builder type which enables the collection of TimeSpan instances. Interfaces IGetsPerformable An object which can get an IPerformable instance, such as a performable builder. IGetsPerformableWithResult An object which can get a non-generic IPerformableWithResult instance, such as a performable builder. IGetsPerformableWithResult<TResult> An object which can get an IPerformableWithResult<TResult> instance, such as a performable builder. IProvidesTimeSpan A type which may provide a TimeSpan."
  },
  "api/CSF.Screenplay.Performance.html": {
    "href": "api/CSF.Screenplay.Performance.html",
    "title": "Class Performance | Screenplay",
    "summary": "Class Performance Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Primary implementation type of IPerformance. public sealed class Performance : IPerformance, IHasPerformanceIdentity, IHasServiceProvider, IDisposable, IBeginsAndEndsPerformance, IEquatable<Performance> Inheritance object Performance Implements IPerformance IHasPerformanceIdentity IHasServiceProvider IDisposable IBeginsAndEndsPerformance IEquatable<Performance> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Performance(IServiceProvider, IList<IdentifierAndName>, Guid) Initialises a new instance of Performance public Performance(IServiceProvider serviceProvider, IList<IdentifierAndName> namingHierarchy, Guid performanceIdentity = default) Parameters serviceProvider IServiceProvider A dependency injection service provider namingHierarchy IList<IdentifierAndName> A collection of identifiers and names providing the hierarchical name of this performance; see NamingHierarchy for more information. performanceIdentity Guid A unique identifier for the performance; if omitted (equal to Empty) then a new Guid will be generated as the identity for this performance Exceptions ArgumentNullException If serviceProvider is null Properties NamingHierarchy Gets an ordered list of identifiers which indicate the current performance's name within an organisational hierarchy. public IReadOnlyList<IdentifierAndName> NamingHierarchy { get; } Property Value IReadOnlyList<IdentifierAndName> Examples If the current performance is to be named Joe can take out the Trash, and it is part of a parent name, named Joe can do his chores then the first identifier in the list will be named Joe can do his chores and the second will be named Joe can take out the Trash. Remarks A Screenplay typically contains more than one performance and may contain many. It is normal to organise performances into a hierarchical structure based upon their purpose, role or relationship. The position of the current performance in that naming structure is represented by the value of this property. The ordered list of IdentifierAndName instances indicate a path from the 'root' of the hierarchy (which has no inherent name) to the current performance. Identifier/name pairs which are earlier in the collection are considered to be closer to the root, whereas latter identifier/names are branch & leaf names. In this manner, they work very similarly to .NET namespaces. The earlier in the list that a name appears, the more general it should be, representing a wider category. When using Screenplay with Integration, this hierarchy of names would typically correspond to the naming convention used by the testing framework. That might be based upon .NET namespaces, classes and test methods for a more traditional unit testing framework. Alternatively, for a BDD-style testing framework, it could be named based upon human-readable feature & scenario names. PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. PerformanceState Gets a value which indicates the state of the current performance. public PerformanceState PerformanceState { get; } Property Value PerformanceState See Also PerformanceState ServiceProvider Gets a service provider/resolver instance associated with this object. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods BeginPerformance() Begins the performance public void BeginPerformance() Dispose() public void Dispose() Equals(Performance) public bool Equals(Performance other) Parameters other Performance Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool FinishPerformance(bool?) Finishes the performance with a value indicating whether or not it was a success public void FinishPerformance(bool? success) Parameters success bool? If true then the performance is to be considered a success; if false then a failure. A value of null indicates that the performance did not succeed but should not be considered a failure either. GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/CSF.Screenplay.PerformanceAdapter.html": {
    "href": "api/CSF.Screenplay.PerformanceAdapter.html",
    "title": "Class PerformanceAdapter | Screenplay",
    "summary": "Class PerformanceAdapter Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll An adapter which enables the use of IPerformance within an NUnit3 test, without needing to parameter-inject the instance as Lazy<IPerformance>. public sealed class PerformanceAdapter : IPerformance, IHasPerformanceIdentity, IHasServiceProvider, IDisposable, IBeginsAndEndsPerformance Inheritance object PerformanceAdapter Implements IPerformance IHasPerformanceIdentity IHasServiceProvider IDisposable IBeginsAndEndsPerformance Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Due to NUnit architectural limitations, injectable parameters cannot be resolved from DI at the point the test method is built. If we were to attempt this, then the parameter value would not be associated with the correct Screenplay/DI scope (and thus Event Bus). This is due to the two-process model which NUnit uses; one process for building the test methods and another process for running the tests. By using an adapter with Lazy resolution of the real implementation, we ensure that DI resolution is deferred into the test-run process and not the test-building process. Constructors PerformanceAdapter(Guid) Creates a new instance of PerformanceAdapter for the specified performance identity. public PerformanceAdapter(Guid performanceIdentity) Parameters performanceIdentity Guid A performance identity, corresponding to PerformanceIdentity. Properties NamingHierarchy Gets an ordered list of identifiers which indicate the current performance's name within an organisational hierarchy. public IReadOnlyList<IdentifierAndName> NamingHierarchy { get; } Property Value IReadOnlyList<IdentifierAndName> Examples If the current performance is to be named Joe can take out the Trash, and it is part of a parent name, named Joe can do his chores then the first identifier in the list will be named Joe can do his chores and the second will be named Joe can take out the Trash. Remarks A Screenplay typically contains more than one performance and may contain many. It is normal to organise performances into a hierarchical structure based upon their purpose, role or relationship. The position of the current performance in that naming structure is represented by the value of this property. The ordered list of IdentifierAndName instances indicate a path from the 'root' of the hierarchy (which has no inherent name) to the current performance. Identifier/name pairs which are earlier in the collection are considered to be closer to the root, whereas latter identifier/names are branch & leaf names. In this manner, they work very similarly to .NET namespaces. The earlier in the list that a name appears, the more general it should be, representing a wider category. When using Screenplay with Integration, this hierarchy of names would typically correspond to the naming convention used by the testing framework. That might be based upon .NET namespaces, classes and test methods for a more traditional unit testing framework. Alternatively, for a BDD-style testing framework, it could be named based upon human-readable feature & scenario names. PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. PerformanceState Gets a value which indicates the state of the current performance. public PerformanceState PerformanceState { get; } Property Value PerformanceState See Also PerformanceState ServiceProvider Gets a service provider/resolver instance associated with this object. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods BeginPerformance() Begins the performance public void BeginPerformance() Dispose() public void Dispose() FinishPerformance(bool?) Finishes the performance with a value indicating whether or not it was a success public void FinishPerformance(bool? success) Parameters success bool? If true then the performance is to be considered a success; if false then a failure. A value of null indicates that the performance did not succeed but should not be considered a failure either."
  },
  "api/CSF.Screenplay.PerformanceProviderFactory.html": {
    "href": "api/CSF.Screenplay.PerformanceProviderFactory.html",
    "title": "Class PerformanceProviderFactory | Screenplay",
    "summary": "Class PerformanceProviderFactory Namespace CSF.Screenplay Assembly CSF.Screenplay.ReqnrollPlugin.dll Factory type for instances of PerformanceProvider. public class PerformanceProviderFactory Inheritance object PerformanceProviderFactory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetPerformanceContainer(IServiceProvider) Gets an instance of PerformanceProvider for the specified service provider. public PerformanceProvider GetPerformanceContainer(IServiceProvider services) Parameters services IServiceProvider A service provider Returns PerformanceProvider A PerformanceProvider."
  },
  "api/CSF.Screenplay.PerformanceStarter.html": {
    "href": "api/CSF.Screenplay.PerformanceStarter.html",
    "title": "Class PerformanceStarter | Screenplay",
    "summary": "Class PerformanceStarter Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Helper class for beginning the functionality of a Screenplay IPerformance from your own logic, using a fluent interface public static class PerformanceStarter Inheritance object PerformanceStarter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples Here is an example of the recommended technique for consuming this class' functionality. using static CSF.Screenplay.ScreenplayStarter; // ... then in your top-level performance logic: await Given(joe).WasAbleTo(takeOutTheTrash); Remarks This class is a convenience to aid in the readability of top-level performance logic, providing a fluent entry-point into the performance methods. Each of the methods upon this class corresponds to a PerformancePhase within the overall performance. By using these methods, the actor is down-cast to the appropriate interface that is specific to that phase, which activates appropriate functionality of the fluent interface. It is recommended to consume this functionality in your own logic via the using static directive, so that you may use the Given(Actor), When(Actor) & Then(Actor) methods stand-alone. Do not use these methods in your own Performable implementations. Doing so would reduce their reusability; use these methods only in your top-level performance logic. Any performables which are executed by one of these three methods automatically inherits the performance phase from which its top-level performable was started. Methods Given(Actor) Returns the actor instance, down-cast to ICanPerformGiven, activating the fluent interface for the Given phase of the performance. public static ICanPerformGiven Given(Actor actor) Parameters actor Actor The actor. Returns ICanPerformGiven Then(Actor) Returns the actor instance, down-cast to ICanPerformThen, activating the fluent interface for the Then phase of the performance. public static ICanPerformThen Then(Actor actor) Parameters actor Actor The actor. Returns ICanPerformThen When(Actor) Returns the actor instance, down-cast to ICanPerformWhen, activating the fluent interface for the When phase of the performance. public static ICanPerformWhen When(Actor actor) Parameters actor Actor The actor. Returns ICanPerformWhen"
  },
  "api/CSF.Screenplay.Performances.IBeginsAndEndsPerformance.html": {
    "href": "api/CSF.Screenplay.Performances.IBeginsAndEndsPerformance.html",
    "title": "Interface IBeginsAndEndsPerformance | Screenplay",
    "summary": "Interface IBeginsAndEndsPerformance Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll An object which controls the beginning and ending of a performance public interface IBeginsAndEndsPerformance Methods BeginPerformance() Begins the performance void BeginPerformance() FinishPerformance(bool?) Finishes the performance with a value indicating whether or not it was a success void FinishPerformance(bool? success) Parameters success bool? If true then the performance is to be considered a success; if false then a failure. A value of null indicates that the performance did not succeed but should not be considered a failure either."
  },
  "api/CSF.Screenplay.Performances.IHasPerformanceEvents.html": {
    "href": "api/CSF.Screenplay.Performances.IHasPerformanceEvents.html",
    "title": "Interface IHasPerformanceEvents | Screenplay",
    "summary": "Interface IHasPerformanceEvents Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll An object which has events which are significant to the progress of a Screenplay. public interface IHasPerformanceEvents Remarks This object is used as an event publisher, such that events which originate from many separate objects may be aggregated to a single point of contact. This way, consumers of those events have only a single object to which they need subscribe. There should only be a single instance of an object which implements this interface, for the lifetime of a Screenplay. This type is closely related to IRelaysPerformanceEvents. This is the event publisher and IRelaysPerformanceEvents is event sink which collects them. Despite this, their APIs are not symmetrical, as many of the events published by this type are derived by subscribing to an Actor instance from the event sink. Events ActorCreated Occurs when a new Actor is created and added to the IPerformance. event EventHandler<ActorEventArgs> ActorCreated Event Type EventHandler<ActorEventArgs> ActorSpotlit Occurs when an Actor is placed into the Spotlight of an IStage. event EventHandler<ActorEventArgs> ActorSpotlit Event Type EventHandler<ActorEventArgs> BeginPerformable Occurs when an Actor begins the execution of a performable object. event EventHandler<PerformableEventArgs> BeginPerformable Event Type EventHandler<PerformableEventArgs> EndPerformable Occurs when an Actor ends the execution of a performable object. event EventHandler<PerformableEventArgs> EndPerformable Event Type EventHandler<PerformableEventArgs> GainedAbility Occurs when an Actor gains a new ability. event EventHandler<GainAbilityEventArgs> GainedAbility Event Type EventHandler<GainAbilityEventArgs> PerformableFailed Occurs when a performable object fails with an exception. event EventHandler<PerformableFailureEventArgs> PerformableFailed Event Type EventHandler<PerformableFailureEventArgs> PerformableResult Occurs when an Actor receives a result from a perfperformable objectrmance. event EventHandler<PerformableResultEventArgs> PerformableResult Event Type EventHandler<PerformableResultEventArgs> PerformanceBegun Occurs when a IPerformance begins executing. event EventHandler<PerformanceEventArgs> PerformanceBegun Event Type EventHandler<PerformanceEventArgs> PerformanceFinished Occurs when a IPerformance has finished executing. event EventHandler<PerformanceFinishedEventArgs> PerformanceFinished Event Type EventHandler<PerformanceFinishedEventArgs> RecordAsset Occurs when an actor records the presence of a new file asset. event EventHandler<PerformableAssetEventArgs> RecordAsset Event Type EventHandler<PerformableAssetEventArgs> ScreenplayEnded Occurs when a Screenplay has ended. event EventHandler ScreenplayEnded Event Type EventHandler ScreenplayStarted Occurs when a Screenplay starts. event EventHandler ScreenplayStarted Event Type EventHandler SpotlightTurnedOff Occurs when the Spotlight of an IStage is 'turned off'; the Actor who is currently spotlit is removed without being replaced. event EventHandler<PerformanceScopeEventArgs> SpotlightTurnedOff Event Type EventHandler<PerformanceScopeEventArgs> See Also IRelaysPerformanceEvents"
  },
  "api/CSF.Screenplay.Performances.IRelaysPerformanceEvents.html": {
    "href": "api/CSF.Screenplay.Performances.IRelaysPerformanceEvents.html",
    "title": "Interface IRelaysPerformanceEvents | Screenplay",
    "summary": "Interface IRelaysPerformanceEvents Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll An object which can relay events that relate to a IPerformance public interface IRelaysPerformanceEvents Remarks This object is used as an event sink; a single point of contact to which many objects may send events. This allows event consumers to receive events from many origins by subscribing to only a single object. There should only be a single instance of an object which implements this interface, for the lifetime of a Screenplay. This type is closely related to IHasPerformanceEvents. This is the event sink and IHasPerformanceEvents is the publisher of those events. Despite this, their APIs are not symmetrical, as many of the events published are derived by subscribing to an Actor instance. Methods InvokeActorCreated(Actor) Invokes an event indicating that a new Actor has been created and added to the IPerformance. void InvokeActorCreated(Actor actor) Parameters actor Actor The actor InvokeActorSpotlit(Actor) Invokes an event indicating that an Actor has been placed into the Spotlight of an IStage. void InvokeActorSpotlit(Actor actor) Parameters actor Actor The actor InvokeGainedAbility(Actor, object) Invokes an event indicating that a new Actor has gained an ability. void InvokeGainedAbility(Actor actor, object ability) Parameters actor Actor The actor ability object The ability that the actor has gained. Remarks Use this method only when an actor gains one or more abilities before the the SubscribeTo(Actor) method has been used to subscribe to the actor. Once the actor has been subscribed-to by an implementation of this instance, their newly-added abilities will automatically be captured. In some circumstances where the actor is fully created and has their abilities granted BEFORE there has been an opportunity to subscribe to them, then this method is required to retrospectively trigger the abilitiy-granted event. This is applicable for actors who are created by an IPersona, which might grant the actors one or more abilities immediately, as part of their creation. InvokePerformanceBegun(IPerformance) Invokes an event indicating that a IPerformance has begun. void InvokePerformanceBegun(IPerformance performance) Parameters performance IPerformance The performance InvokePerformanceFinished(IPerformance, bool?) Invokes an event indicating that a IPerformance has finished. void InvokePerformanceFinished(IPerformance performance, bool? success) Parameters performance IPerformance The performance success bool? A value indicating whether or not the performance was a success InvokeScreenplayEnded() Invokes an event indicating that a Screenplay has ended. void InvokeScreenplayEnded() InvokeScreenplayStarted() Invokes an event indicating that a Screenplay has started. void InvokeScreenplayStarted() InvokeSpotlightTurnedOff(Guid) Invokes an event indicating that the Spotlight of the IStage has been 'turned off'. void InvokeSpotlightTurnedOff(Guid performanceIdentity) Parameters performanceIdentity Guid A unique identifier for the current IPerformance. SubscribeTo(Actor) Subscribes to (and relays) events from the specified actor. void SubscribeTo(Actor actor) Parameters actor Actor The actor to which this relay should subscribe. UnsubscribeFrom(Actor) Unsubscribes from events from the specified actor. void UnsubscribeFrom(Actor actor) Parameters actor Actor The actor from which this relay should unsubscribe. Remarks This method is typically used when the actor instance is about to be disposed, such as at the end of a IPerformance. UnsubscribeFromAllActors(Guid) Unsubscribes from all of the events for all of the actors who are part of the the IPerformance, indicated by its identity. void UnsubscribeFromAllActors(Guid performanceIdentity) Parameters performanceIdentity Guid The identity of a performance. Remarks Using this method is equivalent to calling UnsubscribeFrom(Actor) for every Actor which is participating in the specified performance. Use this method when ending a performance, as a convenience to unsubscribe from all of its actors at once. Note that this method might not result in unsubscribing any actors. If the subscribed actors are also managed by an implementation of ICast then the disposal of the cast will automatically unsubscribe these actors on its own. This method is provided & used as a backup technique, in case the actors are not managed by a cast. See Also IHasPerformanceEvents"
  },
  "api/CSF.Screenplay.Performances.IdentifierAndName.html": {
    "href": "api/CSF.Screenplay.Performances.IdentifierAndName.html",
    "title": "Class IdentifierAndName | Screenplay",
    "summary": "Class IdentifierAndName Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll A model which indicates a unique identifier and a corresponding human-readable name. public sealed class IdentifierAndName : IEquatable<IdentifierAndName>, IHasName Inheritance object IdentifierAndName Implements IEquatable<IdentifierAndName> IHasName Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors IdentifierAndName(string, string, bool) Initialises a new instance of IdentifierAndName public IdentifierAndName(string identifier, string name = null, bool wasIdentifierAutoGenerated = false) Parameters identifier string The identifier for this item, which might not be human-readable name string A human-readable name for this item wasIdentifierAutoGenerated bool A value that indicates whether or not identifier is an auto-generated value Exceptions ArgumentNullException If identifier is null Properties Identifier Gets the identifier for the current item public string Identifier { get; } Property Value string Remarks The identifier for an item might not be a human-readable value. It is required to uniquely identify the current item, however. Name Gets a human-readable name for the current item public string Name { get; } Property Value string Remarks The human-readable name in this context is not mandatory, and so this property might return a null reference if no name was specified. WasIdentifierAutoGenerated Gets a value indicating whether or not the Identifier is an automatically-generated value or not. public bool WasIdentifierAutoGenerated { get; } Property Value bool Remarks Some integrations with Screenplay do not provide a suitable unique identifier for this position. In that case, because a unique identifier is required, Screenplay generates a unique identifier (the string representation of a GUID) automatically and uses it as the Identifier. Obviously, if that is the case then the identifier will have no meaning or correspondence to anything in the logic consuming Screenplay. This property is used to indicate when this is the case; if it is true then the Identifier was randomly-generated by Screenplay. Methods Equals(IdentifierAndName) public bool Equals(IdentifierAndName other) Parameters other IdentifierAndName Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string"
  },
  "api/CSF.Screenplay.Performances.PerformanceEventArgs.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceEventArgs.html",
    "title": "Class PerformanceEventArgs | Screenplay",
    "summary": "Class PerformanceEventArgs Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to a scope of a IPerformance. public class PerformanceEventArgs : PerformanceScopeEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs PerformanceEventArgs Implements IHasPerformanceIdentity Derived PerformanceFinishedEventArgs Inherited Members PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformanceEventArgs(IPerformance) Initialises a new instance of PerformanceEventArgs public PerformanceEventArgs(IPerformance performance) Parameters performance IPerformance The performance Exceptions ArgumentNullException If the scenario hierarchy is null Properties NamingHierarchy Gets an ordered list of identifiers which indicate the IPerformance's name within an organisational hierarchy. public IReadOnlyList<IdentifierAndName> NamingHierarchy { get; } Property Value IReadOnlyList<IdentifierAndName> Remarks This hierarchical name has the exact same meaning and corresponds directly to NamingHierarchy. See Also IPerformance NamingHierarchy Performance Gets the IPerformance to which this event relates. public IPerformance Performance { get; } Property Value IPerformance See Also IPerformance PerformanceScopeEventArgs"
  },
  "api/CSF.Screenplay.Performances.PerformanceEventBus.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceEventBus.html",
    "title": "Class PerformanceEventBus | Screenplay",
    "summary": "Class PerformanceEventBus Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.dll Implementation of an event bus for performance-related events. public class PerformanceEventBus : IHasPerformanceEvents, IRelaysPerformanceEvents Inheritance object PerformanceEventBus Implements IHasPerformanceEvents IRelaysPerformanceEvents Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This object should be used as a singleton across the lifetime of a Screenplay. As an event bus object, it is both a subscriber (a sink) which can receive events. It is also a publisher, which emits events. The purpose of this object is to aggregate events from many instances of Performance and Actor over the duration/lifetime of the Screenplay. This way, consumers have only a single object to which they should subscribe in order to receive those events. As you will see from the API of this object, the implementations of IHasPerformanceEvents and IRelaysPerformanceEvents are not symmetrical. Many events are published by subscribing to the events upon an Actor. Properties EventBusId Gets a unique identifier for this event bus instance. public Guid EventBusId { get; } Property Value Guid Remarks This property is not used by the Screenplay architecture directly, it is primarily for debugging/development purposes. A common problem/developer-mistake which may occur is accidentally working with more than one Event Bus; this can occur when working with a multiple process model, in which it is possible for more than once instance of a type registered in DI as a 'Singleton' to coexist. This property helps developers identify event bus instances (in a debugger, for example), so that they may recognise occasions in which they are dealing with more than one of them. Methods InvokeActorCreated(Actor) Invokes an event indicating that a new Actor has been created and added to the IPerformance. public void InvokeActorCreated(Actor actor) Parameters actor Actor The actor InvokeActorSpotlit(Actor) Invokes an event indicating that an Actor has been placed into the Spotlight of an IStage. public void InvokeActorSpotlit(Actor actor) Parameters actor Actor The actor InvokeGainedAbility(Actor, object) Invokes an event indicating that a new Actor has gained an ability. public void InvokeGainedAbility(Actor actor, object ability) Parameters actor Actor The actor ability object The ability that the actor has gained. Remarks Use this method only when an actor gains one or more abilities before the the SubscribeTo(Actor) method has been used to subscribe to the actor. Once the actor has been subscribed-to by an implementation of this instance, their newly-added abilities will automatically be captured. In some circumstances where the actor is fully created and has their abilities granted BEFORE there has been an opportunity to subscribe to them, then this method is required to retrospectively trigger the abilitiy-granted event. This is applicable for actors who are created by an IPersona, which might grant the actors one or more abilities immediately, as part of their creation. InvokePerformanceBegun(IPerformance) Invokes an event indicating that a IPerformance has begun. public void InvokePerformanceBegun(IPerformance performance) Parameters performance IPerformance The performance InvokePerformanceFinished(IPerformance, bool?) Invokes an event indicating that a IPerformance has finished. public void InvokePerformanceFinished(IPerformance performance, bool? success) Parameters performance IPerformance The performance success bool? A value indicating whether or not the performance was a success InvokeScreenplayEnded() Invokes an event indicating that a Screenplay has ended. public void InvokeScreenplayEnded() InvokeScreenplayStarted() Invokes an event indicating that a Screenplay has started. public void InvokeScreenplayStarted() InvokeSpotlightTurnedOff(Guid) Invokes an event indicating that the Spotlight of the IStage has been 'turned off'. public void InvokeSpotlightTurnedOff(Guid performanceIdentity) Parameters performanceIdentity Guid A unique identifier for the current IPerformance. SubscribeTo(Actor) Subscribes to (and relays) events from the specified actor. public void SubscribeTo(Actor actor) Parameters actor Actor The actor to which this relay should subscribe. UnsubscribeFrom(Actor) Unsubscribes from events from the specified actor. public void UnsubscribeFrom(Actor actor) Parameters actor Actor The actor from which this relay should unsubscribe. Remarks This method is typically used when the actor instance is about to be disposed, such as at the end of a IPerformance. UnsubscribeFromAllActors(Guid) Unsubscribes from all of the events for all of the actors who are part of the the IPerformance, indicated by its identity. public void UnsubscribeFromAllActors(Guid performanceIdentity) Parameters performanceIdentity Guid The identity of a performance. Remarks Using this method is equivalent to calling UnsubscribeFrom(Actor) for every Actor which is participating in the specified performance. Use this method when ending a performance, as a convenience to unsubscribe from all of its actors at once. Note that this method might not result in unsubscribing any actors. If the subscribed actors are also managed by an implementation of ICast then the disposal of the cast will automatically unsubscribe these actors on its own. This method is provided & used as a backup technique, in case the actors are not managed by a cast. Events ActorCreated Occurs when a new Actor is created and added to the IPerformance. public event EventHandler<ActorEventArgs> ActorCreated Event Type EventHandler<ActorEventArgs> ActorSpotlit Occurs when an Actor is placed into the Spotlight of an IStage. public event EventHandler<ActorEventArgs> ActorSpotlit Event Type EventHandler<ActorEventArgs> BeginPerformable Occurs when an Actor begins the execution of a performable object. public event EventHandler<PerformableEventArgs> BeginPerformable Event Type EventHandler<PerformableEventArgs> EndPerformable Occurs when an Actor ends the execution of a performable object. public event EventHandler<PerformableEventArgs> EndPerformable Event Type EventHandler<PerformableEventArgs> GainedAbility Occurs when an Actor gains a new ability. public event EventHandler<GainAbilityEventArgs> GainedAbility Event Type EventHandler<GainAbilityEventArgs> PerformableFailed Occurs when a performable object fails with an exception. public event EventHandler<PerformableFailureEventArgs> PerformableFailed Event Type EventHandler<PerformableFailureEventArgs> PerformableResult Occurs when an Actor receives a result from a perfperformable objectrmance. public event EventHandler<PerformableResultEventArgs> PerformableResult Event Type EventHandler<PerformableResultEventArgs> PerformanceBegun Occurs when a IPerformance begins executing. public event EventHandler<PerformanceEventArgs> PerformanceBegun Event Type EventHandler<PerformanceEventArgs> PerformanceFinished Occurs when a IPerformance has finished executing. public event EventHandler<PerformanceFinishedEventArgs> PerformanceFinished Event Type EventHandler<PerformanceFinishedEventArgs> RecordAsset Occurs when an actor records the presence of a new file asset. public event EventHandler<PerformableAssetEventArgs> RecordAsset Event Type EventHandler<PerformableAssetEventArgs> ScreenplayEnded Occurs when a Screenplay has ended. public event EventHandler ScreenplayEnded Event Type EventHandler ScreenplayStarted Occurs when a Screenplay starts. public event EventHandler ScreenplayStarted Event Type EventHandler SpotlightTurnedOff Occurs when the Spotlight of an IStage is 'turned off'; the Actor who is currently spotlit is removed without being replaced. public event EventHandler<PerformanceScopeEventArgs> SpotlightTurnedOff Event Type EventHandler<PerformanceScopeEventArgs>"
  },
  "api/CSF.Screenplay.Performances.PerformanceFinishedEventArgs.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceFinishedEventArgs.html",
    "title": "Class PerformanceFinishedEventArgs | Screenplay",
    "summary": "Class PerformanceFinishedEventArgs Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to a finishing of a IPerformance. public class PerformanceFinishedEventArgs : PerformanceEventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs PerformanceEventArgs PerformanceFinishedEventArgs Implements IHasPerformanceIdentity Inherited Members PerformanceEventArgs.Performance PerformanceEventArgs.NamingHierarchy PerformanceScopeEventArgs.PerformanceIdentity EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PerformanceFinishedEventArgs(IPerformance, bool?) Initialises a new instance of PerformanceEventArgs public PerformanceFinishedEventArgs(IPerformance performance, bool? success) Parameters performance IPerformance The performance. success bool? A value indicating whether or not the scenario completed with a succeess result Exceptions ArgumentNullException If the scenario hierarchy is null Properties Success Gets a value indicating whether the finished IPerformance was a success or not public bool? Success { get; } Property Value bool? Remarks The three possible values for this property correspond to three possible values of PerformanceState which represent a performance that has finished. Value Corresponding state true Success false Failed null Completed When using Screenplay with Integration, these three performance states may go on to correspond to a test pass, failure or skipped/ignored test, respectively. See Also IPerformance PerformanceScopeEventArgs PerformanceEventArgs"
  },
  "api/CSF.Screenplay.Performances.PerformanceProvider.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceProvider.html",
    "title": "Class PerformanceProvider | Screenplay",
    "summary": "Class PerformanceProvider Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.dll A class which provides access to the current IPerformance, which exists within the current dependency injection scope. public class PerformanceProvider Inheritance object PerformanceProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This container/provider class is required for architectural reasons. Instances of Performance cannot be created upon their first resolution from dependency injection. This is because performances are immutable and require constructor parameters which are provided by the creating logic. However, performance must also be available instance-per-scope from DI. That is why this class is required, so that a created performance may be 'registered' with this class, with SetCurrentPerformance(IPerformance). This class is itself registered in DI as instance-per-scope. So, consuming logic may resolve a performance by getting an instance of this provider and then using GetCurrentPerformance(). Methods GetCurrentPerformance() Gets the current performance from this provider instance. public IPerformance GetCurrentPerformance() Returns IPerformance The current performance Exceptions InvalidOperationException If this instance does not have a current performance. SetCurrentPerformance(IPerformance) Sets the current performance for this provider instance. public void SetCurrentPerformance(IPerformance currentPerformance) Parameters currentPerformance IPerformance The new current performance Exceptions ArgumentNullException If currentPerformance is null InvalidOperationException If the current instance already has a current performance."
  },
  "api/CSF.Screenplay.Performances.PerformanceScopeEventArgs.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceScopeEventArgs.html",
    "title": "Class PerformanceScopeEventArgs | Screenplay",
    "summary": "Class PerformanceScopeEventArgs Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll A model for event arguments which relate to a scope of a IPerformance. public class PerformanceScopeEventArgs : EventArgs, IHasPerformanceIdentity Inheritance object EventArgs PerformanceScopeEventArgs Implements IHasPerformanceIdentity Derived ActorEventArgs PerformanceEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This event arguments class is often used as a base for models which identify a IPerformance. Constructors PerformanceScopeEventArgs(Guid) Initializes a new instance of PerformanceScopeEventArgs public PerformanceScopeEventArgs(Guid performanceIdentity) Parameters performanceIdentity Guid The performance identity Properties PerformanceIdentity Gets the unique IPerformance identifier public Guid PerformanceIdentity { get; } Property Value Guid Remarks This value is used to uniquely identify a performance within a CSF.Screenplay. See Also IPerformance"
  },
  "api/CSF.Screenplay.Performances.PerformanceState.html": {
    "href": "api/CSF.Screenplay.Performances.PerformanceState.html",
    "title": "Enum PerformanceState | Screenplay",
    "summary": "Enum PerformanceState Namespace CSF.Screenplay.Performances Assembly CSF.Screenplay.Abstractions.dll Enumerates the states of an IPerformance. public enum PerformanceState Fields Completed = 4 The performance has completed but it has neither succeeded or failed. In some Integration, this might mean that the IPerformance or Scenario was skipped or interrupted in a way that should not be treated as a failure. Failed = 3 The performance has completed but it has failed. InProgress = 1 The performance has been started but is not yet complete; use FinishPerformance(bool?) to complete it. NotStarted = 0 The performance is not yet started; use BeginPerformance() to begin it. Success = 2 The performance has completed and was a success. Remarks When Screenplay is being used with Integration then this will also closely correspond to the state & outcome of the corresponding Scenario"
  },
  "api/CSF.Screenplay.Performances.html": {
    "href": "api/CSF.Screenplay.Performances.html",
    "title": "Namespace CSF.Screenplay.Performances | Screenplay",
    "summary": "Namespace CSF.Screenplay.Performances Classes IdentifierAndName A model which indicates a unique identifier and a corresponding human-readable name. PerformanceEventArgs A model for event arguments which relate to a scope of a IPerformance. PerformanceEventBus Implementation of an event bus for performance-related events. PerformanceFinishedEventArgs A model for event arguments which relate to a finishing of a IPerformance. PerformanceProvider A class which provides access to the current IPerformance, which exists within the current dependency injection scope. PerformanceScopeEventArgs A model for event arguments which relate to a scope of a IPerformance. Interfaces IBeginsAndEndsPerformance An object which controls the beginning and ending of a performance IHasPerformanceEvents An object which has events which are significant to the progress of a Screenplay. IRelaysPerformanceEvents An object which can relay events that relate to a IPerformance Enums PerformanceState Enumerates the states of an IPerformance."
  },
  "api/CSF.Screenplay.ReportFragment.html": {
    "href": "api/CSF.Screenplay.ReportFragment.html",
    "title": "Class ReportFragment | Screenplay",
    "summary": "Class ReportFragment Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll A model for a fragment of a report upon a IPerformance. public sealed class ReportFragment Inheritance object ReportFragment Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Examples An example of a template string is \"{Actor} washes {Count} dishes\". This template expects two placeholder values for Actor & Count. A sample FormattedFragment which might result from this could be \"Joe washes 5 dishes\". Remarks A report fragment is typically human readable summary of the execution of a single performable item or the assignment of an ability to an Actor (the actor \"gaining\" an ability). A complete report about an IPerformance would usually contain many such fragments, organised hierarchically where performables consume & execute performables themselves. This creates a nested structure where the outermost report fragments describe higher-level performables, with lower-level performables contained within. Report fragments are created from a template, which is a human-readable string with named placeholders, using a syntax which is very similar to the way in which Microsoft.Extensions.Logging uses template strings: https://learn.microsoft.com/en-us/dotnet/core/extensions/logging. The template may have any number of placeholders, which are names enclosed within braces, such as {Actor}. These placeholders are then populated with a collection of values which are provided to fill those placeholders. The result is a completely formatted, human-readable report fragment string. This model holds the result of this formatting process, the implementation of IFormatsReportFragment is responsible for performing the formatting itself. Constructors ReportFragment(string, string, IReadOnlyList<NameAndValue>) Initializes a new instance of ReportFragment. public ReportFragment(string originalTemplate, string formattedFragment, IReadOnlyList<NameAndValue> placeholderValues) Parameters originalTemplate string The original template string formattedFragment string The formatted report fragment placeholderValues IReadOnlyList<NameAndValue> The placeholder values Exceptions ArgumentNullException If any parameter is null. Properties FormattedFragment Gets the formatted report fragment, after placeholder substitution has taken place. public string FormattedFragment { get; } Property Value string OriginalTemplate Gets the original template string for this report fragment, without placeholder substitution. public string OriginalTemplate { get; } Property Value string PlaceholderValues Gets a collection of the placeholder values, and the placeholder names to which those values correspond. public IReadOnlyList<NameAndValue> PlaceholderValues { get; } Property Value IReadOnlyList<NameAndValue> Methods ToString() public override string ToString() Returns string See Also IFormatsReportFragment"
  },
  "api/CSF.Screenplay.ReportFragmentFormatter.html": {
    "href": "api/CSF.Screenplay.ReportFragmentFormatter.html",
    "title": "Class ReportFragmentFormatter | Screenplay",
    "summary": "Class ReportFragmentFormatter Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Default implementation of IFormatsReportFragment. public class ReportFragmentFormatter : IFormatsReportFragment Inheritance object ReportFragmentFormatter Implements IFormatsReportFragment Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ReportFragmentFormatter(IGetsReportFormat, IGetsValueFormatter) Initializes a new instance of ReportFragmentFormatter. public ReportFragmentFormatter(IGetsReportFormat formatCreator, IGetsValueFormatter formatterFactory) Parameters formatCreator IGetsReportFormat A format creator which parses the original format string and values into a ReportFormat formatterFactory IGetsValueFormatter A factory for instances of IValueFormatter Exceptions ArgumentNullException If any parameter is null. Methods Format(string, params object[]) Gets the formatted report fragment from the specified template and values. public ReportFragment Format(string template, params object[] values) Parameters template string A string template for the report fragment values object[] A collection of values associated with the report fragment Returns ReportFragment A formatted report fragment Examples The following code will produce the final formatted string as noted below. var p1 = \"first\"; var p2 = \"second\"; formatter.Format(\"The values are {p2} and {p1}\", p1, p2); // This will yield the result \"The values are first and second\" Remarks The template should be a human-readable string (localized if you wish) which would be recorded in a Screenplay report. This string may contain any number of placeholder markers which are indicated by some text enclosed within braces, such as {Name}. This functions in a slightly similar fashion to .NET logging: https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-message-template or the Format(string, params object[]) method. Importantly, the placeholders are identified by names, rather than numeric index, in the same way that logging template strings work. Placeholders do not support any kind of format or alignment syntax. Developers are encouraged to choose meaningful names for their placeholders. The ReportFragment which is produced by this method will include the values associated with those placeholder names. This allows reporting infrastructure to work in a similar manner to the way in which structured logging is described in the article linked above. This provides a richer data model than simply a plain string. See Also ReportFragment"
  },
  "api/CSF.Screenplay.ReportModel.ActorCreatedReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.ActorCreatedReport.html",
    "title": "Class ActorCreatedReport | Screenplay",
    "summary": "Class ActorCreatedReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll An implementation of ReportableModelBase which represents the addition/creation of a new actor in a performance. public class ActorCreatedReport : ReportableModelBase Inheritance object ReportableModelBase ActorCreatedReport Inherited Members ReportableModelBase.Report ReportableModelBase.ActorName object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This model exposes nothing more than the ReportableModelBase already provides."
  },
  "api/CSF.Screenplay.ReportModel.ActorGainedAbilityReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.ActorGainedAbilityReport.html",
    "title": "Class ActorGainedAbilityReport | Screenplay",
    "summary": "Class ActorGainedAbilityReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll An implementation of ReportableModelBase which occurs when an Actor gains a new ability. public class ActorGainedAbilityReport : ReportableModelBase Inheritance object ReportableModelBase ActorGainedAbilityReport Inherited Members ReportableModelBase.Report ReportableModelBase.ActorName object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This model exposes nothing more than the ReportableModelBase already provides."
  },
  "api/CSF.Screenplay.ReportModel.ActorSpotlitReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.ActorSpotlitReport.html",
    "title": "Class ActorSpotlitReport | Screenplay",
    "summary": "Class ActorSpotlitReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll An implementation of ReportableModelBase which occurs when an Actor is put into the spotlight. public class ActorSpotlitReport : ReportableModelBase Inheritance object ReportableModelBase ActorSpotlitReport Inherited Members ReportableModelBase.Report ReportableModelBase.ActorName object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This model exposes nothing more than the ReportableModelBase already provides."
  },
  "api/CSF.Screenplay.ReportModel.IdentifierAndNameModel.html": {
    "href": "api/CSF.Screenplay.ReportModel.IdentifierAndNameModel.html",
    "title": "Class IdentifierAndNameModel | Screenplay",
    "summary": "Class IdentifierAndNameModel Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll Model represents an IdentifierAndName within a Screenplay report. public class IdentifierAndNameModel Inheritance object IdentifierAndNameModel Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Like many models in this namespace, this type mimicks a first-class part of the Screenplay architecture. This model type is intended for use with the serialization process to JSON. Many of the properties of these types will correspond directly with the same-named properties on the original Screenplay architecture types. Properties Identifier Corresponds to the value Identifier. public string Identifier { get; set; } Property Value string Name Corresponds to the value Name. public string Name { get; set; } Property Value string WasIdentifierAutoGenerated Corresponds to the value WasIdentifierAutoGenerated. public bool WasIdentifierAutoGenerated { get; set; } Property Value bool"
  },
  "api/CSF.Screenplay.ReportModel.PerformableAsset.html": {
    "href": "api/CSF.Screenplay.ReportModel.PerformableAsset.html",
    "title": "Class PerformableAsset | Screenplay",
    "summary": "Class PerformableAsset Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll Model represents a single asset which was recorded from a performable. public class PerformableAsset Inheritance object PerformableAsset Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Assets are files which are saved to disk, containing arbitrary information, recorded by a performable. This might be a screenshot, some generated content or diagnostic information. Its real content is arbitrary and down to the implementation. An asset is described here by a file path and an optional human-readable summary. Properties FilePath Gets or sets a full/absolute path to the asset file. public string FilePath { get; set; } Property Value string FileSummary Gets or sets an optional human-readable summary of what this asset represents. This should be one sentence at most, suitable for display in a UI tool-tip. public string FileSummary { get; set; } Property Value string"
  },
  "api/CSF.Screenplay.ReportModel.PerformableReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.PerformableReport.html",
    "title": "Class PerformableReport | Screenplay",
    "summary": "Class PerformableReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll An implementation of ReportableModelBase which represents the execution of a performable item. public class PerformableReport : ReportableModelBase Inheritance object ReportableModelBase PerformableReport Inherited Members ReportableModelBase.Report ReportableModelBase.ActorName object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Reports about performables may themselves contain further reportables. This may create a hierarchical structure of reports which contain further reports, and so on. This represents the use of high-level performables which consume/compose lower-level performables. Properties Assets Gets or sets a collection of the assets which were recorded by the current performable. public List<PerformableAsset> Assets { get; set; } Property Value List<PerformableAsset> Exception Gets or sets a value which is the string representation of any Exception which occurred, causing the performable to fail. public string Exception { get; set; } Property Value string Remarks If this property is non-null then the performable has failed with an exception, and this property will contain the result of ToString() for that error. If this property is null then the performable did not raise an exception and completed successfully. ExceptionIsFromConsumedPerformable Gets a value which indicates whether or not the Exception is one which was originally thrown from a consumed performable. public bool ExceptionIsFromConsumedPerformable { get; set; } Property Value bool Remarks If Exception is null then the value of this property is meaningless and undefined. If the exception is not null then - if this property is set to true then it means that exception which is recorded for this performable was originally thrown from a performable which was consumed by the current one. In other words, it indicates whether or not the reason for the current performable's error was because a consumed/child performable encountered an error. If, on the other hand, Exception is not null and this property value is false then it indicates that the current performable is the original source of the error. HasResult Gets or sets a value that indicates whether or not the performable (which generated this report) emitted a result. public bool HasResult { get; set; } Property Value bool Remarks This property will be true if the original performable which lead to this report derived from either IPerformableWithResult or IPerformableWithResult<TResult> (and did not fail). For performables which do not emit a result, this value will always be false. See Also Result PerformableType Gets or sets the FullName of the performable item to which this report model relates. public string PerformableType { get; set; } Property Value string PerformancePhase Corresponds to the PerformancePhase to which the current reportable is part. public string PerformancePhase { get; set; } Property Value string Remarks This property contains the string representation of that performance phase. It is quite rare for this property to be unset (IE: null), typically it is only unset for the initial creation/setup of Actors at the beginning of a performance. Reportables Gets or sets a collection of the reportable items which have been composed by the current performable. public List<ReportableModelBase> Reportables { get; set; } Property Value List<ReportableModelBase> Remarks This collection is commonly populated for task performables, because the nature of tasks is to consume and compose other performables. This collection can create a hierarchical structure of performables composing other performables. That structure could be deeply nested. Result Gets or sets a string representation of the result which was emitted by the corresponding performable. public string Result { get; set; } Property Value string Remarks This property is only relevant if the original performable which lead to this report derived from either IPerformableWithResult or IPerformableWithResult<TResult>. For performables which do not emit a result, this value will always be null. See Also HasResult"
  },
  "api/CSF.Screenplay.ReportModel.PerformanceReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.PerformanceReport.html",
    "title": "Class PerformanceReport | Screenplay",
    "summary": "Class PerformanceReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll Model represents an IPerformance within a Screenplay report. public class PerformanceReport Inheritance object PerformanceReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Like many models in this namespace, this type mimicks a first-class part of the Screenplay architecture. This model type is intended for use with the serialization process to JSON. Many of the properties of these types will correspond directly with the same-named properties on the original Screenplay architecture types. Properties NamingHierarchy Corresponds with NamingHierarchy. public List<IdentifierAndNameModel> NamingHierarchy { get; set; } Property Value List<IdentifierAndNameModel> Outcome Corresponds with PerformanceState, showing the final outcome of the performance. public string Outcome { get; set; } Property Value string Remarks This property contains the string representation of the value of PerformanceState. It is named 'Outcome' rather than 'PerformanceState' because the concept of state would refer to a current state, wheras a report is about something which happened in the past. Additionally, it is impossible for a report to indicate InProgress or NotStarted here. The state will always correspond to one of the three terminal states for a performance. Thus, this property indicates the final outcome of the performance, rather than where it is 'right now'. Reportables Gets or set an ordered collection of the reportable events which occurred in the current performance. public List<ReportableModelBase> Reportables { get; set; } Property Value List<ReportableModelBase>"
  },
  "api/CSF.Screenplay.ReportModel.ReportMetadata.html": {
    "href": "api/CSF.Screenplay.ReportModel.ReportMetadata.html",
    "title": "Class ReportMetadata | Screenplay",
    "summary": "Class ReportMetadata Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll Model represents the metadata about a Screenplay report. public class ReportMetadata Inheritance object ReportMetadata Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ReportFormatVersion Gets or sets a version number for the format of report that has been produced. public string ReportFormatVersion { get; set; } Property Value string Remarks This version number is intended to comply with Semantic versioning: https://semver.org/spec/v2.0.0.html. It may be used to assist parsing logic determine whether or not it is reading a compatible report file. Timestamp Gets or sets the UTC timestamp at which the report was generated. public DateTime Timestamp { get; set; } Property Value DateTime"
  },
  "api/CSF.Screenplay.ReportModel.ReportableModelBase.html": {
    "href": "api/CSF.Screenplay.ReportModel.ReportableModelBase.html",
    "title": "Class ReportableModelBase | Screenplay",
    "summary": "Class ReportableModelBase Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll Model represents anything which may be reported-upon within an IPerformance. [JsonPolymorphic(TypeDiscriminatorPropertyName = \"Type\")] [JsonDerivedType(typeof(ActorCreatedReport), \"ActorCreatedReport\")] [JsonDerivedType(typeof(ActorGainedAbilityReport), \"ActorGainedAbilityReport\")] [JsonDerivedType(typeof(ActorSpotlitReport), \"ActorSpotlitReport\")] [JsonDerivedType(typeof(SpotlightTurnedOffReport), \"SpotlightTurnedOffReport\")] [JsonDerivedType(typeof(PerformableReport), \"PerformableReport\")] public abstract class ReportableModelBase Inheritance object ReportableModelBase Derived ActorCreatedReport ActorGainedAbilityReport ActorSpotlitReport PerformableReport SpotlightTurnedOffReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This base model has subclasses for each of the specific types of event which may be reported-upon. Properties ActorName Gets or sets the name of the Actor who is associated with this report. public string ActorName { get; set; } Property Value string Remarks Almost all reportables involve an actor, it is rare for this value to be unset (IE: null). Report Gets or sets the human-readable text of the report. public string Report { get; set; } Property Value string"
  },
  "api/CSF.Screenplay.ReportModel.ScreenplayReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.ScreenplayReport.html",
    "title": "Class ScreenplayReport | Screenplay",
    "summary": "Class ScreenplayReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll Represents a complete Screenplay report. public class ScreenplayReport Inheritance object ScreenplayReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This type is not used in the writing of Screenplay reports; the JsonScreenplayReporter writes the report by streaming it to a file as it is generated. This type is used only for the deserialization of a report file. Properties Metadata Gets or sets the metadata for the report. public ReportMetadata Metadata { get; set; } Property Value ReportMetadata Performances Gets or sets the performances which are included within the report. public ICollection<PerformanceReport> Performances { get; set; } Property Value ICollection<PerformanceReport> Remarks There is no defined order to the performances within the report. The order in which they appear in this collection will correspond to the order in which they were serialized to the report file. However, because performances may occur in parallel, there is no guarantee that the order will be stable between different reports, even if the Screenplay and IPerformance instances contained are the same, with the same logic."
  },
  "api/CSF.Screenplay.ReportModel.SpotlightTurnedOffReport.html": {
    "href": "api/CSF.Screenplay.ReportModel.SpotlightTurnedOffReport.html",
    "title": "Class SpotlightTurnedOffReport | Screenplay",
    "summary": "Class SpotlightTurnedOffReport Namespace CSF.Screenplay.ReportModel Assembly CSF.Screenplay.dll An implementation of ReportableModelBase which occurs when the spotlight is turned off. public class SpotlightTurnedOffReport : ReportableModelBase Inheritance object ReportableModelBase SpotlightTurnedOffReport Inherited Members ReportableModelBase.Report ReportableModelBase.ActorName object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This model exposes nothing more than the ReportableModelBase already provides."
  },
  "api/CSF.Screenplay.ReportModel.html": {
    "href": "api/CSF.Screenplay.ReportModel.html",
    "title": "Namespace CSF.Screenplay.ReportModel | Screenplay",
    "summary": "Namespace CSF.Screenplay.ReportModel Classes ActorCreatedReport An implementation of ReportableModelBase which represents the addition/creation of a new actor in a performance. ActorGainedAbilityReport An implementation of ReportableModelBase which occurs when an Actor gains a new ability. ActorSpotlitReport An implementation of ReportableModelBase which occurs when an Actor is put into the spotlight. IdentifierAndNameModel Model represents an IdentifierAndName within a Screenplay report. PerformableAsset Model represents a single asset which was recorded from a performable. PerformableReport An implementation of ReportableModelBase which represents the execution of a performable item. PerformanceReport Model represents an IPerformance within a Screenplay report. ReportMetadata Model represents the metadata about a Screenplay report. ReportableModelBase Model represents anything which may be reported-upon within an IPerformance. ScreenplayReport Represents a complete Screenplay report. SpotlightTurnedOffReport An implementation of ReportableModelBase which occurs when the spotlight is turned off."
  },
  "api/CSF.Screenplay.Reporting.AssetPathProvider.html": {
    "href": "api/CSF.Screenplay.Reporting.AssetPathProvider.html",
    "title": "Class AssetPathProvider | Screenplay",
    "summary": "Class AssetPathProvider Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Implementation of IGetsAssetFilePath which filename paths for assets. public class AssetPathProvider : IGetsAssetFilePath Inheritance object AssetPathProvider Implements IGetsAssetFilePath Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Paths which are generated by this class are in the format: YYYY-MM-DDTHHMMSSZ_PERFORMANCEID_ASSETNUMBER_BASENAME. The first part of the filename is a timestamp, similar to ISO 8601, except that the : characters separating the hours, minutes and seconds are omitted. The second part is the performance identifier, equal to either the Identifier of the last item from NamingHierarchy, or if the naming hierarchy is empty, the PerformanceIdentity. The third part is a zero-padded asset number, to differentiate between multiple assets generated during the same performance. The final part is the base name of the asset as specified by the consuming logic. The path returned from GetAssetFilePath(string) will be in the same directory as the report file, as returned by GetReportPath(). If the report path returned by that service is null then this method will also return null, meaning that the asset file should not be written. This type is somewhat stateful, because it maintains an internal counter in order to provide the asset numbers (described above). It should be consumed from dependency injection as a scoped service, so that each performance has its own instance of this type. This class is intended for internal Screenplay usage. Normal consumers of Screenplay should not concern themselves with this detail. Instead they should grant the GetAssetFilePaths to actors who should be able to save asset files. Constructors AssetPathProvider(IGetsReportPath, IPerformance) Initializes a new instance of the AssetPathProvider class. public AssetPathProvider(IGetsReportPath reportPathProvider, IPerformance performance) Parameters reportPathProvider IGetsReportPath The report path provider. performance IPerformance The performance. Methods GetAssetFilePath(string) Gets the filesystem path to which an asset file should be written. public string GetAssetFilePath(string baseName) Parameters baseName string A short & descriptive filename fragment, which includes the file extension but no path information Returns string An absolute file system path at which the asset file should be saved, or a null reference indicating that the asset file should not be saved. Remarks If reporting is disabled, for the same reasons as GetReportPath() would return null, then this method will also return null. In that case, reporting is disabled and no asset files should be written to the file system. If reporting is enabled, then this method should return an absolute file system path to which an asset file should be written, where the asset has the specified 'base name'. That base name should be a short filename fragment which describes the asset. This file name will be embellished with other information by this method, such as to ensure that the file name is unique within the current Screenplay run."
  },
  "api/CSF.Screenplay.Reporting.FormattableFormatter.html": {
    "href": "api/CSF.Screenplay.Reporting.FormattableFormatter.html",
    "title": "Class FormattableFormatter | Screenplay",
    "summary": "Class FormattableFormatter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Implementation of IValueFormatter which formats objects that implement IFormattableValue. public class FormattableFormatter : IValueFormatter Inheritance object FormattableFormatter Implements IValueFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CanFormat(object) Gets a value indicating whether this object is suitable for formatting the specified value. public bool CanFormat(object value) Parameters value object The value to be formatted Returns bool true if this formatter is suitable for formatting the specified value; false if not. FormatForReport(object) Gets a formatted string which represents the specified value. public string FormatForReport(object value) Parameters value object The value to be formatted Returns string A formatted string which represents the specified value. Remarks Ensure that the value has been tested with CanFormat(object) before executing this method. The behaviour of this method is undefined for any value for which the can-format method does not return true. It may lead to exceptions or garbage output."
  },
  "api/CSF.Screenplay.Reporting.HumanizerFormatter.html": {
    "href": "api/CSF.Screenplay.Reporting.HumanizerFormatter.html",
    "title": "Class HumanizerFormatter | Screenplay",
    "summary": "Class HumanizerFormatter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll A formatter which makes use of the Humanizer: https://github.com/Humanizr/Humanizer library to format a limited number of value types. public class HumanizerFormatter : IValueFormatter Inheritance object HumanizerFormatter Implements IValueFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks In theory this formatter could do quite a lot more, as Humanizer's capabilities are much wider than the functionality used here. Since this is a preloaded/default formatter, it is intentionally limited so as to avoid accidentally \"humanising\" values which were already human-readable, mangling them in an unwanted way. The types supported by this formatter implementation are: Type Note DateTime Formatted by Humanizer Nullable<T> of DateTime Formatted by Humanizer if not null, otherwise CanFormat(object) will return false TimeSpan Formatted by Humanizer Nullable<T> of TimeSpan Formatted by Humanizer if not null, otherwise CanFormat(object) will return false Implements IEnumerable<T> of string Formatted by Humanizer into a comma-separated list Developers are welcome to create their own formatter implementations which make use of Humanizer (the dependency is already present) and which more closely target the values they'd like formatted. This class is intentionally limited to formatting values which are unlikely to be controversial. Methods CanFormat(object) Gets a value indicating whether this object is suitable for formatting the specified value. public bool CanFormat(object value) Parameters value object The value to be formatted Returns bool true if this formatter is suitable for formatting the specified value; false if not. FormatForReport(object) Gets a formatted string which represents the specified value. public string FormatForReport(object value) Parameters value object The value to be formatted Returns string A formatted string which represents the specified value. Remarks Ensure that the value has been tested with CanFormat(object) before executing this method. The behaviour of this method is undefined for any value for which the can-format method does not return true. It may lead to exceptions or garbage output."
  },
  "api/CSF.Screenplay.Reporting.IDeserializesReport.html": {
    "href": "api/CSF.Screenplay.Reporting.IDeserializesReport.html",
    "title": "Interface IDeserializesReport | Screenplay",
    "summary": "Interface IDeserializesReport Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll An object which deserializes a Screenplay report from a stream. public interface IDeserializesReport Methods DeserializeAsync(Stream) Deserializes a Screenplay report from the provided stream asynchronously. Task<ScreenplayReport> DeserializeAsync(Stream stream) Parameters stream Stream The stream containing the serialized Screenplay report. Returns Task<ScreenplayReport> A task that represents the asynchronous operation. The task result contains the deserialized Screenplay report."
  },
  "api/CSF.Screenplay.Reporting.IFormattableValue.html": {
    "href": "api/CSF.Screenplay.Reporting.IFormattableValue.html",
    "title": "Interface IFormattableValue | Screenplay",
    "summary": "Interface IFormattableValue Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll An object which has its own functionality for generating a human-readable representation of itself for a Screenplay report. public interface IFormattableValue Remarks Implement this interface in your own types in order to provide a custom representation of the object when it is included in a Screenplay report. The FormatForReport() method should be used to create a human-readable string which represents the object in the report text. This interface is a part of the mechanism for formatting values in reports in Screenplay. Methods FormatForReport() Gets a human-readable formatted string which represents the current object instance, suitable to be used in a Screenplay report. string FormatForReport() Returns string A formatted string which represents the current instance. See Also IHasName IValueFormatter"
  },
  "api/CSF.Screenplay.Reporting.IFormatterRegistry.html": {
    "href": "api/CSF.Screenplay.Reporting.IFormatterRegistry.html",
    "title": "Interface IFormatterRegistry | Screenplay",
    "summary": "Interface IFormatterRegistry Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll A registry of the concrete types of IValueFormatter which are available for use by the Screenplay reporting functionality. public interface IFormatterRegistry : IList<Type>, ICollection<Type>, IEnumerable<Type>, IEnumerable Inherited Members IList<Type>.IndexOf(Type) IList<Type>.Insert(int, Type) IList<Type>.RemoveAt(int) IList<Type>.this[int] ICollection<Type>.Add(Type) ICollection<Type>.Clear() ICollection<Type>.Contains(Type) ICollection<Type>.CopyTo(Type[], int) ICollection<Type>.Remove(Type) ICollection<Type>.Count ICollection<Type>.IsReadOnly IEnumerable<Type>.GetEnumerator() Remarks Formatter types stored within this registry will be selected for use in the reverse order in which they appear in the collection. When selecting a formatter for a particular object/value, this collection will be iterated starting at the end, moving toward the beginning. This means that (presuming new formatter types are added using Add(T)), types which are added later will be used with precedence over those which are added earlier. This is the mechanism which is used as a tie-breaker if two or more IValueFormatter types would both return true from CanFormat(object). Developers might want to add a IValueFormatter type to this collection, which is to have a lower precedence than another which has already been added, when they are both able to format the same value. In that scenario, use Insert(int, T) to explicitly add the formatter at a lower index (closer to the start of the collection)."
  },
  "api/CSF.Screenplay.Reporting.IGetsAssetFilePath.html": {
    "href": "api/CSF.Screenplay.Reporting.IGetsAssetFilePath.html",
    "title": "Interface IGetsAssetFilePath | Screenplay",
    "summary": "Interface IGetsAssetFilePath Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll A service which gets a filesystem path to which Screenplay asset files should be written, if they are to be written at all. public interface IGetsAssetFilePath Methods GetAssetFilePath(string) Gets the filesystem path to which an asset file should be written. string GetAssetFilePath(string baseName) Parameters baseName string A short & descriptive filename fragment, which includes the file extension but no path information Returns string An absolute file system path at which the asset file should be saved, or a null reference indicating that the asset file should not be saved. Remarks If reporting is disabled, for the same reasons as GetReportPath() would return null, then this method will also return null. In that case, reporting is disabled and no asset files should be written to the file system. If reporting is enabled, then this method should return an absolute file system path to which an asset file should be written, where the asset has the specified 'base name'. That base name should be a short filename fragment which describes the asset. This file name will be embellished with other information by this method, such as to ensure that the file name is unique within the current Screenplay run."
  },
  "api/CSF.Screenplay.Reporting.IGetsReportFormat.html": {
    "href": "api/CSF.Screenplay.Reporting.IGetsReportFormat.html",
    "title": "Interface IGetsReportFormat | Screenplay",
    "summary": "Interface IGetsReportFormat Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll An object which can get a ReportFormat from a report format template and the associated values. public interface IGetsReportFormat Methods GetReportFormat(string, IList<object>) Gets a ReportFormat instance from the specified template and collection of values. ReportFormat GetReportFormat(string template, IList<object> values) Parameters template string The original report format template values IList<object> An ordered collection of placeholder values to be used with the template Returns ReportFormat An instance of ReportFormat which combines the template and the values. Remarks The template is intended to be a human-readable string, with value placeholders enclosed within braces. The values is a collection of data values to be used as the 'filler' for those placeholders. The order in which the values are provided is important, as the placeholders will be filled in the order in which they appear in the template string. Note that duplicate placeholders will receive the same value and do not require the value to be repeated in the values collection. Exceptions ArgumentNullException If any parameter is null."
  },
  "api/CSF.Screenplay.Reporting.IGetsReportPath.html": {
    "href": "api/CSF.Screenplay.Reporting.IGetsReportPath.html",
    "title": "Interface IGetsReportPath | Screenplay",
    "summary": "Interface IGetsReportPath Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll A service which gets the path to which the Screenplay report should be written. public interface IGetsReportPath Methods GetReportPath() Gets the path to which the report should be written. string GetReportPath() Returns string The report path. Remarks If the returned path is null then Screenplay's reporting functionality should be disabled and no report should be written. Otherwise, implementations of this interface should return an absolute file system path to which the report should be written. This path must be writable by the executing process. Reporting could be disabled if either the Screenplay Options report path is null or a whitespace-only string, or if the path indicated by those options is not writable."
  },
  "api/CSF.Screenplay.Reporting.IGetsValueFormatter.html": {
    "href": "api/CSF.Screenplay.Reporting.IGetsValueFormatter.html",
    "title": "Interface IGetsValueFormatter | Screenplay",
    "summary": "Interface IGetsValueFormatter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll An object which can select the most appropriate implementation of IValueFormatter from a IFormatterRegistry. public interface IGetsValueFormatter Extension Methods ValueFormatterExtensions.FormatValue(IGetsValueFormatter, object) Methods GetValueFormatter(object) Selects and returns an IValueFormatter which is most appropriate to the specified value. IValueFormatter GetValueFormatter(object value) Parameters value object The value to be formatted Returns IValueFormatter A value formatter Remarks See the remarks for IFormatterRegistry for more information about the algorithm by which an appropriate formatter is selected. It should be very rare for this method to raise an exception; as implementations of this type should come pre-loaded with fallback formatters which may format any value. Exceptions might only be expected if a developer removes these default formatters and does not replace them with suitable implementaton types that can cover all scenarios. Exceptions InvalidOperationException If no appropriate formatter could be selected"
  },
  "api/CSF.Screenplay.Reporting.IReporter.html": {
    "href": "api/CSF.Screenplay.Reporting.IReporter.html",
    "title": "Interface IReporter | Screenplay",
    "summary": "Interface IReporter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll Defines a reporter that subscribes to and processes events from a Screenplay event notifier. public interface IReporter : IDisposable Inherited Members IDisposable.Dispose() Remarks Implementations of this interface are responsible for accumulating information about the Screenplay as events are received, and generating reports based on that information. Methods SubscribeTo(IHasPerformanceEvents) Subscribes to the events emitted by the specified Screenplay event notifier. void SubscribeTo(IHasPerformanceEvents events) Parameters events IHasPerformanceEvents A Screenplay event notifier Remarks As events are received, this reporter instance may accumulate information about the Screnplay that it is to report upon. UnsubscribeFrom(IHasPerformanceEvents) Unsubscribes from the specified Screenplay event notifier. void UnsubscribeFrom(IHasPerformanceEvents events) Parameters events IHasPerformanceEvents A Screenplay event notifier Remarks Use this method only after the event notifier has emitted the ScreenplayEnded event. If this reporter unsubscribes from Screenplay events before the Screenplay has ended then the results are undefined. This could lead to a corrupt report file."
  },
  "api/CSF.Screenplay.Reporting.ITestsPathForWritePermissions.html": {
    "href": "api/CSF.Screenplay.Reporting.ITestsPathForWritePermissions.html",
    "title": "Interface ITestsPathForWritePermissions | Screenplay",
    "summary": "Interface ITestsPathForWritePermissions Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll An object which may test a file system path for writability. public interface ITestsPathForWritePermissions Methods HasWritePermission(string) Gets a value indicating whether or not the current process should be able to write a file at the specified path. bool HasWritePermission(string path) Parameters path string An absolute or relative file path. Returns bool true if the current process is able to write to the specified path; false if not. Remarks The path may be relative or absolute; if relative then it is treated as relative to the current working directory."
  },
  "api/CSF.Screenplay.Reporting.IValueFormatter.html": {
    "href": "api/CSF.Screenplay.Reporting.IValueFormatter.html",
    "title": "Interface IValueFormatter | Screenplay",
    "summary": "Interface IValueFormatter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll An object which can format a value which appears within a Screenplay report. public interface IValueFormatter Remarks Implement this interface in your own types in order to create a service which may externally format values for inclusion in a Screenplay report. A typical Screenplay solution will include many implementations of this interface, each of which is responsible for formatting a specific subset of values. Before an implementation of this type is used to format a value, the CanFormat(object) method should be called in order to determine whether the formatter is suitable for the value in question. This is an application of the strategy pattern: https://en.wikipedia.org/wiki/Strategy_pattern. For any concrete implementation of this interface to be considered in formatting a value with a report, its type must first be registered with the IFormatterRegistry. The FormatForReport(object) method should be used to create a human-readable string which represents the object in the report text. This interface is a part of the mechanism for formatting values in reports in Screenplay. Methods CanFormat(object) Gets a value indicating whether this object is suitable for formatting the specified value. bool CanFormat(object value) Parameters value object The value to be formatted Returns bool true if this formatter is suitable for formatting the specified value; false if not. FormatForReport(object) Gets a formatted string which represents the specified value. string FormatForReport(object value) Parameters value object The value to be formatted Returns string A formatted string which represents the specified value. Remarks Ensure that the value has been tested with CanFormat(object) before executing this method. The behaviour of this method is undefined for any value for which the can-format method does not return true. It may lead to exceptions or garbage output. See Also IHasName IFormattableValue IFormatterRegistry"
  },
  "api/CSF.Screenplay.Reporting.JsonScreenplayReportReader.html": {
    "href": "api/CSF.Screenplay.Reporting.JsonScreenplayReportReader.html",
    "title": "Class JsonScreenplayReportReader | Screenplay",
    "summary": "Class JsonScreenplayReportReader Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Implementation of IDeserializesReport that deserializes a Screenplay report from a JSON stream. public class JsonScreenplayReportReader : IDeserializesReport Inheritance object JsonScreenplayReportReader Implements IDeserializesReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods DeserializeAsync(Stream) Deserializes a Screenplay report from the provided stream asynchronously. public Task<ScreenplayReport> DeserializeAsync(Stream stream) Parameters stream Stream The stream containing the serialized Screenplay report. Returns Task<ScreenplayReport> A task that represents the asynchronous operation. The task result contains the deserialized Screenplay report."
  },
  "api/CSF.Screenplay.Reporting.JsonScreenplayReporter.html": {
    "href": "api/CSF.Screenplay.Reporting.JsonScreenplayReporter.html",
    "title": "Class JsonScreenplayReporter | Screenplay",
    "summary": "Class JsonScreenplayReporter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll An object which subscribes/listens to the events of IHasPerformanceEvents and which produces a JSON-formatted report from them. public sealed class JsonScreenplayReporter : IReporter, IDisposable Inheritance object JsonScreenplayReporter Implements IReporter IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Note that instances of this class are not reusable; this is a stateful type. Each instance builds and writes a single report file which corresponds to the execution of a single instance of Screenplay. To write a second report, or to write a report about a different Screenplay, please create a new instance of this type. This type works by accumulating reporting information about IPerformance instances using ScreenplayReportBuilder. Each of these performances may themselves accumulate information from the various events which occur during the performance lifetime. Once a performance is ended (success or otherwise), the completed PerformanceReport may be retrieved from the screenplay report builder. This is then written & flushed to the JSON file. The writing of JSON must be performed in a thread-safe manner, recall that multiple performances could be ongoing at the same time, in parallel. Additionally, it is important to write the JSON as-we-progress, rather than waiting until the end of the Screenplay, or the ScreenplayEnded event. That's because in many scenarios, the end of the Screenplay is triggered by the assembly-unload events for the whole process. This is particularly true for software testing frameworks. If we waited to write all of the JSON at the very end of the process then it is very likely that the write will be interrupted. Logic triggered from unload event handlers is permitted only a tiny amount of system compute resource and is inappropriate for performing anything substantial. This is why this type writes each performance to JSON as it completes, essentially streaming the information to the JSON file. This means that all that is left to be done when the Screenplay completes is to write a few closing symbols and then close the file. Constructors JsonScreenplayReporter(Stream, ScreenplayReportBuilder) Initializes a new instance of JsonScreenplayReporter for a specified file path. public JsonScreenplayReporter(Stream writeStream, ScreenplayReportBuilder builder) Parameters writeStream Stream The stream to which the JSON report shall be written. builder ScreenplayReportBuilder The Screenplay report builder Exceptions ArgumentNullException If writeStream is null. Methods Dispose() public void Dispose() SubscribeTo(IHasPerformanceEvents) Subscribes to the events emitted by the specified Screenplay event notifier. public void SubscribeTo(IHasPerformanceEvents events) Parameters events IHasPerformanceEvents A Screenplay event notifier Remarks As events are received, this reporter instance may accumulate information about the Screnplay that it is to report upon. UnsubscribeFrom(IHasPerformanceEvents) Unsubscribes from the specified Screenplay event notifier. public void UnsubscribeFrom(IHasPerformanceEvents events) Parameters events IHasPerformanceEvents A Screenplay event notifier Remarks Use this method only after the event notifier has emitted the ScreenplayEnded event. If this reporter unsubscribes from Screenplay events before the Screenplay has ended then the results are undefined. This could lead to a corrupt report file."
  },
  "api/CSF.Screenplay.Reporting.NameAndValue.html": {
    "href": "api/CSF.Screenplay.Reporting.NameAndValue.html",
    "title": "Class NameAndValue | Screenplay",
    "summary": "Class NameAndValue Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll A simple model for a value that is to be included in a formatted ReportFragment, which has an associated name. public class NameAndValue Inheritance object NameAndValue Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NameAndValue(string, object) Initializes a new instance of NameAndValue. public NameAndValue(string name, object value) Parameters name string The name for the value value object The value Exceptions ArgumentNullException If name is null. Properties Name Gets the name associated with this value. public string Name { get; } Property Value string Value Gets the value. public object Value { get; } Property Value object"
  },
  "api/CSF.Screenplay.Reporting.NameFormatter.html": {
    "href": "api/CSF.Screenplay.Reporting.NameFormatter.html",
    "title": "Class NameFormatter | Screenplay",
    "summary": "Class NameFormatter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Implementation of IValueFormatter which formats objects that implement IHasName. public class NameFormatter : IValueFormatter Inheritance object NameFormatter Implements IValueFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CanFormat(object) Gets a value indicating whether this object is suitable for formatting the specified value. public bool CanFormat(object value) Parameters value object The value to be formatted Returns bool true if this formatter is suitable for formatting the specified value; false if not. FormatForReport(object) Gets a formatted string which represents the specified value. public string FormatForReport(object value) Parameters value object The value to be formatted Returns string A formatted string which represents the specified value. Remarks Ensure that the value has been tested with CanFormat(object) before executing this method. The behaviour of this method is undefined for any value for which the can-format method does not return true. It may lead to exceptions or garbage output."
  },
  "api/CSF.Screenplay.Reporting.NoOpReporter.html": {
    "href": "api/CSF.Screenplay.Reporting.NoOpReporter.html",
    "title": "Class NoOpReporter | Screenplay",
    "summary": "Class NoOpReporter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll A no-op implementation of IReporter which does nothing. public sealed class NoOpReporter : IReporter, IDisposable Inheritance object NoOpReporter Implements IReporter IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Methods Dispose() public void Dispose() SubscribeTo(IHasPerformanceEvents) Subscribes to the events emitted by the specified Screenplay event notifier. public void SubscribeTo(IHasPerformanceEvents events) Parameters events IHasPerformanceEvents A Screenplay event notifier Remarks As events are received, this reporter instance may accumulate information about the Screnplay that it is to report upon. UnsubscribeFrom(IHasPerformanceEvents) Unsubscribes from the specified Screenplay event notifier. public void UnsubscribeFrom(IHasPerformanceEvents events) Parameters events IHasPerformanceEvents A Screenplay event notifier Remarks Use this method only after the event notifier has emitted the ScreenplayEnded event. If this reporter unsubscribes from Screenplay events before the Screenplay has ended then the results are undefined. This could lead to a corrupt report file."
  },
  "api/CSF.Screenplay.Reporting.PerformanceReportBuilder.html": {
    "href": "api/CSF.Screenplay.Reporting.PerformanceReportBuilder.html",
    "title": "Class PerformanceReportBuilder | Screenplay",
    "summary": "Class PerformanceReportBuilder Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Builder for an instance of PerformanceReport. public class PerformanceReportBuilder Inheritance object PerformanceReportBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This is a stateful builder, so instances of this type are not reusable for more than one PerformanceReport. Constructors PerformanceReportBuilder(List<IdentifierAndNameModel>, IGetsValueFormatter, IFormatsReportFragment) Initialises a new instance of PerformanceReportBuilder. public PerformanceReportBuilder(List<IdentifierAndNameModel> namingHierarchy, IGetsValueFormatter valueFormatterProvider, IFormatsReportFragment formatter) Parameters namingHierarchy List<IdentifierAndNameModel> The naming hierarchy of the performance; see NamingHierarchy valueFormatterProvider IGetsValueFormatter A value formatter factory formatter IFormatsReportFragment A report-fragment formatter Exceptions ArgumentNullException If any parameter is null. Methods ActorCreated(Actor) Adds a report to the current performance indicating that an actor has been created/added to the performance. public void ActorCreated(Actor actor) Parameters actor Actor The actor ActorGainedAbility(Actor, object) Adds a report to the current performance indicating that an actor has gained/been granted a new ability. public void ActorGainedAbility(Actor actor, object ability) Parameters actor Actor The actor ability object The ability which was granted ActorSpotlit(Actor) Adds a report to the current performance indicating that an actor has been placed into the spotlight. public void ActorSpotlit(Actor actor) Parameters actor Actor The actor Remarks For more information, see the spotlight glossary item. BeginPerformable(object, Actor, string) Begins a new report within the current performance, that a new performable has been begun. public void BeginPerformable(object performable, Actor actor, string performancePhase) Parameters performable object The performable obeject which has begun actor Actor The actor executing the performable performancePhase string The performance phase in which the performable occurs Remarks This might be a new performable at the root of the performance, or it might be nested within another performable which is already in progress. When this method is executed, the performable becomes the 'current' performable for this builder. The current performable is tracked as a Stack<T>, as a performable may contain a hierarchy of further performables, each of which becomes the current performable in its turn. This method pushes a new performable onto the stack. Once all of the consumed performables have finished, the current performable will return to this one. Thus, as performables begin and end, the current performable stack will be pushed and popped many times. See Also EndPerformable(object, Actor) RecordFailureForCurrentPerformable(Exception) EndPerformable(object, Actor) Indicates that the current performable has finished normally and that it should no longer be current. public void EndPerformable(object performable, Actor actor) Parameters performable object The performable which is ending actor Actor The actor which was executing the performable Remarks This method will 'pop' the current performable from the current performable stack. The current performable will become either the performable which directly consumed/composed the one which is ending, or perhaps this will lead to there being no current performable (if the ending performable was at the root of the performance). See Also BeginPerformable(object, Actor, string) GetReport(bool?) Records the outcome of this performance and gets the report. public PerformanceReport GetReport(bool? success) Parameters success bool? A value indicating the outcome of the performance, this has the same semantics as the parameter to FinishPerformance(bool?) Returns PerformanceReport The completed performance report. Remarks Use this method when the performance has completed. Once this method has been used, it is normal that this builder instance will not be used any further. RecordAssetForCurrentPerformable(string, string) Enriches the current performable with information about a file asset. public void RecordAssetForCurrentPerformable(string assetPath, string assetSummary) Parameters assetPath string The file path to the asset assetSummary string The human readable summary of the asset Remarks This method may be called many times for the same performable, or it might not be used at all. RecordFailureForCurrentPerformable(Exception) Records the current performable as a failure, due to an uncaught exception. public void RecordFailureForCurrentPerformable(Exception exception) Parameters exception Exception The exception which lead to the failure Remarks This method will 'pop' the current performable from the current performable stack. The current performable will become either the performable which directly consumed/composed the one which is ending, or perhaps this will lead to there being no current performable (if the ending performable was at the root of the performance). RecordResultForCurrentPerformable(object) Enriches the current performable with information about its result. public void RecordResultForCurrentPerformable(object result) Parameters result object The result of the performable Remarks This method is only applicable to performables which may return a result. SpotlightTurnedOff() Adds a report to the current performance indicating that the spotlight has been turned off. public void SpotlightTurnedOff() Remarks For more information, see the spotlight glossary item."
  },
  "api/CSF.Screenplay.Reporting.ReportFormat.html": {
    "href": "api/CSF.Screenplay.Reporting.ReportFormat.html",
    "title": "Class ReportFormat | Screenplay",
    "summary": "Class ReportFormat Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll Model used for creating a ReportFragment, which includes the original report fragment template string, a reworked template string suitable for use with Format(string, params object[]) and the placeholder values to be inserted into that format. public class ReportFormat Inheritance object ReportFormat Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ReportFormat(string, string, IList<NameAndValue>) Initializes a new instance of ReportFormat. public ReportFormat(string originalTemplate, string formatTemplate, IList<NameAndValue> values) Parameters originalTemplate string The original template string formatTemplate string The reformatted template string values IList<NameAndValue> The placeholder values and their names Exceptions ArgumentNullException If any parameter is null. Properties FormatTemplate Gets a reformatted version of OriginalTemplate, which includes only numeric placeholders. public string FormatTemplate { get; } Property Value string Remarks This string should be in a format which could be used by Format(string, params object[]). OriginalTemplate Gets the original template string, which may include named placeholders. public string OriginalTemplate { get; } Property Value string Values Gets a collection of the placeholder values which are to be inserted into the FormatTemplate. public IReadOnlyList<NameAndValue> Values { get; } Property Value IReadOnlyList<NameAndValue> Remarks The value's numeric position/index in this collection corresponds to which of the numeric placeholders of FormatTemplate the value should be inserted into. The Name associated with the value may be used to report upon the name of that particular value, preserving that aspect of the OriginalTemplate for informational purposes."
  },
  "api/CSF.Screenplay.Reporting.ReportFormatCreator.html": {
    "href": "api/CSF.Screenplay.Reporting.ReportFormatCreator.html",
    "title": "Class ReportFormatCreator | Screenplay",
    "summary": "Class ReportFormatCreator Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Default implementation of IGetsReportFormat. public class ReportFormatCreator : IGetsReportFormat Inheritance object ReportFormatCreator Implements IGetsReportFormat Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetReportFormat(string, IList<object>) Gets a ReportFormat instance from the specified template and collection of values. public ReportFormat GetReportFormat(string template, IList<object> values) Parameters template string The original report format template values IList<object> An ordered collection of placeholder values to be used with the template Returns ReportFormat An instance of ReportFormat which combines the template and the values. Remarks The template is intended to be a human-readable string, with value placeholders enclosed within braces. The values is a collection of data values to be used as the 'filler' for those placeholders. The order in which the values are provided is important, as the placeholders will be filled in the order in which they appear in the template string. Note that duplicate placeholders will receive the same value and do not require the value to be repeated in the values collection. Exceptions ArgumentNullException If any parameter is null."
  },
  "api/CSF.Screenplay.Reporting.ReportPathProvider.html": {
    "href": "api/CSF.Screenplay.Reporting.ReportPathProvider.html",
    "title": "Class ReportPathProvider | Screenplay",
    "summary": "Class ReportPathProvider Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Stateful implementation of IGetsReportPath which caches the outcome of the path-determination logic. public class ReportPathProvider : IGetsReportPath Inheritance object ReportPathProvider Implements IGetsReportPath Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class uses ReportPath as its primary source of truth. However, if that value is null/whitespace or if the path is not writable then this class will return null from GetReportPath(), disabling the reporting functionality. If ReportPath is a relative path then it is combined with the current working directory to form an absolute path, thus (if GetReportPath() does not return null), its return value will always be an absolute path. Because of the caching functionality, this class is stateful and should be used as a singleton. Constructors ReportPathProvider(IOptions<ScreenplayOptions>, ITestsPathForWritePermissions) Initializes a new instance of the ReportPathProvider class. public ReportPathProvider(IOptions<ScreenplayOptions> screenplayOptions, ITestsPathForWritePermissions permissionsTester) Parameters screenplayOptions IOptions<ScreenplayOptions> The screenplay options. permissionsTester ITestsPathForWritePermissions The permissions tester. Methods GetReportPath() Gets the path to which the report should be written. public string GetReportPath() Returns string The report path. Remarks If the returned path is null then Screenplay's reporting functionality should be disabled and no report should be written. Otherwise, implementations of this interface should return an absolute file system path to which the report should be written. This path must be writable by the executing process. Reporting could be disabled if either the Screenplay Options report path is null or a whitespace-only string, or if the path indicated by those options is not writable."
  },
  "api/CSF.Screenplay.Reporting.ScreenplayReportBuilder.html": {
    "href": "api/CSF.Screenplay.Reporting.ScreenplayReportBuilder.html",
    "title": "Class ScreenplayReportBuilder | Screenplay",
    "summary": "Class ScreenplayReportBuilder Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Builder type accumulates PerformanceReportBuilder as performances occur within the Screenplay. public class ScreenplayReportBuilder Inheritance object ScreenplayReportBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This type is used by JsonScreenplayReporter so that it may direct the appropriate reports (relating to performances) to the appropriate performance. Be mindful that performances could be occurring in parallel, so it would be incorrect to maintain a concept of \"the current performance\". This class provides a thread-safe mechanism by which to access the builder for each performance, as they occur. Use BeginPerformance(Guid, IReadOnlyList<IdentifierAndName>) in order to add a new performance to this builder. During that performance's lifespan use GetPerformanceBuilder(Guid) in order to direct logic to its builder. Once the performance is over, use EndPerformanceAndGetReport(Guid, bool?) to remove that performance from this instance (it doesn't need tracking once it's finished) and to get the completed report for that performance. Constructors ScreenplayReportBuilder(Func<List<IdentifierAndNameModel>, PerformanceReportBuilder>) Initialises a new instance of ScreenplayReportBuilder. public ScreenplayReportBuilder(Func<List<IdentifierAndNameModel>, PerformanceReportBuilder> performanceBuilderFactory) Parameters performanceBuilderFactory Func<List<IdentifierAndNameModel>, PerformanceReportBuilder> A factory function for performance report builders Exceptions ArgumentNullException If performanceBuilderFactory is null. Methods BeginPerformance(Guid, IReadOnlyList<IdentifierAndName>) Begins building a report about a new performance. public void BeginPerformance(Guid performanceIdentifier, IReadOnlyList<IdentifierAndName> namingHierarchy) Parameters performanceIdentifier Guid The performance identifier namingHierarchy IReadOnlyList<IdentifierAndName> A naming hierarchy for that performance Remarks This method adds the new performance to the state of the current instance, so that it tracked and may be built by accumulating further reporting data. Once the performance is being tracked, use GetPerformanceBuilder(Guid) to return a reference to that builder. Use EndPerformanceAndGetReport(Guid, bool?) once the performance is finished (successfully or otherwise), which will remove it from the current Screenplay builder. See Also IPerformance NamingHierarchy IHasPerformanceIdentity EndPerformanceAndGetReport(Guid, bool?) Ends the specified performance, removing its builder from the current instance, and returns the completed/built report. public PerformanceReport EndPerformanceAndGetReport(Guid performanceIdentifier, bool? success) Parameters performanceIdentifier Guid The performance identifier success bool? A value indicating whether or not the performance was a success. This has the same semantics as the parameter to FinishPerformance(bool?) Returns PerformanceReport The performance report which was built by the performance report builder Exceptions ArgumentException If the current Screenplay builder does not have a tracked performance with the specified performanceIdentifier. See Also IPerformance IHasPerformanceIdentity IBeginsAndEndsPerformance PerformanceReport GetPerformanceBuilder(Guid) Gets the performance builder corresponding to the specified identifier. public PerformanceReportBuilder GetPerformanceBuilder(Guid performanceIdentifier) Parameters performanceIdentifier Guid The performance identifier Returns PerformanceReportBuilder A performance report builder which corresponds to the requested performance Exceptions ArgumentException If the current Screenplay builder does not have a tracked performance with the specified performanceIdentifier. See Also IPerformance IHasPerformanceIdentity PerformanceReportBuilder See Also PerformanceReportBuilder"
  },
  "api/CSF.Screenplay.Reporting.ToStringFormatter.html": {
    "href": "api/CSF.Screenplay.Reporting.ToStringFormatter.html",
    "title": "Class ToStringFormatter | Screenplay",
    "summary": "Class ToStringFormatter Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Implementation of IValueFormatter which formats any object by using its default ToString() method, or returns the string <null> if the value is null. public class ToStringFormatter : IValueFormatter Inheritance object ToStringFormatter Implements IValueFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This formatter should be used as a default/last resort. It is very likely that this could produce results which are not particularly human readable. Methods CanFormat(object) Gets a value indicating whether this object is suitable for formatting the specified value. public bool CanFormat(object value) Parameters value object The value to be formatted Returns bool true if this formatter is suitable for formatting the specified value; false if not. FormatForReport(object) Gets a formatted string which represents the specified value. public string FormatForReport(object value) Parameters value object The value to be formatted Returns string A formatted string which represents the specified value. Remarks Ensure that the value has been tested with CanFormat(object) before executing this method. The behaviour of this method is undefined for any value for which the can-format method does not return true. It may lead to exceptions or garbage output."
  },
  "api/CSF.Screenplay.Reporting.ValueFormatterExtensions.html": {
    "href": "api/CSF.Screenplay.Reporting.ValueFormatterExtensions.html",
    "title": "Class ValueFormatterExtensions | Screenplay",
    "summary": "Class ValueFormatterExtensions Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.Abstractions.dll Extension methods for IGetsValueFormatter. public static class ValueFormatterExtensions Inheritance object ValueFormatterExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods FormatValue(IGetsValueFormatter, object) Formats the specified value using an appropriate implementation of IValueFormatter, retrieved from the factory. public static string FormatValue(this IGetsValueFormatter formatterProvider, object value) Parameters formatterProvider IGetsValueFormatter A value formatter factory value object The value to be formatted Returns string The formatted value Remarks This extension method is a convenience, equivalent to using GetValueFormatter(object), followed by FormatForReport(object), both using value as the parameter. Exceptions ArgumentNullException If formatterProvider is null."
  },
  "api/CSF.Screenplay.Reporting.ValueFormatterProvider.html": {
    "href": "api/CSF.Screenplay.Reporting.ValueFormatterProvider.html",
    "title": "Class ValueFormatterProvider | Screenplay",
    "summary": "Class ValueFormatterProvider Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Implementation of IGetsValueFormatter which uses dependency injection services. public class ValueFormatterProvider : IGetsValueFormatter Inheritance object ValueFormatterProvider Implements IGetsValueFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ValueFormatterProvider(IServiceProvider, IFormatterRegistry) Initializes a new instance of ValueFormatterProvider. public ValueFormatterProvider(IServiceProvider services, IFormatterRegistry registry) Parameters services IServiceProvider A service provider registry IFormatterRegistry A registry of the available formatter types Exceptions ArgumentNullException If any parameter is null. Methods GetValueFormatter(object) Selects and returns an IValueFormatter which is most appropriate to the specified value. public IValueFormatter GetValueFormatter(object value) Parameters value object The value to be formatted Returns IValueFormatter A value formatter Remarks See the remarks for IFormatterRegistry for more information about the algorithm by which an appropriate formatter is selected. It should be very rare for this method to raise an exception; as implementations of this type should come pre-loaded with fallback formatters which may format any value. Exceptions might only be expected if a developer removes these default formatters and does not replace them with suitable implementaton types that can cover all scenarios. Exceptions InvalidOperationException If no appropriate formatter could be selected"
  },
  "api/CSF.Screenplay.Reporting.ValueFormatterRegistry.html": {
    "href": "api/CSF.Screenplay.Reporting.ValueFormatterRegistry.html",
    "title": "Class ValueFormatterRegistry | Screenplay",
    "summary": "Class ValueFormatterRegistry Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Default implementation of IFormatterRegistry which also serves as an object factory, by virtue of a service provider. public class ValueFormatterRegistry : IFormatterRegistry, IList<Type>, ICollection<Type>, IEnumerable<Type>, IEnumerable Inheritance object ValueFormatterRegistry Implements IFormatterRegistry IList<Type> ICollection<Type> IEnumerable<Type> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Count public int Count { get; } Property Value int IsReadOnly public bool IsReadOnly { get; } Property Value bool this[int] public Type this[int index] { get; set; } Parameters index int Property Value Type Methods Add(Type) public void Add(Type item) Parameters item Type Clear() public void Clear() Contains(Type) public bool Contains(Type item) Parameters item Type Returns bool CopyTo(Type[], int) public void CopyTo(Type[] array, int arrayIndex) Parameters array Type[] arrayIndex int GetEnumerator() public IEnumerator<Type> GetEnumerator() Returns IEnumerator<Type> IndexOf(Type) public int IndexOf(Type item) Parameters item Type Returns int Insert(int, Type) public void Insert(int index, Type item) Parameters index int item Type Remove(Type) public bool Remove(Type item) Parameters item Type Returns bool RemoveAt(int) public void RemoveAt(int index) Parameters index int"
  },
  "api/CSF.Screenplay.Reporting.WritePermissionTester.html": {
    "href": "api/CSF.Screenplay.Reporting.WritePermissionTester.html",
    "title": "Class WritePermissionTester | Screenplay",
    "summary": "Class WritePermissionTester Namespace CSF.Screenplay.Reporting Assembly CSF.Screenplay.dll Helper class to determine whether or not we have write permission to a specified file path. public class WritePermissionTester : ITestsPathForWritePermissions Inheritance object WritePermissionTester Implements ITestsPathForWritePermissions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods HasWritePermission(string) Gets a value indicating whether or not the current process has write permission to the specified file path. public bool HasWritePermission(string path) Parameters path string An absolute or relative file path. Returns bool true if the current process is able to write to the specified path; false if not. Remarks The path may be relative or absolute; if relative then it is treated as relative to the current working directory. This method will recurse in order to test the permissions for parent directories, if it finds a file or directory which does not exist. When testing for the writability of directories, this is performed by attempting to create a temporary file with a random file name; see GetRandomFileName(). If we are able to create such a file then it is assumed that we have full write permissions to the directory. In this scenario, the temporary file is deleted immediately after. This method will return false if we reach the root directory of the filesystem."
  },
  "api/CSF.Screenplay.Reporting.html": {
    "href": "api/CSF.Screenplay.Reporting.html",
    "title": "Namespace CSF.Screenplay.Reporting | Screenplay",
    "summary": "Namespace CSF.Screenplay.Reporting Classes AssetPathProvider Implementation of IGetsAssetFilePath which filename paths for assets. FormattableFormatter Implementation of IValueFormatter which formats objects that implement IFormattableValue. HumanizerFormatter A formatter which makes use of the Humanizer: https://github.com/Humanizr/Humanizer library to format a limited number of value types. JsonScreenplayReportReader Implementation of IDeserializesReport that deserializes a Screenplay report from a JSON stream. JsonScreenplayReporter An object which subscribes/listens to the events of IHasPerformanceEvents and which produces a JSON-formatted report from them. NameAndValue A simple model for a value that is to be included in a formatted ReportFragment, which has an associated name. NameFormatter Implementation of IValueFormatter which formats objects that implement IHasName. NoOpReporter A no-op implementation of IReporter which does nothing. PerformanceReportBuilder Builder for an instance of PerformanceReport. ReportFormat Model used for creating a ReportFragment, which includes the original report fragment template string, a reworked template string suitable for use with Format(string, params object[]) and the placeholder values to be inserted into that format. ReportFormatCreator Default implementation of IGetsReportFormat. ReportPathProvider Stateful implementation of IGetsReportPath which caches the outcome of the path-determination logic. ScreenplayReportBuilder Builder type accumulates PerformanceReportBuilder as performances occur within the Screenplay. ToStringFormatter Implementation of IValueFormatter which formats any object by using its default ToString() method, or returns the string <null> if the value is null. ValueFormatterExtensions Extension methods for IGetsValueFormatter. ValueFormatterProvider Implementation of IGetsValueFormatter which uses dependency injection services. ValueFormatterRegistry Default implementation of IFormatterRegistry which also serves as an object factory, by virtue of a service provider. WritePermissionTester Helper class to determine whether or not we have write permission to a specified file path. Interfaces IDeserializesReport An object which deserializes a Screenplay report from a stream. IFormattableValue An object which has its own functionality for generating a human-readable representation of itself for a Screenplay report. IFormatterRegistry A registry of the concrete types of IValueFormatter which are available for use by the Screenplay reporting functionality. IGetsAssetFilePath A service which gets a filesystem path to which Screenplay asset files should be written, if they are to be written at all. IGetsReportFormat An object which can get a ReportFormat from a report format template and the associated values. IGetsReportPath A service which gets the path to which the Screenplay report should be written. IGetsValueFormatter An object which can select the most appropriate implementation of IValueFormatter from a IFormatterRegistry. IReporter Defines a reporter that subscribes to and processes events from a Screenplay event notifier. ITestsPathForWritePermissions An object which may test a file system path for writability. IValueFormatter An object which can format a value which appears within a Screenplay report."
  },
  "api/CSF.Screenplay.ScopeAndPerformance.html": {
    "href": "api/CSF.Screenplay.ScopeAndPerformance.html",
    "title": "Class ScopeAndPerformance | Screenplay",
    "summary": "Class ScopeAndPerformance Namespace CSF.Screenplay Assembly CSF.Screenplay.dll A model which contains both an IPerformance and a dependency injection IServiceScope. public sealed class ScopeAndPerformance : IDisposable Inheritance object ScopeAndPerformance Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors ScopeAndPerformance(IPerformance, IServiceScope) Initialises a new instance of ScopeAndPerformance. public ScopeAndPerformance(IPerformance performance, IServiceScope scope) Parameters performance IPerformance The performance scope IServiceScope The scope Exceptions ArgumentNullException If any parameter is null. Properties Performance Gets the performance. public IPerformance Performance { get; } Property Value IPerformance Scope Gets the DI scope. public IServiceScope Scope { get; } Property Value IServiceScope Methods Dispose() public void Dispose()"
  },
  "api/CSF.Screenplay.Screenplay.html": {
    "href": "api/CSF.Screenplay.Screenplay.html",
    "title": "Class Screenplay | Screenplay",
    "summary": "Class Screenplay Namespace CSF.Screenplay Assembly CSF.Screenplay.dll An object which represents a complete execution of Screenplay logic, which should include one or more Performance instances. public sealed class Screenplay : IHasServiceProvider Inheritance object Screenplay Implements IHasServiceProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods ScreenplayExtensions.CreateScopedPerformance(Screenplay, IList<IdentifierAndName>, Guid) ScreenplayExtensions.ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, int) ScreenplayExtensions.ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, CancellationToken) ScreenplayExtensions.ExecuteAsPerformanceAsync<T>(Screenplay, IList<IdentifierAndName>, CancellationToken) ScreenplayExtensions.GetEventBus(Screenplay) Remarks A Screenplay, when used as a noun (an instance of this class), refers to a complete execution of the Screenplay software. A Screenplay is composed of at least one Performance and typically contains many performances. When the Screenplay architecture is applied to automated testing, an instance of this class corresponds to a complete test run, where each test corresponds to a performance. End-user logic, such as test logic, rarely interacts directly with this class. That is because the Screenplay object is generally consumed only by integration logic. It is recommended to create instances of this type by adding Screenplay to a dependency injection IServiceCollection via the extension method AddScreenplay(IServiceCollection) and then resolving an instance of this class from the service provider. Alternatively, if you do not wish to configure a service collection manually and just want an instance of this type then use the static Create(Action<IServiceCollection>) method. The Screenplay object is used to create instances of Performance via its ServiceProvider. You may wish to read a diagram showing how screenplays, performances, actors and performables relate to one another. Constructors Screenplay(IServiceProvider) Initialises a new instance of Screenplay. public Screenplay(IServiceProvider serviceProvider) Parameters serviceProvider IServiceProvider A service provider Remarks It is unlikely that developers should be executing this constructor directly. Consider using the static factory method Create(Action<IServiceCollection>). Alternatively, add Screenplay to an IServiceCollection using AddScreenplay(IServiceCollection) and then resolve an instance of this class from the service provider built from that service collection. Exceptions ArgumentNullException If serviceProvider is null. Properties ServiceProvider Gets a service provider/resolver instance associated with this object. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods BeginScreenplay() Execute this method from the consuming logic in order to inform the Screenplay architecture that the Screenplay has begun. public void BeginScreenplay() CompleteScreenplay() Execute this method from the consuming logic in order to inform the Screenplay architecture that the Screenplay is now complete. public void CompleteScreenplay() Create(Action<IServiceCollection>) Creates and returns a Screenplay, optionally including some dependency injection service customisations. public static Screenplay Create(Action<IServiceCollection> serviceCollectionCustomisations = null) Parameters serviceCollectionCustomisations Action<IServiceCollection> An optional action which permits further customization of the service collection that is implicitly created by this method. Returns Screenplay A Screenplay instance created from a new service collection. Remarks Use this method to create an instance of Screenplay when you are not already using an IServiceCollection. This method creates a new service collection instance, adds Screenplay to it and then creates & returns the Screenplay object instance. If you already have an IServiceCollection and you wish to integrate Screenplay into it, then use the extension method AddScreenplay(IServiceCollection) instead. ExecuteAsPerformanceAsync(Func<IServiceProvider, CancellationToken, Task<bool?>>, IList<IdentifierAndName>, CancellationToken) Executes the specified logic as a Performance public Task<bool?> ExecuteAsPerformanceAsync(Func<IServiceProvider, CancellationToken, Task<bool?>> performanceLogic, IList<IdentifierAndName> namingHierarchy = null, CancellationToken cancellationToken = default) Parameters performanceLogic Func<IServiceProvider, CancellationToken, Task<bool?>> The logic to be executed by the performance. namingHierarchy IList<IdentifierAndName> An optional naming hierarchy used to identify the performance. cancellationToken CancellationToken An optional cancellation token to abort the performance logic. Returns Task<bool?> A task which completes when the performance's logic has completed, returning the result of the performance. Remarks This method is the primary entry point for beginning a Screenplay Performance. This method begins a new Dependency Injection Scope, and within that scope starts the performance, which executes the specified performance logic: performanceLogic. The return value from the performance logic should conform to the semantics of the parameter value passed to FinishPerformance(bool?). The namingHierarchy may be used to give the performance a name, so that its results (and subsequent report) may be identified. This parameter has the same semantics as NamingHierarchy. Note that if the performanceLogic raises a PerformableException then this method will catch that exception and not rethrow. In that case: An event will be raised with the event bus: IHasPerformanceEvents, specifically PerformableFailed. This will contain details of the exception which occurred; subscribers to be informed that the performance has failed. The performance will be immediately terminated and placed into the Failed state. Any other exception, which does not derive from PerformableException, will not be caught by this method and will propagate outward. These exceptions will be interpreted as an error within the Screenplay architecture, since the Actor class will always catch and rethrow any exception encountered from any overload of PerformAsync, wrapped as the inner exception of a PerformableException. Exceptions ArgumentNullException If the performanceLogic is null. See Also Performance ScreenplayServiceCollectionExtensions"
  },
  "api/CSF.Screenplay.ScreenplayAssemblyAttribute.html": {
    "href": "api/CSF.Screenplay.ScreenplayAssemblyAttribute.html",
    "title": "Class ScreenplayAssemblyAttribute | Screenplay",
    "summary": "Class ScreenplayAssemblyAttribute Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll An attribute used to mark an assembly which contains Screenplay-based tests. [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false)] public class ScreenplayAssemblyAttribute : TestActionAttribute, ITestAction Inheritance object Attribute TestActionAttribute ScreenplayAssemblyAttribute Implements ITestAction Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples Decorate your assembly with this attribute using the syntax [assembly: CSF.Screenplay.ScreenplayAssembly]. You may place this into any source file, outside of any type declaration. By convention it would be put into a dedicated source file within the Properties project directory. Remarks This attribute is the core of the NUnit3 test framework integration with Screenplay. In order to run tests with Screenplay, the assembly must be decorated with this attribute. This attribute has one mandatory parameter; that is the Type of a concrete implementation of IGetsScreenplay. That type will be instantiated by the NUnit3 integration and will be used to build and retrieve the Screenplay instance for running the Screenplay-based tests within the decorated assembly. Each test method must additionally be decorated with the ScreenplayAttribute in order to make it a Screenplay-based test. Constructors ScreenplayAssemblyAttribute(Type) Initializes a new instance of ScreenplayAssemblyAttribute. public ScreenplayAssemblyAttribute(Type factoryType) Parameters factoryType Type The concrete type of a class which implements IGetsScreenplay. Remarks The factoryType specified in this constructor must meet all of the following criteria: It must be a non-null Type which derives from IGetsScreenplay It must have a public parameterless constructor It must return a non-null instance of Screenplay from its GetScreenplay() method Properties Targets Provides the target for the action attribute public override ActionTargets Targets { get; } Property Value ActionTargets Methods AfterTest(ITest) Executed after each test is run public override void AfterTest(ITest test) Parameters test ITest The test that has just been run. BeforeTest(ITest) Executed before each test is run public override void BeforeTest(ITest test) Parameters test ITest The test that is going to be run. GetScreenplay() Gets the Screenplay which is to be used for tests contained in the current assembly. public Screenplay GetScreenplay() Returns Screenplay The Screenplay. Exceptions InvalidOperationException If the Screenplay factory used with the constructor to this attribute is invalid or fails to return a non-null Screenplay instance. See Also ScreenplayAttribute"
  },
  "api/CSF.Screenplay.ScreenplayAttribute.html": {
    "href": "api/CSF.Screenplay.ScreenplayAttribute.html",
    "title": "Class ScreenplayAttribute | Screenplay",
    "summary": "Class ScreenplayAttribute Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll Applied to a test method, indicates that decorated test is a Screenplay test. [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class ScreenplayAttribute : Attribute, ITestAction, ITestBuilder Inheritance object Attribute ScreenplayAttribute Implements ITestAction ITestBuilder Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks When a test method is decorated with this attribute then the test corresponding to that method will be executed via Screenplay. This means that the affected test method will be executed as an IPerformance. It also means that all parameters for the method will be provided by resolving them from the current performance's ServiceProvider. See the article on dependency injection in Screenplay for more information about what may be injected into test logic from DI, via the test method parameters. Remember that for this attribute to be effective, the Assembly which contains the test method must be decorated with ScreenplayAssemblyAttribute. If it is not, then the test will fail with an exception. Properties Targets Gets the targets for the attribute (when performing before/after test actions). public ActionTargets Targets { get; } Property Value ActionTargets The targets. Methods AfterTest(ITest) Executed after each test is run public void AfterTest(ITest test) Parameters test ITest The test that has just been run. BeforeTest(ITest) Executed before each test is run public void BeforeTest(ITest test) Parameters test ITest The test that is going to be run. BuildFrom(IMethodInfo, Test) Build one or more TestMethods from the provided MethodInfo. public IEnumerable<TestMethod> BuildFrom(IMethodInfo method, Test suite) Parameters method IMethodInfo The method to be used as a test suite Test The TestSuite to which the method will be added Returns IEnumerable<TestMethod> A TestMethod object See Also ScreenplayAssemblyAttribute"
  },
  "api/CSF.Screenplay.ScreenplayBinding.html": {
    "href": "api/CSF.Screenplay.ScreenplayBinding.html",
    "title": "Class ScreenplayBinding | Screenplay",
    "summary": "Class ScreenplayBinding Namespace CSF.Screenplay Assembly CSF.Screenplay.ReqnrollPlugin.dll Reqnroll binding which uses hooks to coordinate the relevant Screenplay & IPerformance event invokers. [Binding] public class ScreenplayBinding Inheritance object ScreenplayBinding Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ScreenplayBinding(IServiceProvider) Initialises a new instance of ScreenplayBinding. public ScreenplayBinding(IServiceProvider serviceProvider) Parameters serviceProvider IServiceProvider The service provider Exceptions ArgumentNullException If the serviceProvider is null. Methods AfterScenario() Executed after each scenario. [AfterScenario(new string[] { })] public void AfterScenario() AfterTestRun() Executed after a test run. [AfterTestRun] public static void AfterTestRun() BeforeScenario() Executed before each scenario. [BeforeScenario(new string[] { })] public void BeforeScenario() BeforeTestRun() Executed before a test run. [BeforeTestRun] public static void BeforeTestRun()"
  },
  "api/CSF.Screenplay.ScreenplayExtensions.html": {
    "href": "api/CSF.Screenplay.ScreenplayExtensions.html",
    "title": "Class ScreenplayExtensions | Screenplay",
    "summary": "Class ScreenplayExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Extension methods for the Screenplay type. public static class ScreenplayExtensions Inheritance object ScreenplayExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CreateScopedPerformance(Screenplay, IList<IdentifierAndName>, Guid) Creates a new IPerformance, and a new Dependency Injection scope. public static ScopeAndPerformance CreateScopedPerformance(this Screenplay screenplay, IList<IdentifierAndName> namingHierarchy, Guid identity = default) Parameters screenplay Screenplay The Screenplay from which to create the performance namingHierarchy IList<IdentifierAndName> A collection of identifiers and names providing the hierarchical name of this performance; see NamingHierarchy for more information. identity Guid An optional identity to use for this performance; corresponding to PerformanceIdentity. If omitted then a new identity will be generated automatically. Returns ScopeAndPerformance A ScopeAndPerformance containing the newly-created performance as well as the newly-started DI scope. Remarks This method includes the consequence/side-effect of creating a new dependency injection scope from the ServiceProvider associated with the specified Screenplay. That scope will be associated with the created performance and will be returned as part of the return of this method. Please use the Dispose() method the returned object when you are finished with the performance. This ensures that the DI scope and all associated resources (including the performance) will also be properly disposed-of. Exceptions ArgumentNullException If screenplay is null. ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, int) Executes the specified logic as a Performance, synchronously. public static bool? ExecuteAsPerformance(this Screenplay screenplay, Func<IServiceProvider, bool?> performanceLogic, IList<IdentifierAndName> namingHierarchy = null, int timeoutMiliseconds = 0) Parameters screenplay Screenplay The screenplay with which to execute the logic. performanceLogic Func<IServiceProvider, bool?> The logic to be executed by the performance. namingHierarchy IList<IdentifierAndName> An optional naming hierarchy used to identify the performance. timeoutMiliseconds int If set to a non-zero positive value, then the performance logic will be aborted after the specified timeout in milliseconds. Returns bool? The result of the performance. Remarks This method is the primary entry point for beginning a Screenplay Performance. This method begins a new Dependency Injection Scope, and within that scope starts the performance, which executes the specified performance logic: performanceLogic. The return value from the performance logic should conform to the semantics of the parameter value passed to FinishPerformance(bool?). The namingHierarchy may be used to give the performance a name, so that its results (and subsequent report) may be identified. This parameter has the same semantics as NamingHierarchy. Use this method only if ExecuteAsPerformanceAsync(Func<IServiceProvider, CancellationToken, Task<bool?>>, IList<IdentifierAndName>, CancellationToken) is not viable. This method executes the logic asynchronously, as is the architecture of Screenplay, but then uses Wait(CancellationToken) to convert the asynchronous result into a synchronous one. If timeoutMiliseconds is not specified, or specified with a zero value then there will be no timeout applied to the performance's logic. If specified with a positive integer then the performance logic will be aborted if the specified timeout (in milliseconds) is exceeded. Please be aware that - as with Wait(CancellationToken) - if the timeout duration is exceded, the synchronous performance logic is not actually aborted. The thread on which this method is executed will stop waiting for the thread on which the performance logic is running, but the performance logic thread will still continue, typically to completion. All this means is that when the performance logic eventually does complete, its results are discarded because the Screenplay 'gave up waiting' for it. Exceptions ArgumentNullException If either screenplay or performanceLogic is null. ArgumentOutOfRangeException If timeoutMiliseconds is a negative number. See Also ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, CancellationToken) ExecuteAsPerformance(Screenplay, Func<IServiceProvider, bool?>, IList<IdentifierAndName>, CancellationToken) Executes the specified logic as a Performance, synchronously. public static bool? ExecuteAsPerformance(this Screenplay screenplay, Func<IServiceProvider, bool?> performanceLogic, IList<IdentifierAndName> namingHierarchy, CancellationToken cancellationToken) Parameters screenplay Screenplay The screenplay with which to execute the logic. performanceLogic Func<IServiceProvider, bool?> The logic to be executed by the performance. namingHierarchy IList<IdentifierAndName> A naming hierarchy used to identify the performance; if null then an empty name will be used. cancellationToken CancellationToken A cancellation token, which if cancelled will abort waiting for performanceLogic to complete. Returns bool? The result of the performance. Remarks This method is the primary entry point for beginning a Screenplay Performance. This method begins a new Dependency Injection Scope, and within that scope starts the performance, which executes the specified performance logic: performanceLogic. The return value from the performance logic should conform to the semantics of the parameter value passed to FinishPerformance(bool?). The namingHierarchy may be used to give the performance a name, so that its results (and subsequent report) may be identified. This parameter has the same semantics as NamingHierarchy. Use this method only if ExecuteAsPerformanceAsync(Func<IServiceProvider, CancellationToken, Task<bool?>>, IList<IdentifierAndName>, CancellationToken) is not viable. This method executes the logic asynchronously, as is the architecture of Screenplay, but then uses Wait(CancellationToken) to convert the asynchronous result into a synchronous one. If cancellationToken is not specified then no cancellation/abort logic will be applied. If specified, and the token is cancelled, then the Screenplay will abort waiting for the performance logic to complete. Please be aware that - as with Wait(CancellationToken) - if the token is cancelled, the synchronous performance logic is not actually aborted. The thread on which this method is executed will stop waiting for the thread on which the performance logic is running, but the performance logic thread will still continue, typically to completion. All this means is that when the performance logic eventually does complete, its results are discarded because the Screenplay 'gave up waiting' for it. Exceptions ArgumentNullException If either screenplay or performanceLogic is null. ExecuteAsPerformanceAsync<T>(Screenplay, IList<IdentifierAndName>, CancellationToken) Executes the logic with a specified imlpementation of IHostsPerformance as a Performance public static Task<bool?> ExecuteAsPerformanceAsync<T>(this Screenplay screenplay, IList<IdentifierAndName> namingHierarchy = null, CancellationToken cancellationToken = default) where T : IHostsPerformance Parameters screenplay Screenplay The screenplay with which to execute the logic. namingHierarchy IList<IdentifierAndName> An optional naming hierarchy used to identify the performance. cancellationToken CancellationToken An optional cancellation token to abort the performance logic. Returns Task<bool?> A task which completes when the performance's logic has completed, returning the result of the performance. Type Parameters T The concrete type of an implementation of IHostsPerformance which contains the performance logic. Remarks This method is a convenient way to execute performances, where the logic for the performance is contained within a concrete type. This method begins a new Dependency Injection Scope, and within that scope starts the performance. It resolves an instance of the specified T from the DI container, and executes its ExecutePerformanceAsync(CancellationToken) method to get the performance result. An advantage of using this method is that the performance logic is encapsulated within a class, and that the service provider is used to resolve only a single object instance, thus avoiding the service locator anti-pattern. The namingHierarchy may be used to give the performance a name, so that its results (and subsequent report) may be identified. This parameter has the same semantics as NamingHierarchy. Note that if the specified implementation of IHostsPerformance raises a PerformableException then this method will catch that exception and not rethrow. In that case: An event will be raised with the event bus: IHasPerformanceEvents, specifically PerformableFailed. This will contain details of the exception which occurred; subscribers to be informed that the performance has failed. The performance will be immediately terminated and placed into the Failed state. Any other exception, which does not derive from PerformableException, will not be caught by this method and will propagate outward. These exceptions will be interpreted as an error within the Screenplay architecture, since the Actor class will always catch and rethrow any exception encountered from any overload of PerformAsync, wrapped as the inner exception of a PerformableException. Exceptions ArgumentNullException If the screenplay is null. See Also IHostsPerformance GetEventBus(Screenplay) Gets the event bus from the screenplay's service provider. public static IHasPerformanceEvents GetEventBus(this Screenplay screenplay) Parameters screenplay Screenplay The screenplay from which to retrieve the event bus. Returns IHasPerformanceEvents The IHasPerformanceEvents event bus instance. Exceptions ArgumentNullException If screenplay is null."
  },
  "api/CSF.Screenplay.ScreenplayLocator.html": {
    "href": "api/CSF.Screenplay.ScreenplayLocator.html",
    "title": "Class ScreenplayLocator | Screenplay",
    "summary": "Class ScreenplayLocator Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll A small static service locator of sorts, dedicated to getting an appropriate instance of Screenplay for a specified test object. public static class ScreenplayLocator Inheritance object ScreenplayLocator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This type uses reflection to find the ScreenplayAssemblyAttribute which decorates the assembly in which the specified object (a test, a test method or the assembly itself) resides. It additionally caches the results in-memory to avoid repetitive reflection, only to retrieve the same results. Methods GetScopedPerformance(ITest) Gets a DI scope and IPerformance for the specified test. public static ScopeAndPerformance GetScopedPerformance(ITest test) Parameters test ITest An NUnit3 test object. Returns ScopeAndPerformance A DI scope and performance. Remarks This method will return a cached ScopeAndPerformance if one exists for the specified test. If one does not yet exist then a new scope will be created, with an associated performance, and added to the cache. GetScopedPerformance(Guid) Gets a DI scope and IPerformance matching the specified performance identity. public static ScopeAndPerformance GetScopedPerformance(Guid identity) Parameters identity Guid A GUID performance identity, corresponding to PerformanceIdentity. Returns ScopeAndPerformance A DI scope and performance. Remarks Unlike the other overload of this method, this overload will not create a scoped performance if one does not yet exist. If this method is used with a performance identity which is not yet cached, then an exception will be raised. Exceptions ArgumentException If no scope & performance exists in the cache, matching the specified identity GetScreenplay(IMethodInfo) Gets a Screenplay instance from the specified test method. public static Screenplay GetScreenplay(IMethodInfo method) Parameters method IMethodInfo The test method for which to get a Screenplay object. Returns Screenplay The Screenplay object for the specified test method. Remarks This method makes use of the ScreenplayAssemblyAttribute which decorates the assembly in which the specified method was declared, to get a Screenplay object instance applicable to the test method. If the method's assembly is not decorated with the Screenplay assembly attribute then this method will raise an exception. Exceptions ArgumentNullException If method is null. ArgumentException If the method's assembly is null or is not decorated with ScreenplayAssemblyAttribute. GetScreenplay(ITest) Gets a Screenplay instance from the specified test. public static Screenplay GetScreenplay(ITest test) Parameters test ITest The test for which to get a Screenplay object. Returns Screenplay The Screenplay object for the specified test. Remarks This method makes use of the ScreenplayAssemblyAttribute which decorates the assembly in which the specified test's method was declared, to get a Screenplay object instance applicable to the test method. If the test's method's assembly is not decorated with the Screenplay assembly attribute then this method will raise an exception. Exceptions ArgumentNullException If test is null. ArgumentException If the test's method's assembly is null or is not decorated with ScreenplayAssemblyAttribute. GetScreenplay(Assembly) Gets a Screenplay instance from the specified Assembly. public static Screenplay GetScreenplay(Assembly assembly) Parameters assembly Assembly The test assembly for which to get a Screenplay object. Returns Screenplay The Screenplay object for the specified assembly. Remarks This method makes use of the ScreenplayAssemblyAttribute which decorates the assembly to get a Screenplay object instance for that assembly. If the specified assembly is not decorated with the Screenplay assembly attribute then this method will raise an exception. Exceptions ArgumentNullException If assembly is null. ArgumentException If the assembly is not decorated with ScreenplayAssemblyAttribute."
  },
  "api/CSF.Screenplay.ScreenplayOptions.html": {
    "href": "api/CSF.Screenplay.ScreenplayOptions.html",
    "title": "Class ScreenplayOptions | Screenplay",
    "summary": "Class ScreenplayOptions Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Options model which permits the customization/configuration of Screenplay in DI. public sealed class ScreenplayOptions Inheritance object ScreenplayOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Developer note: In an ideal world, this type would be registered into DI via the Options pattern: https://learn.microsoft.com/en-us/dotnet/core/extensions/options. Unfortunately, the BoDi DI container used by Reqnroll (which I wish to support with Screenplay) does not support the appropriate methods/logic to register the neccesary services for Options. This is why this object uses a somewhat homebrew version of options, without making use of the official libraries. Reqnroll is presently investigating replacing the BoDi container, and if it is someday replaced by MSDI, then issue #292 is available to make that switch to the options pattern/ Properties OnBeginScreenplayActions Gets an ordered collection of actions which should be executed when the Screenplay begins, before the first IPerformance starts. public List<Action<IServiceProvider>> OnBeginScreenplayActions { get; } Property Value List<Action<IServiceProvider>> Remarks Each of the actions in this configuration parameter are executed when the BeginScreenplay() method is invoked. By default this collection contains one item. This will initialise an instance of IReporter and subscribe it to the event bus: IHasPerformanceEvents, which will activate Screenplay reporting. You may add further callbacks if you wish, to extend Screenplay; they are executed in the order in which they appear in this collection. OnEndScreenplayActions Gets an ordered collection of actions which should be executed when the Screenplay finished, after the last IPerformance ends. public List<Action<IServiceProvider>> OnEndScreenplayActions { get; } Property Value List<Action<IServiceProvider>> Remarks Each of the actions in this configuration parameter are executed when the CompleteScreenplay() method is invoked. By default this collection contains one item, which disposes of the reporting infrastructure. You may add further callbacks if you wish, to extend Screenplay; they are executed in the order in which they appear in this collection. Be very wary of the use of this property. This is because it is usual for the end of a Screenplay to be triggered by the unloading of the the assemblies in the current process. If the logic triggered by this is nontrivial, it's very likely that it will be terminated early by the ending of the overall process. PerformanceEventsConfig An optional callback/action which exposes the various IHasPerformanceEvents which may be subscribed-to in order to be notified of the progress of a screenplay. public Action<IHasPerformanceEvents> PerformanceEventsConfig { get; set; } Property Value Action<IHasPerformanceEvents> Remarks The implementation of IHasPerformanceEvents is an event publisher which emits notifications when key evens occur during the lifetime of a Screenplay and its performances: IPerformance. If you wish, you may subscribe to these events from your own logic in order to develop new functionality or extend Screenplay. There is no need to add an explicit subscription to any events for the reporting infrastructure. Screenplay will automatically subscribe to this object from the reporting mechanism, unless the value of ReportPath means that reporting is disabled. ReportPath Gets a file system path at which a Screenplay report file will be written. public string ReportPath { get; set; } Property Value string Remarks As a Screenplay executes each IPerformance, it accumulates data relating to those performances, via its reporting mechanism. This information is then written to a JSON-formatted report file, which is saved at the path specified by this property. Once the Screenplay has completed this file may be inspected, converted into a different format and otherwise used to learn-about and diagnose the Screenplay. If this value is set to a relative file path, then it will be relative to the current working directory. If using Screenplay with a software testing integration, then this directory might not be easily determined. The default value for this property is a relative file path in the current working directory, using the filename ScreenplayReport_[timestamp].json where [timestamp] is replaced by the current UTC date & time in a format which is similar to ISO 8601, except that the : characters separating the hours, minutes and second are omitted. This is because they are typically not legal filename characters. A sample of a Screenplay Report filename using this default path is ScreenplayReport_2024-10-04T192345Z.json. If this property is set to null, or an empty/whitespace-only string, or if the path is not writable, then the reporting functionality will be disabled and no report will be written. At runtime, do not read this value directly; instead use an implementation of IGetsReportPath service to get the report path. ValueFormatters Gets a collection of concrete Type which implement IValueFormatter, which will be used to format values which are to appear in Screenplay reports. public IFormatterRegistry ValueFormatters { get; } Property Value IFormatterRegistry Remarks As noted in the documentation for IFormatterRegistry, the types in this collection are considered for use in reverse-collection-order. In other words, they will be tested using CanFormat(object) from last-to-first in this collection. Thus, generalized formatters should be placed at the beginning of this collection, where more specialized formatters should be placed toward the end. Make use of Add(T) to add new formatters to the end of this collection. It comes pre-loaded with three generalised formatters by default, in the following order. ToStringFormatter - a default/fallback implementation which may format any value at all HumanizerFormatter - a formatter for dates, times & time spans which uses the Humanizer library NameFormatter - which formats values that implement IHasName by emitting their name FormattableFormatter - which formats values that implement IFormattableValue There is no need to register/add any types listed in this registry into dependency injection. The methods which accept a configuration action of ScreenplayOptions will iterate through this collection and add every one of the implementation types found as transient-lifetime services in dependency injection."
  },
  "api/CSF.Screenplay.ScreenplayPlugin.html": {
    "href": "api/CSF.Screenplay.ScreenplayPlugin.html",
    "title": "Class ScreenplayPlugin | Screenplay",
    "summary": "Class ScreenplayPlugin Namespace CSF.Screenplay Assembly CSF.Screenplay.ReqnrollPlugin.dll The Screenplay plugin for Reqnroll. public class ScreenplayPlugin : IRuntimePlugin Inheritance object ScreenplayPlugin Implements IRuntimePlugin Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This plugin class is the test framework integration for Reqnroll. Crucially it adds the Screenplay architecture to the Reqnroll architecture. Becuase this plugin leverages the Reqnroll/BoDi IObjectContainer, it is likely incompatible with other plugins which integrate with third party Dependency Injection libraries. This may be easily worked-around, though. If you are using a third-party DI plugin then do not use this plugin. Instead use the AddScreenplay(IServiceCollection) method to add Screenplay to that third-party DI system, when customising the dependency registrations. Adding Screenplay in that way is equivalent to the work done by this plugin. If you wish to further customise the dependency injection, such as adding injectable services for abilities or implementations of IPersona, add them to the relevant DI container. When using Reqnroll's default BoDi container this is described in the following article https://docs.reqnroll.net/latest/automation/context-injection.html#advanced-options. If using a third-party DI container then you should use that container's appropriate mechanism of adding services. Properties Screenplay Provides static access to the Screenplay instance. public static Screenplay Screenplay { get; } Property Value Screenplay Remarks This is required because the bindings for beginning/ending the Screenplay in ScreenplayBinding must be static. Those bindings use the [BeforeTestRun] and [AfterTestRun] hooks, which must be static, as documented here: https://docs.reqnroll.net/latest/automation/hooks.html#supported-hook-attributes Methods Initialize(RuntimePluginEvents, RuntimePluginParameters, UnitTestProviderConfiguration) public void Initialize(RuntimePluginEvents runtimePluginEvents, RuntimePluginParameters runtimePluginParameters, UnitTestProviderConfiguration unitTestProviderConfiguration) Parameters runtimePluginEvents RuntimePluginEvents runtimePluginParameters RuntimePluginParameters unitTestProviderConfiguration UnitTestProviderConfiguration"
  },
  "api/CSF.Screenplay.ScreenplayServiceCollectionExtensions.html": {
    "href": "api/CSF.Screenplay.ScreenplayServiceCollectionExtensions.html",
    "title": "Class ScreenplayServiceCollectionExtensions | Screenplay",
    "summary": "Class ScreenplayServiceCollectionExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.dll Extension methods for IServiceCollection relating to Screenplay. public static class ScreenplayServiceCollectionExtensions Inheritance object ScreenplayServiceCollectionExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddScreenplay(IServiceCollection) Adds the Screenplay framework to the specified service collection. public static IServiceCollection AddScreenplay(this IServiceCollection services) Parameters services IServiceCollection An IServiceCollection Returns IServiceCollection The service collection, so that calls may be chained Remarks Use this method to add Screenplay to an existing service collection; if you just want an instance of Screenplay and do not care for integrating it with a service collection of your own then consider the convenience method Create(Action<IServiceCollection>). Exceptions ArgumentNullException If services is null."
  },
  "api/CSF.Screenplay.Selenium.Actions.ClearCookies.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.ClearCookies.html",
    "title": "Class ClearCookies | Screenplay",
    "summary": "Class ClearCookies Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll An action which clears all browser cookies for the current site/domain. public class ClearCookies : IPerformable, ICanReport Inheritance object ClearCookies Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples using static CSF.Screenplay.Selenium.PerformableBuilder; // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(ClearAllDomainCookies(), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method ClearAllDomainCookies(). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to clear all cookies for the current domain. This is equivalent to a human user entering the browser's settings and doing the same. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also ClearAllDomainCookies()"
  },
  "api/CSF.Screenplay.Selenium.Actions.ClearLocalStorage.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.ClearLocalStorage.html",
    "title": "Class ClearLocalStorage | Screenplay",
    "summary": "Class ClearLocalStorage Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll An action which clears the browser's local storage for the current site. public class ClearLocalStorage : IPerformable, ICanReport Inheritance object ClearLocalStorage Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples using static CSF.Screenplay.Selenium.PerformableBuilder; // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(ClearLocalStorage(), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method ClearLocalStorage(). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to clear the local storage store for the current domain. Note that this operation is not supported first-class by Selenium WebDriver (it is not part of the WebDriver specification). Clearing local storage is implemented by sending the following JavaScript to the web browser via ExecuteJavaScript: localStorage.clear(). Bear this in mind when using this action, as it is not neccesarily identical to a user clearing the storage interactively via the browser's settings. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also ClearLocalStorage()"
  },
  "api/CSF.Screenplay.Selenium.Actions.ClearTheContents.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.ClearTheContents.html",
    "title": "Class ClearTheContents | Screenplay",
    "summary": "Class ClearTheContents Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll A partial Screenplay Action which clears the contents of an HTML element. public class ClearTheContents : ISingleElementPerformable, ICanReportForElement Inheritance object ClearTheContents Implements ISingleElementPerformable ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example clears the contents of the element with ID username. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget username = new ElementId(\"username\", \"the username field\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(ClearTheContentsOf(username), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method ClearTheContentsOf(ITarget). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to clear the contents of the HTML element indicated by the target. The element to be cleared is typically an HTML <input> or <textarea> element. It could be any element which supports Webdriver's Clear() method. For input or textarea elements, this action is equivalent to the user selecting all text and pressing the delete key. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement upon which it shall act. It has this in common with many Screenplay actions & tasks in the Selenium extension which operate upon a single element. These performables derive from ISingleElementPerformable. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableAdapter. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also ClearTheContentsOf(ITarget)"
  },
  "api/CSF.Screenplay.Selenium.Actions.Click.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.Click.html",
    "title": "Class Click | Screenplay",
    "summary": "Class Click Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll A partial Screenplay Action which clicks on an HTML element. public class Click : ISingleElementPerformable, ICanReportForElement Inheritance object Click Implements ISingleElementPerformable ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example clicks on the element with ID buy_now. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget buyNow = new ElementId(\"buy_now\", \"the 'buy now' button\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(ClickOn(buyNow), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method ClickOn(ITarget). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to click on the HTML element indicated by the target. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement upon which it shall act. It has this in common with many Screenplay actions & tasks in the Selenium extension which operate upon a single element. These performables derive from ISingleElementPerformable. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableAdapter. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also ClickOn(ITarget)"
  },
  "api/CSF.Screenplay.Selenium.Actions.DeleteTheCookie.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.DeleteTheCookie.html",
    "title": "Class DeleteTheCookie | Screenplay",
    "summary": "Class DeleteTheCookie Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll An action which deletes a specific browser cookie by name. public class DeleteTheCookie : IPerformable, ICanReport Inheritance object DeleteTheCookie Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples In this example, the action will delete a cookie named \"MyCookieName\". using static CSF.Screenplay.Selenium.PerformableBuilder; // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(DeleteTheCookieNamed(\"MyCookieName\"), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method DeleteTheCookieNamed(string). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to delete the cookie (for the current domain) which has the specified name. This is equivalent to a human user entering the browser's developer tools and doing the same. Constructors DeleteTheCookie(string) Initializes a new instance of the DeleteTheCookie class with the specified cookie name. public DeleteTheCookie(string cookieName) Parameters cookieName string The name of the cookie to delete. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also DeleteTheCookieNamed(string)"
  },
  "api/CSF.Screenplay.Selenium.Actions.DeselectAll.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.DeselectAll.html",
    "title": "Class DeselectAll | Screenplay",
    "summary": "Class DeselectAll Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll A partial Screenplay Action which de-selects every option from an HTML <select> element. public class DeselectAll : ISingleElementPerformable, ICanReportForElement Inheritance object DeselectAll Implements ISingleElementPerformable ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example deselects every option from the element with class optional_extras, which is a descendent of an element with the ID confirm_purchase. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget optionalExtras = new CssSelector(\"#confirm_purchase .optional_extras\", \"the list of optional extras\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(DeselectEverythingFrom(optionalExtras), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method DeselectEverythingFrom(ITarget). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to deselect every option from the HTML element indicated by the target. Use of this action makes sense only for <select> elements which have the multiple attribute. Select elements which do not permit multiple-selection must have precisely one option always selected, which means that this action will not be effective. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement upon which it shall act. It has this in common with many Screenplay actions & tasks in the Selenium extension which operate upon a single element. These performables derive from ISingleElementPerformable. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableAdapter. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also DeselectEverythingFrom(ITarget)"
  },
  "api/CSF.Screenplay.Selenium.Actions.DeselectByIndex.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.DeselectByIndex.html",
    "title": "Class DeselectByIndex | Screenplay",
    "summary": "Class DeselectByIndex Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll A partial Screenplay Action which de-selects an option from an HTML <select> element based upon that option's zero-based index (position). public class DeselectByIndex : ISingleElementPerformable, ICanReportForElement Inheritance object DeselectByIndex Implements ISingleElementPerformable ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example deselects the second option (index 1) from the element with class optional_extras, which is a descendent of an element with the ID confirm_purchase. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget optionalExtras = new CssSelector(\"#confirm_purchase .optional_extras\", \"the list of optional extras\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(DeselectTheOption(1).From(optionalExtras), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method DeselectTheOption(int). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to deselect an option from the HTML element indicated by the target. Use of this action makes sense only for <select> elements which have the multiple attribute. Select elements which do not permit multiple-selection must have precisely one option always selected, which means that this action will not be effective. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement upon which it shall act. It has this in common with many Screenplay actions & tasks in the Selenium extension which operate upon a single element. These performables derive from ISingleElementPerformable. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableAdapter. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Constructors DeselectByIndex(int) Initializes a new instance of the DeselectByIndex class with the specified index. public DeselectByIndex(int index) Parameters index int The zero-based index of the option to deselect. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also DeselectTheOption(int)"
  },
  "api/CSF.Screenplay.Selenium.Actions.DeselectByText.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.DeselectByText.html",
    "title": "Class DeselectByText | Screenplay",
    "summary": "Class DeselectByText Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll A partial Screenplay Action which de-selects an option from an HTML <select> element based upon that option's displayed text. public class DeselectByText : ISingleElementPerformable, ICanReportForElement Inheritance object DeselectByText Implements ISingleElementPerformable ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example deselects the option \"French Fries\" from the element with class optional_extras, which is a descendent of an element with the ID confirm_purchase. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget optionalExtras = new CssSelector(\"#confirm_purchase .optional_extras\", \"the list of optional extras\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(DeselectTheOption(\"French Fries\").From(optionalExtras), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method DeselectTheOption(string). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to deselect an option from the HTML element indicated by the target. Use of this action makes sense only for <select> elements which have the multiple attribute. Select elements which do not permit multiple-selection must have precisely one option always selected, which means that this action will not be effective. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement upon which it shall act. It has this in common with many Screenplay actions & tasks in the Selenium extension which operate upon a single element. These performables derive from ISingleElementPerformable. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableAdapter. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Constructors DeselectByText(string) Initializes a new instance of the DeselectByText class with the specified text. public DeselectByText(string text) Parameters text string The human-readable text of the option to deselect. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also DeselectTheOption(string)"
  },
  "api/CSF.Screenplay.Selenium.Actions.DeselectByValue.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.DeselectByValue.html",
    "title": "Class DeselectByValue | Screenplay",
    "summary": "Class DeselectByValue Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll A partial Screenplay Action which de-selects an option from an HTML <select> element based upon that option's value; the value attribute. public class DeselectByValue : ISingleElementPerformable, ICanReportForElement Inheritance object DeselectByValue Implements ISingleElementPerformable ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example deselects the option with value \"f_fries\" from the element with class optional_extras, which is a descendent of an element with the ID confirm_purchase. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget optionalExtras = new CssSelector(\"#confirm_purchase .optional_extras\", \"the list of optional extras\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(DeselectTheOptionWithValue(\"f_fries\").From(optionalExtras), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method DeselectTheOptionWithValue(string). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to deselect an option from the HTML element indicated by the target. Use of this action makes sense only for <select> elements which have the multiple attribute. Select elements which do not permit multiple-selection must have precisely one option always selected, which means that this action will not be effective. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement upon which it shall act. It has this in common with many Screenplay actions & tasks in the Selenium extension which operate upon a single element. These performables derive from ISingleElementPerformable. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableAdapter. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Constructors DeselectByValue(string) Initializes a new instance of the DeselectByValue class with the specified text. public DeselectByValue(string value) Parameters value string The underlying value of the option to deselect. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also DeselectTheOptionWithValue(string)"
  },
  "api/CSF.Screenplay.Selenium.Actions.ExecuteJavaScript.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.ExecuteJavaScript.html",
    "title": "Class ExecuteJavaScript | Screenplay",
    "summary": "Class ExecuteJavaScript Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll An action which sends a JavaScript string to a web browser and executes it. This action ignores the result (if any) from that script. public class ExecuteJavaScript : IPerformable, ICanReport Inheritance object ExecuteJavaScript Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples In this example, the script will write \"I can count to 5\" into the developer console. using static CSF.Screenplay.Selenium.PerformableBuilder; var iCanCount = new NamedScript<int>(\"console.log('I can count to ' + arguments[0])\", \"my counting script\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(ExecuteAScript(iCanCount, 5), cancellationToken); // ... other performance logic } Remarks The best way to use this action is via the builder method ExecuteAScript(NamedScript) or one of its same-named overloads. The NamedScript class, and its counterparts with generic type parameters, provide a manner in which scripts to be executed by this action may be stored within the application or test logic, providing type safety for their parameters. Performing this action, as an actor which has the BrowseTheWeb ability, sends the body of the script and its parameter values to the web browser and executes it. This is roughly equivalent to a user opening the developer tools Console, typing the script and its parameters there, and pressing enter. This action does not return any result from the script, so it is useful only when the script to execute does not return a result, or when the intent is to ignore the result. If the result is important then use ExecuteJavaScriptAndGetResult<TResult> instead. Within the script body, any parameters are accessible via the arguments object. That object exposes the parameter values by their zero-based index (position) in the parameters list. So, a script which takes three parameters will expose these to the script as arguments[0], arguments[1] and arguments[2], respectively for the first, second and third parameter values. Constructors ExecuteJavaScript(string, string, params object[]) Initialises a new instance of ExecuteJavaScript. public ExecuteJavaScript(string script, string scriptName, params object[] arguments) Parameters script string The JavaScript to be executed. scriptName string A human-readable name for the script, which may be displayed in a Screenplay report. arguments object[] A collection of arguments/parameters to the script. Exceptions ArgumentException If either script or scriptName are null or whitespace-only. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also ExecuteAScript(NamedScript) ExecuteAScript<T1>(NamedScript<T1>, T1) ExecuteAScript<T1, T2>(NamedScript<T1, T2>, T1, T2) ExecuteAScript<T1, T2, T3>(NamedScript<T1, T2, T3>, T1, T2, T3) ExecuteAScript<T1, T2, T3, T4>(NamedScript<T1, T2, T3, T4>, T1, T2, T3, T4) ExecuteAScript<T1, T2, T3, T4, T5>(NamedScript<T1, T2, T3, T4, T5>, T1, T2, T3, T4, T5) ExecuteAScript<T1, T2, T3, T4, T5, T6>(NamedScript<T1, T2, T3, T4, T5, T6>, T1, T2, T3, T4, T5, T6) ExecuteAScript<T1, T2, T3, T4, T5, T6, T7>(NamedScript<T1, T2, T3, T4, T5, T6, T7>, T1, T2, T3, T4, T5, T6, T7) ExecuteJavaScriptAndGetResult<TResult>"
  },
  "api/CSF.Screenplay.Selenium.Actions.ISingleElementPerformable.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.ISingleElementPerformable.html",
    "title": "Interface ISingleElementPerformable | Screenplay",
    "summary": "Interface ISingleElementPerformable Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll An object which is similar to IPerformable but provides access to a Selenium WebDriver and a Selenium element. public interface ISingleElementPerformable : ICanReportForElement Inherited Members ICanReportForElement.GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Remarks This interface is specialised for performables which interact with a single Selenium element. It allows for the provision of some of the boilerplate to set up such a performable. See IPerformable for more information about how this interface would be used in general terms. In order to actually use implementations of this interface as performables, they should be wrapped in an SingleElementPerformableAdapter. Methods PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Selenium.Actions.OpenUrl.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.OpenUrl.html",
    "title": "Class OpenUrl | Screenplay",
    "summary": "Class OpenUrl Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll An action which navigates to a specified URL, as if the user had entered it into the browser address bar. public class OpenUrl : IPerformable, ICanReport Inheritance object OpenUrl Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples In this example, the action will navigate the web browser to https://example.com/myPage. using static CSF.Screenplay.Selenium.PerformableBuilder; var examplePage = new NamedUri(\"https://example.com/myPage\", \"the example web page\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(OpenTheUrl(examplePage), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method OpenTheUrl(NamedUri). The OpenTheUrl builder method does not have a one-to-one relationship with this action, though. The builder method actually returns a Screenplay task named OpenUrlRespectingBase. The purpose of that task is to prepend a base URL to URLs which are relative. This action is capable only of navigating to absolute URLs, and it will raise an exception if the URL is not absolute. Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to navigate to the specified URL. This is performed in the same way as if the user had entered the URL into their web browser address bar and pressed enter. Constructors OpenUrl(NamedUri) Initializes a new instance of the OpenUrl class with the specified URL. public OpenUrl(NamedUri uri) Parameters uri NamedUri The URL to open. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also OpenUrlRespectingBase OpenTheUrl(NamedUri)"
  },
  "api/CSF.Screenplay.Selenium.Actions.SaveScreenshot.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.SaveScreenshot.html",
    "title": "Class SaveScreenshot | Screenplay",
    "summary": "Class SaveScreenshot Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll An action which saves a Selenium Screenshot object to disk as an asset file. public class SaveScreenshot : IPerformable, ICanReport Inheritance object SaveScreenshot Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples In this example, the action will save the screenshot with the name Shopping cart items, using the JPEG file format. Note that because of the internal workings of the GetAssetFilePaths mechanism, the precise file name by which the asset is saved is indeterminate. The precise details of file naming are determined by AssetPathProvider. using OpenQA.Selenium; using static CSF.Screenplay.Selenium.PerformableBuilder; // Retrieved via (for example) the TakeScreenshot question readonly Screenshot screenshot; // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(SaveTheScreenshot(screenshot) .WithTheName(\"Shopping cart items\") .WithTheFormat(ScreenshotImageFormat.Jpeg), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method SaveTheScreenshot(Screenshot). Instead of this action, consider using the task TakeAndSaveScreenshot, via either of the builder methods TakeAndSaveAScreenshot() or TakeAndSaveAScreenshotIfSupported(). Use of this action (standalone) is only required if you wish to examine or interact with the Screenshot object. If all you want to achieve is to take the screenshot and save it, the task is likely to be more convenient. Performing this action with a specified Screenshot object, such as one retrieved via the TakeScreenshot question, saves that Screenshot object to disk as an asset file To perform this action, the actor must have the ability GetAssetFilePaths. If the actor does not have the ability then this action will throw an exception. Constructors SaveScreenshot(Screenshot, string, ScreenshotImageFormat) Initializes a new instance of the SaveScreenshot class. public SaveScreenshot(Screenshot screenshot, string name = null, ScreenshotImageFormat format = ScreenshotImageFormat.Png) Parameters screenshot Screenshot The screenshot to save. name string A human-readable name for the screenshot, which identifies it within the performance. format ScreenshotImageFormat An optional format in which to save the screenshot; if omitted then PNG will be used by default. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also TakeScreenshot TakeAndSaveScreenshot SaveTheScreenshot(Screenshot)"
  },
  "api/CSF.Screenplay.Selenium.Actions.SelectByIndex.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.SelectByIndex.html",
    "title": "Class SelectByIndex | Screenplay",
    "summary": "Class SelectByIndex Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll A partial Screenplay Action which selects an option from an HTML <select> element based upon that option's zero-based index (position). public class SelectByIndex : ISingleElementPerformable, ICanReportForElement Inheritance object SelectByIndex Implements ISingleElementPerformable ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example selects the second option (index 1) from the element with class optional_extras, which is a descendent of an element with the ID confirm_purchase. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget optionalExtras = new CssSelector(\"#confirm_purchase .optional_extras\", \"the list of optional extras\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(SelectTheOption(1).From(optionalExtras), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method SelectTheOption(int). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to select an option from the HTML element indicated by the target. This action has differing behaviour depending whether the <select> element has the multiple attribute or not. For an element which permits multiple-selection, this action adds the chosen option to the option(s) which are already selected. For an element which does not permit multiple-selection, this action replaces the option which is currently selected with the chosen option. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement upon which it shall act. It has this in common with many Screenplay actions & tasks in the Selenium extension which operate upon a single element. These performables derive from ISingleElementPerformable. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableAdapter. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Constructors SelectByIndex(int) Initializes a new instance of the SelectByIndex class with the specified index. public SelectByIndex(int index) Parameters index int The zero-based index of the option to select. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also SelectTheOption(int)"
  },
  "api/CSF.Screenplay.Selenium.Actions.SelectByText.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.SelectByText.html",
    "title": "Class SelectByText | Screenplay",
    "summary": "Class SelectByText Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll A partial Screenplay Action which selects an option from an HTML <select> element based upon that option's displayed text. public class SelectByText : ISingleElementPerformable, ICanReportForElement Inheritance object SelectByText Implements ISingleElementPerformable ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example selects the option \"French Fries\" from the element with class optional_extras, which is a descendent of an element with the ID confirm_purchase. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget optionalExtras = new CssSelector(\"#confirm_purchase .optional_extras\", \"the list of optional extras\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(SelectTheOption(\"French Fries\").From(optionalExtras), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method SelectTheOption(string). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to select an option from the HTML element indicated by the target. This action has differing behaviour depending whether the <select> element has the multiple attribute or not. For an element which permits multiple-selection, this action adds the chosen option to the option(s) which are already selected. For an element which does not permit multiple-selection, this action replaces the option which is currently selected with the chosen option. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement upon which it shall act. It has this in common with many Screenplay actions & tasks in the Selenium extension which operate upon a single element. These performables derive from ISingleElementPerformable. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableAdapter. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Constructors SelectByText(string) Initializes a new instance of the SelectByText class with the specified text. public SelectByText(string text) Parameters text string The human-readable text of the option to select. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also SelectTheOption(string)"
  },
  "api/CSF.Screenplay.Selenium.Actions.SelectByValue.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.SelectByValue.html",
    "title": "Class SelectByValue | Screenplay",
    "summary": "Class SelectByValue Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll A partial Screenplay Action which selects an option from an HTML <select> element based upon that option's value; the value attribute. public class SelectByValue : ISingleElementPerformable, ICanReportForElement Inheritance object SelectByValue Implements ISingleElementPerformable ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example selects the option with value \"f_fries\" from the element with class optional_extras, which is a descendent of an element with the ID confirm_purchase. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget optionalExtras = new CssSelector(\"#confirm_purchase .optional_extras\", \"the list of optional extras\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(SelectTheOptionWithValue(\"f_fries\").From(optionalExtras), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method SelectTheOptionWithValue(string). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to select an option from the HTML element indicated by the target. This action has differing behaviour depending whether the <select> element has the multiple attribute or not. For an element which permits multiple-selection, this action adds the chosen option to the option(s) which are already selected. For an element which does not permit multiple-selection, this action replaces the option which is currently selected with the chosen option. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement upon which it shall act. It has this in common with many Screenplay actions & tasks in the Selenium extension which operate upon a single element. These performables derive from ISingleElementPerformable. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableAdapter. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Constructors SelectByValue(string) Initializes a new instance of the SelectByValue class with the specified text. public SelectByValue(string value) Parameters value string The underlying value of the option to select. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also SelectTheOptionWithValue(string)"
  },
  "api/CSF.Screenplay.Selenium.Actions.SendKeys.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.SendKeys.html",
    "title": "Class SendKeys | Screenplay",
    "summary": "Class SendKeys Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll A partial Screenplay Action which sends keys (enters text) to an HTML element. public class SendKeys : ISingleElementPerformable, ICanReportForElement Inheritance object SendKeys Implements ISingleElementPerformable ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example types \"Jane Doe\" into the element with ID name. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget name = new ElementId(\"name\", \"the name field\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(EnterTheText(\"Jane Doe\").Into(name), cancellationToken); // ... other performance logic } Remarks Use this action via the builder method EnterTheText(params string[]). Performing this action, as an actor which has the BrowseTheWeb ability, instructs the web browser to press the specified keys, essentially entering text into the HTML element indicated by the target. Typically, this action is performed upon an element which supports user-input such as an <input> or <textarea> element. However, it is not limited to these elements; any element may receive key-presses. You may send non-printable or special keys such as Enter or directional arrow key-presses by using Selenium's Keys class. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement upon which it shall act. It has this in common with many Screenplay actions & tasks in the Selenium extension which operate upon a single element. These performables derive from ISingleElementPerformable. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableAdapter. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Constructors SendKeys(string) Initializes a new instance of the SendKeys class with the specified text. public SendKeys(string text) Parameters text string The text to enter into the element. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also EnterTheText(params string[])"
  },
  "api/CSF.Screenplay.Selenium.Actions.SingleElementPerformableAdapter.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.SingleElementPerformableAdapter.html",
    "title": "Class SingleElementPerformableAdapter | Screenplay",
    "summary": "Class SingleElementPerformableAdapter Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll Adapter class which allows a ISingleElementPerformable to be used as an IPerformable. public class SingleElementPerformableAdapter : IPerformable, ICanReport Inheritance object SingleElementPerformableAdapter Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This adapter class is provided as a convenience to perform some of the boilerplate logic required to scaffold the parameters required by ISingleElementPerformable. This method also caches the SeleniumElement which is returned by the ITarget, avoiding the need to fetch it using the WebDriver more than once. As such, instances of this adapter (like all performables) should not be re-used. Constructors SingleElementPerformableAdapter(ISingleElementPerformable, ITarget) Initializes a new instance of the SingleElementPerformableAdapter class with the specified performable and target. public SingleElementPerformableAdapter(ISingleElementPerformable performable, ITarget target) Parameters performable ISingleElementPerformable The performable to be adapted. target ITarget The target element for the performable. Methods From(ISingleElementPerformable, ITarget) Creates a new instance of the SingleElementPerformableAdapter class with the specified performable and target. public static SingleElementPerformableAdapter From(ISingleElementPerformable performable, ITarget target) Parameters performable ISingleElementPerformable The performable to be adapted. target ITarget The target element for the performable. Returns SingleElementPerformableAdapter A new instance of SingleElementPerformableAdapter. GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Selenium.Actions.Wait.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.Wait.html",
    "title": "Class Wait | Screenplay",
    "summary": "Class Wait Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll A Screenplay action which pauses the Performance until either a specified condition is met or a timeout expires, whichever occurs sooner. public class Wait : IPerformable, ICanReport Inheritance object Wait Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples In this example, Screenplay instructs the WebDriver to wait for up to 2 seconds, or until no element with the class loading_spinner is visible on the web page. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget spinner = new ClassName(\"loading_spinner\", \"the loading spinner\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(WaitUntil(spinner.Is().NotVisible().ForAtMost(TimeSpan.FromSeconds(2)), cancellationToken); // ... other performance logic } Remarks Use this action via either the builder method WaitUntil(IBuildsElementPredicates) or WaitUntil(Func<IWebDriver, bool>). The former is preferred over the latter, as it permits the use of a fluent builder syntax to specify the behaviour of the wait. See the documentation of those builder methods to learn more about their use. This action forces the progress of the IPerformance to be delayed whilst the WebDriver waits for a condition to be true. Internally, this action makes use of Selenium's WebDriverWait functionality to implement the waiting logic. Documentation for the WebDriver Wait functionality from the web may be useful if you would like a deeper understanding of this action. This action accepts a number of parameters. The Predicate is the condition for which we are waiting. In other words, we are waiting until the Predicate is true. This is expressed using a WaitUntilPredicate<T>, of bool. See TargetExtensions for extension methods which act as builders for a predicate: Has(ITarget) builds a predicate for a single element whereas AllHave(ITarget) builds a predicate for a collection of elements. The Timeout is the maximum time which this Action will wait. If the Predicate (above) is not true. If the timeout elapses before the Predicate is true then this action will throw WebDriverTimeoutException. In fact, it is the underlying Selenium WebDriver which will throw this exception; this action does not change that. It is impossible to specify an indefinite timeout. The following rules of precedence are used to ensure that the timeout is always set: If a timeout was specified when constructing this instance, that value is used. If the Actor performing this question has the ability UseADefaultWaitTime, then the time specified by WaitTime is used. If neither of the above apply, a default timeout of 5 seconds is used. The Polling Interval controls how often the WebDriver queries the web browser to determine if the Predicate (above) has been fulfilled. Shorter polling intervals can lead to more responsive waits, the Performance is not left waiting longer than it needs. The 'cost' of a shorter polling interval is increased traffic between the Screenplay and the WebDriver. This is particularly relevant when using a Remote WebDriver, as this translates to actual network/Internet traffic and latency. If unspecified, Selenium's default polling interval is used. At the time of writing that is 500 milliseconds. Lastly, the Ignored Exception Types is a collection of Type. Each entry should be a type which derives from Exception which should be silently ignored whilst testing the Predicate (above). This can be useful to ignore errors which are raised because the Predicate isn't true yet, without needing expensive (and performance-impacting) defensive programming. If this collection is specified then these exception types will be caught and silently ignored whilst evaluating the Predicate, treating an exception as \"not true\". Constructors Wait(WaitUntilPredicate<bool>, TimeSpan?, TimeSpan?, ICollection<Type>) Initializes a new instance of the Wait class. public Wait(WaitUntilPredicate<bool> predicate, TimeSpan? timeout, TimeSpan? pollingInterval = null, ICollection<Type> ignoredExceptionTypes = null) Parameters predicate WaitUntilPredicate<bool> The predicate function to evaluate. timeout TimeSpan? An optional maximum amount of time to wait for the condition; the default is determined by the presence of the UseADefaultWaitTime ability. See the documentation of this class for more details. pollingInterval TimeSpan? An optional interval at which to poll the predicate; the Selenium default is 500ms. ignoredExceptionTypes ICollection<Type> An optional collection of types of exceptions to ignore while waiting; the default is an empty collection. Fields DefaultTimeout This default timeout of 5 seconds used when no timeout is specified and the actor has no UseADefaultWaitTime ability. public static readonly TimeSpan DefaultTimeout Field Value TimeSpan Remarks This, along with a few other performables in the Selenium extension for Screenplay involve waiting, with a timeout to prevent waiting indefinitely. If no timeout has been specified then this 5-second timeout is used as a fall-back default. This may be overridden by granting the Actor the ability UseADefaultWaitTime, with a different timeout specified. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also WaitUntil(IBuildsElementPredicates) WaitUntil(Func<IWebDriver, bool>) UseADefaultWaitTime"
  },
  "api/CSF.Screenplay.Selenium.Actions.WaitForSomeTime.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.WaitForSomeTime.html",
    "title": "Class WaitForSomeTime | Screenplay",
    "summary": "Class WaitForSomeTime Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll A Screenplay action which pauses the performance for a specified amount of time. public class WaitForSomeTime : IPerformable, ICanReport Inheritance object WaitForSomeTime Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples In this example, Screenplay waits for 3 seconds. using static CSF.Screenplay.Selenium.PerformableBuilder; // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(WaitFor(TimeSpan.FromSeconds(3), cancellationToken); // ... other performance logic } Remarks Create instances of this action via the builder method WaitFor(TimeSpan). This wait action inserts an arbitrary pause into the progress of the IPerformance. For most kinds of waiting scenario, consider using Wait instead of this action. This kind of wait will always wait for the full time, wheras a Wait is configured with a condition/Predicate. Once that condition is true it stops waiting and the performance is resumed. Constructors WaitForSomeTime(TimeSpan) Initializes a new instance of the WaitForSomeTime class. public WaitForSomeTime(TimeSpan duration) Parameters duration TimeSpan The amount of time to wait. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also WaitFor(TimeSpan)"
  },
  "api/CSF.Screenplay.Selenium.Actions.WaitUntilPredicate-1.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.WaitUntilPredicate-1.html",
    "title": "Class WaitUntilPredicate<T> | Screenplay",
    "summary": "Class WaitUntilPredicate<T> Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll Represents a predicate that can be used to wait until a condition is true. public class WaitUntilPredicate<T> : IHasName Type Parameters T Inheritance object WaitUntilPredicate<T> Implements IHasName Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors WaitUntilPredicate(Func<IWebDriver, T>, string) Initializes a new instance of the WaitUntilPredicate<T> class. public WaitUntilPredicate(Func<IWebDriver, T> predicate, string name = null) Parameters predicate Func<IWebDriver, T> The predicate function to evaluate. name string An optional name for the predicate. Exceptions ArgumentException Thrown if the result type of the predicate is a value type other than boolean. Properties Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Predicate Gets the predicate function to evaluate. public Func<IWebDriver, T> Predicate { get; } Property Value Func<IWebDriver, T>"
  },
  "api/CSF.Screenplay.Selenium.Actions.WaitUntilPredicate.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.WaitUntilPredicate.html",
    "title": "Class WaitUntilPredicate | Screenplay",
    "summary": "Class WaitUntilPredicate Namespace CSF.Screenplay.Selenium.Actions Assembly CSF.Screenplay.Selenium.dll Provides methods to create wait predicates for Selenium WebDriver. public static class WaitUntilPredicate Inheritance object WaitUntilPredicate Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods From<T>(Func<IWebDriver, T>, string) Creates a WaitUntilPredicate<T> from a given predicate function. public static WaitUntilPredicate<T> From<T>(Func<IWebDriver, T> predicate, string name = null) Parameters predicate Func<IWebDriver, T> The predicate function to evaluate. name string An optional name for the predicate. Returns WaitUntilPredicate<T> A new instance of WaitUntilPredicate. Type Parameters T The result type of the predicate function. Exceptions ArgumentException Thrown if the result type of the predicate is a value type other than boolean."
  },
  "api/CSF.Screenplay.Selenium.Actions.html": {
    "href": "api/CSF.Screenplay.Selenium.Actions.html",
    "title": "Namespace CSF.Screenplay.Selenium.Actions | Screenplay",
    "summary": "Namespace CSF.Screenplay.Selenium.Actions Classes ClearCookies An action which clears all browser cookies for the current site/domain. ClearLocalStorage An action which clears the browser's local storage for the current site. ClearTheContents A partial Screenplay Action which clears the contents of an HTML element. Click A partial Screenplay Action which clicks on an HTML element. DeleteTheCookie An action which deletes a specific browser cookie by name. DeselectAll A partial Screenplay Action which de-selects every option from an HTML <select> element. DeselectByIndex A partial Screenplay Action which de-selects an option from an HTML <select> element based upon that option's zero-based index (position). DeselectByText A partial Screenplay Action which de-selects an option from an HTML <select> element based upon that option's displayed text. DeselectByValue A partial Screenplay Action which de-selects an option from an HTML <select> element based upon that option's value; the value attribute. ExecuteJavaScript An action which sends a JavaScript string to a web browser and executes it. This action ignores the result (if any) from that script. OpenUrl An action which navigates to a specified URL, as if the user had entered it into the browser address bar. SaveScreenshot An action which saves a Selenium Screenshot object to disk as an asset file. SelectByIndex A partial Screenplay Action which selects an option from an HTML <select> element based upon that option's zero-based index (position). SelectByText A partial Screenplay Action which selects an option from an HTML <select> element based upon that option's displayed text. SelectByValue A partial Screenplay Action which selects an option from an HTML <select> element based upon that option's value; the value attribute. SendKeys A partial Screenplay Action which sends keys (enters text) to an HTML element. SingleElementPerformableAdapter Adapter class which allows a ISingleElementPerformable to be used as an IPerformable. Wait A Screenplay action which pauses the Performance until either a specified condition is met or a timeout expires, whichever occurs sooner. WaitForSomeTime A Screenplay action which pauses the performance for a specified amount of time. WaitUntilPredicate Provides methods to create wait predicates for Selenium WebDriver. WaitUntilPredicate<T> Represents a predicate that can be used to wait until a condition is true. Interfaces ISingleElementPerformable An object which is similar to IPerformable but provides access to a Selenium WebDriver and a Selenium element."
  },
  "api/CSF.Screenplay.Selenium.ActorExtensions.html": {
    "href": "api/CSF.Screenplay.Selenium.ActorExtensions.html",
    "title": "Class ActorExtensions | Screenplay",
    "summary": "Class ActorExtensions Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll Extension methods for actors. public static class ActorExtensions Inheritance object ActorExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetLazyElement(ICanPerform, ITarget) Gets a lazy-loaded SeleniumElement instance matching the specified target. public static Lazy<SeleniumElement> GetLazyElement(this ICanPerform actor, ITarget target) Parameters actor ICanPerform An actor, who must have the BrowseTheWeb ability. target ITarget A target which describes an HTML element Returns Lazy<SeleniumElement> A lazy SeleniumElement, the value of which is the HTML element described by the target. Exceptions ArgumentNullException If the actor is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor does not have the BrowseTheWeb ability TargetNotFoundException If the target does not yield an HTML element GetLazyElements(ICanPerform, ITarget) Gets a lazy-loaded SeleniumElementCollection instance matching the specified target. public static Lazy<SeleniumElementCollection> GetLazyElements(this ICanPerform actor, ITarget target) Parameters actor ICanPerform An actor, who must have the BrowseTheWeb ability. target ITarget A target which describes a collection of HTML elements Returns Lazy<SeleniumElementCollection> A lazy SeleniumElementCollection, the value of which is the collection of HTML elements described by the target. Exceptions ArgumentNullException If the actor is null ArgumentException If the actor does not implement IHasAbilities InvalidOperationException If the actor does not have the BrowseTheWeb ability"
  },
  "api/CSF.Screenplay.Selenium.BrowseTheWeb.html": {
    "href": "api/CSF.Screenplay.Selenium.BrowseTheWeb.html",
    "title": "Class BrowseTheWeb | Screenplay",
    "summary": "Class BrowseTheWeb Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll Screenplay ability which allows an Actor to browse the web using a Selenium WebDriver. public class BrowseTheWeb : ICanReport, IDisposable Inheritance object BrowseTheWeb Implements ICanReport IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods BrowseTheWebExtensions.GetJavaScriptExecutor(BrowseTheWeb) Examples Imagine you have configuration like the following in your appsettings.json, following the Microsoft Options Pattern, with a configuration file. { \"WebDriverFactory\": { \"DriverConfigurations\": { \"LocalChrome\": { \"DriverType\": \"ChromeDriver\" }, \"LocalFirefox\": { \"DriverType\": \"FirefoxDriver\" }, }, } } You could now use the following technique when you configure your Actor with this ability. The following example shows how to do this using an IPersona. In addition to the configuration above and the persona shown below, run this code whilst an environment variable named WebDriverFactory__SelectedConfiguration is defined and set to LocalFirefox. This environment variable selects which of the two configured WebDrivers is used (in this case, Firefox). Developers may use the configuration to store a library of available WebDriver configurations, and use a single environment variable to switch between them at execution time. using CSF.Extensions.WebDriver; using CSF.Screenplay.Selenium; public class Webster(IGetsWebDriver webDriverFactory) : IPersona { public string Name => \"Webster\"; public Actor GetActor(Guid performanceIdentity) { var webster = new Actor(Name, performanceIdentity); var browseTheWeb = new BrowseTheWeb(webDriverFactory); webster.IsAbleTo(browseTheWeb); return webster; } } Remarks The 'Browse the Web' ability wraps a Selenium WebDriver and provides access to it via the WebDriver property. It also provide access to the options which were used to create the web driver, via the DriverOptions property. Following Selenium's architecture, both of these properties are abstract/interfaces and offer only the base/lowest common denominator types. Often, this is sufficient. Developers may check for other Selenium-related interfaces if they are required, using patterns such as the following: if(browseTheWeb.WebDriver is OpenQA.Selenium.ISupportsPrint printingDriver) /* ... exercise printingDriver ... */ This ability makes use of the Universal Web Driver Factory from the CSF.Extensions.WebDriver package. This provides a configurable manner, using the .NET Options pattern, to specify the WebDriver without hard-coding the choice. The Selenium Extension to Screenplay makes the IGetsWebDriver web driver factory available via dependency injection. The recommended way in which to grant an Actor this ability is via an IPersona. The web driver factory may be safely constructor-injected into the persona class. Constructors BrowseTheWeb(IGetsWebDriver, string) Initializes a new instance of the BrowseTheWeb class. public BrowseTheWeb(IGetsWebDriver webDriverFactory, string webDriverName = null) Parameters webDriverFactory IGetsWebDriver A universal WebDriver factory instance webDriverName string An optional name, specifying the WebDriver configuration (within those available in the factory) to use. Remarks It is quite normal to omit the webDriverName parameter, leaving it with its default null value. If the WebDriver name is omitted or null then the GetDefaultWebDriver(Action<DriverOptions>) method will be used to get the WebDriver. This requires that the WebDriver factory is configured with a default driver. This could be done via the SelectedConfiguration property of the JSON configuration, or via an environment variable (see the example code in the remarks to this class) or any other way which the Microsoft Configuration Pattern supports. Alternatively, to activate a specific named configuration, you may specify the WebDriver name here. It is normal to retrieve the webDriverFactory parameter via Dependency Injection. The Selenium Extension to Screenplay makes the factory available in that manner. Properties DriverOptions Gets the WebDriver options which were used to create WebDriver. public DriverOptions DriverOptions { get; } Property Value DriverOptions Remarks These options are for reference only; there is no effect on the WebDriver instance if you modify them. The purpose of this property is to allow developers to inspect the options which were used to create the WebDriver. WebDriver Gets the Selenium WebDriver associated with the current ability instance. public IWebDriver WebDriver { get; } Property Value IWebDriver Methods Dispose() public void Dispose() Dispose(bool) Disposes the resources used by the BrowseTheWeb class. protected virtual void Dispose(bool disposing) Parameters disposing bool A boolean value indicating whether the method is called from the Dispose method. GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. See Also IWebDriver WebDriverAndOptions IGetsWebDriver"
  },
  "api/CSF.Screenplay.Selenium.BrowseTheWebExtensions.html": {
    "href": "api/CSF.Screenplay.Selenium.BrowseTheWebExtensions.html",
    "title": "Class BrowseTheWebExtensions | Screenplay",
    "summary": "Class BrowseTheWebExtensions Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll Extension methods for the BrowseTheWeb ability. public static class BrowseTheWebExtensions Inheritance object BrowseTheWebExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetJavaScriptExecutor(BrowseTheWeb) Gets a JavaScript executor object based upon the current WebDriver. public static IJavaScriptExecutor GetJavaScriptExecutor(this BrowseTheWeb ability) Parameters ability BrowseTheWeb Returns IJavaScriptExecutor A JavaScript executor object Exceptions NotSupportedException If the current web driver does not support JavaScript execution."
  },
  "api/CSF.Screenplay.Selenium.BrowserQuirks.html": {
    "href": "api/CSF.Screenplay.Selenium.BrowserQuirks.html",
    "title": "Class BrowserQuirks | Screenplay",
    "summary": "Class BrowserQuirks Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll Static class which holds known browser quirks information. public static class BrowserQuirks Inheritance object BrowserQuirks Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Quirks are a feature of the universal WebDriver factory. See the WebDriver quirks article for more information. Fields CannotSetInputTypeDateWithSendKeys Gets the name of a browser quirk, for browsers which cannot set the value of an <input type=\"date\"> using the \"Send Keys\" technique. public static readonly string CannotSetInputTypeDateWithSendKeys Field Value string Remarks Some WebDriver implementations permit typing a locale-formatted date string into the HTML element, as if it were any other <input> element. Other WebDriver implementations cannot interact with Date inputs in that way and can only enter a new value via a JavaScript workaround. This quirk marks browsers which require such a workaround. The calendar UI which most browsers will render for a Date input field is not built from HTML elements and thus cannot be interacted with by a WebDriver. Thus, if we cannot 'type' a new date and cannot interact by clicking on the calendar, all that remains is to use a JavaScript workaround to set the date. See Also EnterTheDate NeedsToWaitAfterPageLoad Gets the name of a browser quirk, for browsers which must be instructed to wait after navigating to a new web page, until that new page has finished loading. public static readonly string NeedsToWaitAfterPageLoad Field Value string Remarks In traditional (non-SPA) web page navigation, there is a brief delay after clicking a hyperlink which navigates to a new web page. That delay is the time for the 'incoming' web page to load and render. During that delay, the 'outgoing' web page is still visible on-screen. Most WebDriver implementations, those without this quirk, automatically wait during that loading delay. They do not execute further WebDriver commands until the 'incoming' web page has finished loading and is displayed on the screen. This prevents unexpected results and NoSuchElementException being thrown, and similar. Browsers/WebDrivers which are affected by this quirk (at the time of writing, all versions of Apple Safari) do not wait during this loading delay. This means that unless they are explicitly instructed to wait, they can attempt to execute further WebDriver commands prematurely. The task ClickAndWaitForDocumentReady analyses the WebDriver for the presence of this quirk. If the quirk is present then the task inserts wait logic, to work around this behaviour of the affected Browser/WebDriver. This allows Selenium/Screenplay logic to be written in a manner that behaves consistently cross-browser. It is important to remember that this behaviour and quirk applies only to traditional web browser navigation. That is a sequence in which the outgoing page is fully unloaded and the incoming page is retrieved and loaded from the webserver. It does not apply to navigating through Single Page Applications. See Also ClickAndWaitForDocumentReady Methods GetQuirksData() Gets hard-coded information about known browser quirks. public static QuirksData GetQuirksData() Returns QuirksData Quirks data, about the peculiarities of specific browsers. Remarks This information ships with CSF.Screenplay.Selenium. It may be overridden by user-supplied configuration, should things change in the future. See the WebDriver quirks reference material for more information. See Also QuirksData IHasQuirks"
  },
  "api/CSF.Screenplay.Selenium.Builders.ClickBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.ClickBuilder.html",
    "title": "Class ClickBuilder | Screenplay",
    "summary": "Class ClickBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll Builder for creating click actions on a target element. public class ClickBuilder : IGetsPerformable Inheritance object ClickBuilder Implements IGetsPerformable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ClickBuilder(ITarget) Initializes a new instance of the ClickBuilder class with the specified target. public ClickBuilder(ITarget target) Parameters target ITarget The target element to click. Cannot be null. Exceptions ArgumentNullException Thrown when target is null. Methods AndWaitForANewPageToLoad(TimeSpan?) Gets a more sophisticated IPerformable which waits for a page-load to complete after clicking. public IPerformable AndWaitForANewPageToLoad(TimeSpan? forAtMost = null) Parameters forAtMost TimeSpan? Returns IPerformable A performable Remarks Use this method when the click is expected to cause a new web page to load into the browser. In that case, the performable returned by this method will not only click on the target element. See the ClickAndWaitForDocumentReady task for more information. Note that the meaning of \"a new page loading\" is a full Web Browser page load (an entirely new HTML document). It does not mean an SPA/JavaScript-based navigation. This method is not for JavaScrpit/SPA navigation. GetPerformable() Gets the performable object from the current instance. public IPerformable GetPerformable() Returns IPerformable A performable object"
  },
  "api/CSF.Screenplay.Selenium.Builders.EnterTheDateBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.EnterTheDateBuilder.html",
    "title": "Class EnterTheDateBuilder | Screenplay",
    "summary": "Class EnterTheDateBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll A builder type which creates an instance of EnterTheDate. public class EnterTheDateBuilder : IGetsPerformable Inheritance object EnterTheDateBuilder Implements IGetsPerformable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors EnterTheDateBuilder(DateTime?) Initializes a new instance of the EnterTheDateBuilder class with the specified date. public EnterTheDateBuilder(DateTime? date) Parameters date DateTime? The date to enter, or null Methods ForTheCultureNamed(string) Specifies the culture for which to enter the date. This must be the culture in which the web browser is operating. public EnterTheDateBuilder ForTheCultureNamed(string cultureIdentifier) Parameters cultureIdentifier string A culture identifier string Returns EnterTheDateBuilder This same builder, so calls may be chained Examples For example, a British English browser en-GB expects dates to be entered in the format ddMMyyyy. However, a US English browser en-US expects dates to be entered in the format MMddyyyy. The cultureIdentifier parameter of this method must be the culture identifier of the culture which the browser is operating under, such as en-GB. Remarks Web browser are culture-aware applications and they will render the input/display value of a date field using the culture in which their operating system is configured. This impacts the manner in which users input dates. If this method is not used, the task returned by this builder will use the culture of the operating system/environment that is executing the Screenplay Performance. This is usually OK when running the web browser locally, but it might not match the browser's culture when using remote web browsers. Exceptions ArgumentNullException If cultureIdentifier is null CultureNotFoundException If cultureIdentifier indicates a culture which is not found GetPerformable() Gets the performable object from the current instance. public IPerformable GetPerformable() Returns IPerformable A performable object Into(ITarget) Specifies the target element into which to enter the date. This must be an <input type=\"date\"> element. public EnterTheDateBuilder Into(ITarget target) Parameters target ITarget The target element Returns EnterTheDateBuilder This same builder, so calls may be chained Exceptions ArgumentNullException If target is null InvalidOperationException If this method is used more than once"
  },
  "api/CSF.Screenplay.Selenium.Builders.ExecuteJavaScriptBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.ExecuteJavaScriptBuilder.html",
    "title": "Class ExecuteJavaScriptBuilder | Screenplay",
    "summary": "Class ExecuteJavaScriptBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll A builder type for executing JavaScript in the browser which is not expected to return a result value. public class ExecuteJavaScriptBuilder : ExecuteJavaScriptBuilderBase, IGetsPerformable Inheritance object ExecuteJavaScriptBuilderBase ExecuteJavaScriptBuilder Implements IGetsPerformable Inherited Members ExecuteJavaScriptBuilderBase.ScriptBody ExecuteJavaScriptBuilderBase.Name ExecuteJavaScriptBuilderBase.Arguments object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ExecuteJavaScriptBuilder(string) Initialises a new instance of ExecuteJavaScriptBuilder. public ExecuteJavaScriptBuilder(string scriptBody) Parameters scriptBody string The body of the JavaScript to be executed. Exceptions ArgumentException If scriptBody is null or a whitepace-only string Methods WithTheArguments(params object[]) Sets the arguments (parameters) for the script. public ExecuteJavaScriptBuilder WithTheArguments(params object[] arguments) Parameters arguments object[] A collection of parameter values Returns ExecuteJavaScriptBuilder This same builder object, so calls may be chained Remarks This method is optional; if the script requires no parameters then it is unneccesary to use this method. Exceptions InvalidOperationException If the arguments have already been set WithTheName(string) Sets a human-readable name for the script, which may be displayed in Screenplay reports. public ExecuteJavaScriptBuilder WithTheName(string name) Parameters name string The human-readable name for the script Returns ExecuteJavaScriptBuilder This same builder object, so calls may be chained Exceptions ArgumentException If the name is null or a whitepace-only string InvalidOperationException If the name has already been set"
  },
  "api/CSF.Screenplay.Selenium.Builders.ExecuteJavaScriptBuilderBase.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.ExecuteJavaScriptBuilderBase.html",
    "title": "Class ExecuteJavaScriptBuilderBase | Screenplay",
    "summary": "Class ExecuteJavaScriptBuilderBase Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll Base type for a builder which facilitates the execution of JavaScript in the web browser. public abstract class ExecuteJavaScriptBuilderBase Inheritance object ExecuteJavaScriptBuilderBase Derived ExecuteJavaScriptBuilder ExecuteJavaScriptBuilderWithResult<TResult> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ExecuteJavaScriptBuilderBase(string) Initialises a new instance of this builder. protected ExecuteJavaScriptBuilderBase(string scriptBody) Parameters scriptBody string The body of the JavaScript to be executed. Exceptions ArgumentException If scriptBody is null or a whitepace-only string Properties Arguments Gets a collection of the arguments to be provided to the script. protected object[] Arguments { get; } Property Value object[] Name Gets the human-readable name of the script. protected string Name { get; } Property Value string ScriptBody Gets the body of the script to be executed. protected string ScriptBody { get; } Property Value string Methods WithTheArguments(params object[]) Sets the arguments (parameters) for the script. public ExecuteJavaScriptBuilderBase WithTheArguments(params object[] arguments) Parameters arguments object[] A collection of parameter values Returns ExecuteJavaScriptBuilderBase This same builder object, so calls may be chained Remarks This method is optional; if the script requires no parameters then it is unneccesary to use this method. Exceptions InvalidOperationException If the arguments have already been set WithTheName(string) Sets a human-readable name for the script, which may be displayed in Screenplay reports. public ExecuteJavaScriptBuilderBase WithTheName(string name) Parameters name string The human-readable name for the script Returns ExecuteJavaScriptBuilderBase This same builder object, so calls may be chained Exceptions ArgumentException If the name is null or a whitepace-only string InvalidOperationException If the name has already been set"
  },
  "api/CSF.Screenplay.Selenium.Builders.ExecuteJavaScriptBuilderWithResult-1.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.ExecuteJavaScriptBuilderWithResult-1.html",
    "title": "Class ExecuteJavaScriptBuilderWithResult<TResult> | Screenplay",
    "summary": "Class ExecuteJavaScriptBuilderWithResult<TResult> Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll A builder type for executing JavaScript in the browser, where the script is expected to return a result value. public class ExecuteJavaScriptBuilderWithResult<TResult> : ExecuteJavaScriptBuilderBase, IGetsPerformableWithResult<TResult> Type Parameters TResult Inheritance object ExecuteJavaScriptBuilderBase ExecuteJavaScriptBuilderWithResult<TResult> Implements IGetsPerformableWithResult<TResult> Inherited Members ExecuteJavaScriptBuilderBase.ScriptBody ExecuteJavaScriptBuilderBase.Name ExecuteJavaScriptBuilderBase.Arguments object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ExecuteJavaScriptBuilderWithResult(string) Initialises a new instance of ExecuteJavaScriptBuilderWithResult<TResult>. public ExecuteJavaScriptBuilderWithResult(string scriptBody) Parameters scriptBody string The body of the JavaScript to be executed. Exceptions ArgumentException If scriptBody is null or a whitepace-only string Methods WithTheArguments(params object[]) Sets the arguments (parameters) for the script. public ExecuteJavaScriptBuilderWithResult<TResult> WithTheArguments(params object[] arguments) Parameters arguments object[] A collection of parameter values Returns ExecuteJavaScriptBuilderWithResult<TResult> This same builder object, so calls may be chained Remarks This method is optional; if the script requires no parameters then it is unneccesary to use this method. Exceptions InvalidOperationException If the arguments have already been set WithTheName(string) Sets a human-readable name for the script, which may be displayed in Screenplay reports. public ExecuteJavaScriptBuilderWithResult<TResult> WithTheName(string name) Parameters name string The human-readable name for the script Returns ExecuteJavaScriptBuilderWithResult<TResult> This same builder object, so calls may be chained Exceptions ArgumentException If the name is null or a whitepace-only string InvalidOperationException If the name has already been set"
  },
  "api/CSF.Screenplay.Selenium.Builders.FilterElementsBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.FilterElementsBuilder.html",
    "title": "Class FilterElementsBuilder | Screenplay",
    "summary": "Class FilterElementsBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll A builder class for filtering Selenium elements based on a specification. public class FilterElementsBuilder Inheritance object FilterElementsBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples Here is a sample usage which combines both the QueryPredicatePrototypeBuilder and FilterElementsBuilder classes: using static CSF.Screenplay.Selenium.PerformableBuilder; var buyNowButtons = await actor.PerformAsync(Filter(someElements).ForThoseWhich(have => have.Clickability(true).And(have.Text(\"Buy now\")), cancellationToken); The code sample above assumes that actor is an instance of ICanPerform, that someElements is a collection of SeleniumElement instances, and that cancellationToken is a CancellationToken instance. It would filter the elements in someElements to only those which are clickable and have the text \"Buy now\". Constructors FilterElementsBuilder(SeleniumElementCollection) Initializes a new instance of the FilterElementsBuilder class. public FilterElementsBuilder(SeleniumElementCollection elements) Parameters elements SeleniumElementCollection The collection of Selenium elements to be filtered. Methods ForThoseWhich(ISpecificationFunction<SeleniumElement>) Specifies the specification which will be used to filter the collection of elements. public NamedFilterElementsBuilder ForThoseWhich(ISpecificationFunction<SeleniumElement> specification) Parameters specification ISpecificationFunction<SeleniumElement> The specification function to filter elements. Returns NamedFilterElementsBuilder A builder which permits naming the filtered elements. Remarks Consider using the QueryPredicatePrototypeBuilder class to create the specification function which is passed to this method. Do this via the other overload to this method.. ForThoseWhich(Func<QueryPredicatePrototypeBuilder, IBuildsElementPredicates>) Specifies the specification which will be used to filter the collection of elements. public NamedFilterElementsBuilder ForThoseWhich(Func<QueryPredicatePrototypeBuilder, IBuildsElementPredicates> predicatePrototype) Parameters predicatePrototype Func<QueryPredicatePrototypeBuilder, IBuildsElementPredicates> A lambda function which builds a predicate prototype from a fluent interface. Returns NamedFilterElementsBuilder A builder which permits naming the filtered elements. Examples Here is a sample usage which combines both the QueryPredicatePrototypeBuilder and FilterElementsBuilder classes: using static CSF.Screenplay.Selenium.PerformableBuilder; var buyNowButtons = await actor.PerformAsync(Filter(someElements).ForThoseWhich(have => have.Clickability(true).And(have.Text(\"Buy now\")), cancellationToken); The code sample above assumes that actor is an instance of ICanPerform, that someElements is a collection of SeleniumElement instances, and that cancellationToken is a CancellationToken instance. It would filter the elements in someElements to only those which are clickable and have the text \"Buy now\". Remarks This overload uses the QueryPredicatePrototypeBuilder class to create the specification function which is passed to this method. See Also QueryPredicatePrototypeBuilder Filter(SeleniumElementCollection)"
  },
  "api/CSF.Screenplay.Selenium.Builders.FindElementBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.FindElementBuilder.html",
    "title": "Class FindElementBuilder | Screenplay",
    "summary": "Class FindElementBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll A builder class for finding a single element within a specified target. public class FindElementBuilder : IGetsPerformableWithResult<SeleniumElement> Inheritance object FindElementBuilder Implements IGetsPerformableWithResult<SeleniumElement> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This builder offers two methods to configure the finding of elements: WhichMatches(Locator) - Specify a Locator which should be used to filter for the element. AndNameIt(string) - Specify a human-readable name for the element which is found. Constructors FindElementBuilder(ITarget) Initializes a new instance of the FindElementsBuilder class with the specified target. public FindElementBuilder(ITarget target) Parameters target ITarget The target within which elements will be found. Methods AndNameIt(string) Specifies a human-readable name for the collection of elements which are found. public FindElementBuilder AndNameIt(string name) Parameters name string The name for the collection of elements. Returns FindElementBuilder The current instance of FindElementsBuilder. WhichMatches(Locator) Specifies a Locator which should be used to filter the elements which are found. public FindElementBuilder WhichMatches(Locator locator) Parameters locator Locator The locator to filter the elements. Returns FindElementBuilder The current instance of FindElementsBuilder. Operators implicit operator SingleElementPerformableWithResultAdapter<SeleniumElement>(FindElementBuilder) Converts a FindElementsBuilder to a SingleElementPerformableWithResultAdapter<TResult>. public static implicit operator SingleElementPerformableWithResultAdapter<SeleniumElement>(FindElementBuilder builder) Parameters builder FindElementBuilder The FindElementBuilder instance to convert. Returns SingleElementPerformableWithResultAdapter<SeleniumElement> A SingleElementPerformableWithResultAdapter<TResult> instance."
  },
  "api/CSF.Screenplay.Selenium.Builders.FindElementsBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.FindElementsBuilder.html",
    "title": "Class FindElementsBuilder | Screenplay",
    "summary": "Class FindElementsBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll A builder class for finding a collection of elements within a specified target. public class FindElementsBuilder : IGetsPerformableWithResult<SeleniumElementCollection> Inheritance object FindElementsBuilder Implements IGetsPerformableWithResult<SeleniumElementCollection> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This builder offers two methods to configure the finding of elements: WhichMatch(Locator) - Specify a Locator which should be used to filter the elements which are found. AndNameThem(string) - Specify a human-readable name for the collection of elements which are found. Constructors FindElementsBuilder(ITarget) Initializes a new instance of the FindElementsBuilder class with the specified target. public FindElementsBuilder(ITarget target) Parameters target ITarget The target within which elements will be found. Methods AndNameThem(string) Specifies a human-readable name for the collection of elements which are found. public FindElementsBuilder AndNameThem(string name) Parameters name string The name for the collection of elements. Returns FindElementsBuilder The current instance of FindElementsBuilder. WhichMatch(Locator) Specifies a Locator which should be used to filter the elements which are found. public FindElementsBuilder WhichMatch(Locator locator) Parameters locator Locator The locator to filter the elements. Returns FindElementsBuilder The current instance of FindElementsBuilder. Operators implicit operator SingleElementPerformableWithResultAdapter<SeleniumElementCollection>(FindElementsBuilder) Converts a FindElementsBuilder to a SingleElementPerformableWithResultAdapter<TResult>. public static implicit operator SingleElementPerformableWithResultAdapter<SeleniumElementCollection>(FindElementsBuilder builder) Parameters builder FindElementsBuilder The FindElementsBuilder instance to convert. Returns SingleElementPerformableWithResultAdapter<SeleniumElementCollection> A SingleElementPerformableWithResultAdapter<TResult> instance."
  },
  "api/CSF.Screenplay.Selenium.Builders.FromTargetActionBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.FromTargetActionBuilder.html",
    "title": "Class FromTargetActionBuilder | Screenplay",
    "summary": "Class FromTargetActionBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll A builder class for creating performable actions which act upon a specified target element. public class FromTargetActionBuilder Inheritance object FromTargetActionBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods From(ITarget) Creates a performable action from the specified target. public IPerformable From(ITarget target) Parameters target ITarget The target element. Returns IPerformable A performable action."
  },
  "api/CSF.Screenplay.Selenium.Builders.IBuildsElementPredicates.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.IBuildsElementPredicates.html",
    "title": "Interface IBuildsElementPredicates | Screenplay",
    "summary": "Interface IBuildsElementPredicates Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll An object which may be converted into either a WaitUntilPredicate<T> or an CSF.Specifications.ISpecificationFunction<T>. public interface IBuildsElementPredicates Methods GetElementSpecification() Gets a specification function which may be used to filter Selenium elements. ISpecificationFunction<SeleniumElement> GetElementSpecification() Returns ISpecificationFunction<SeleniumElement> A specification function for Selenium elements GetWaitUntilPredicate() Gets a WaitUntilPredicate<T> which may be used to configure a WaitUntilPredicate<T>. WaitUntilPredicate<bool> GetWaitUntilPredicate() Returns WaitUntilPredicate<bool> A wait-until predicate object Exceptions InvalidOperationException If this instance has not been initialised in a manner compatible with creating Web Driver predicates"
  },
  "api/CSF.Screenplay.Selenium.Builders.NamedFilterElementsBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.NamedFilterElementsBuilder.html",
    "title": "Class NamedFilterElementsBuilder | Screenplay",
    "summary": "Class NamedFilterElementsBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll A builder class which permits specifying an optional name for the collection of elements which match an element filter. public class NamedFilterElementsBuilder : IGetsPerformableWithResult<SeleniumElementCollection> Inheritance object NamedFilterElementsBuilder Implements IGetsPerformableWithResult<SeleniumElementCollection> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NamedFilterElementsBuilder(SeleniumElementCollection, ISpecificationFunction<SeleniumElement>) Initializes a new instance of the NamedFilterElementsBuilder class. public NamedFilterElementsBuilder(SeleniumElementCollection elements, ISpecificationFunction<SeleniumElement> specification) Parameters elements SeleniumElementCollection The elements to filter specification ISpecificationFunction<SeleniumElement> The specification by which to filter the elements Exceptions ArgumentNullException If any parameter is null. Methods AndNameThem(string) Specifies a human-readable name for the collection of elements which are found matching the specification. public IPerformableWithResult<SeleniumElementCollection> AndNameThem(string resultsName) Parameters resultsName string A short, descriptive, human-readable name for the collection of matching elements. Returns IPerformableWithResult<SeleniumElementCollection> A performable question Exceptions ArgumentNullException If resultsName is null. Operators implicit operator FilterElements(NamedFilterElementsBuilder) Converts a NamedFilterElementsBuilder to a FilterElements question. public static implicit operator FilterElements(NamedFilterElementsBuilder builder) Parameters builder NamedFilterElementsBuilder The builder to convert. Returns FilterElements Remarks This conversion is only used when the AndNameThem(string) function is not used (the name is not specified)."
  },
  "api/CSF.Screenplay.Selenium.Builders.NamedWaitBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.NamedWaitBuilder.html",
    "title": "Class NamedWaitBuilder | Screenplay",
    "summary": "Class NamedWaitBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll Provides a builder for configuring wait actions in Selenium. public class NamedWaitBuilder : IGetsPerformable Inheritance object NamedWaitBuilder Implements IGetsPerformable Derived UnnamedWaitBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class provides methods for configuring various aspects of a wait action, such as timeout, polling interval, and ignored exception types. Using this class directly requires that a WaitUntilPredicate instance is provided to the constructor. The specified predicate provides both the logic to evaluate and a human-readable name for the wait condition. Constructors NamedWaitBuilder() Initializes a new instance of the NamedWaitBuilder class. protected NamedWaitBuilder() Remarks This constructor is protected, as it is only to be used by derived classes which provide an alternative implementation of GetWaitUntilPredicate(). NamedWaitBuilder(WaitUntilPredicate<bool>) Initializes a new instance of the NamedWaitBuilder class. public NamedWaitBuilder(WaitUntilPredicate<bool> predicate) Parameters predicate WaitUntilPredicate<bool> The predicate which ends the wait when it returns a successful result. Properties IgnoredExceptionTypes Gets or sets the collection of exception types which will be ignored when evaluating the wait predicate. protected ICollection<Type> IgnoredExceptionTypes { get; set; } Property Value ICollection<Type> PollingInterval Gets or sets the interval at which Selenium will poll to determine if the predicate to end the wait has been met. protected TimeSpan? PollingInterval { get; set; } Property Value TimeSpan? Remarks If this property is null, then Selenium provides a default polling interval of 500ms. Timeout Gets or sets the maximum timeout for the wait action. protected TimeSpan? Timeout { get; set; } Property Value TimeSpan? Methods ForAtMost(TimeSpan) Configures the wait action to use a specified maximum timeout. public NamedWaitBuilder ForAtMost(TimeSpan timeout) Parameters timeout TimeSpan The maximum amount of time to wait. Returns NamedWaitBuilder The same wait builder, so that calls may be chained. Remarks If the timeout is reached before the predicate function returns a true result then the wait will end, and an exception will be raised. This method is optional. If it is not called then the default behaviour of the Wait question will be used. See the documentation for that class for more details. GetWaitUntilPredicate() Gets the wait-until predicate, which wraps both the predicate logic and a human-readable name. protected virtual WaitUntilPredicate<bool> GetWaitUntilPredicate() Returns WaitUntilPredicate<bool> The wait-until predicate instance. IgnoringTheseExceptionTypes(params Type[]) Configures the wait action which will be created to ignore exceptions of the specified types. public NamedWaitBuilder IgnoringTheseExceptionTypes(params Type[] ignoredExceptionTypes) Parameters ignoredExceptionTypes Type[] A collection of exception types to be ignored when polling the predicate function. Returns NamedWaitBuilder Remarks When evaluating the predicate/condition function, the WebDriver may throw exceptions, such as if an element doesn't exist. Use this method to specify a collection of exception types which should be ignored. If an exception thrown of one of these types then the WebDriver wait will treat it the same as a false outcome and continue to poll the predicate. This method is optional. If it is not called then by default, only exceptions of type TargetNotFoundException will be ignored. That is - waiting will continue if the target element does not yet exist. If you choose to replace this collection with your own, be sure to include the type TargetNotFoundException if you wish to retain that behaviour. Exceptions InvalidOperationException Thrown if the ignored exception types have already been set. WithPollingInterval(TimeSpan) Configures the wait action which will be created to use a specified polling interval. public NamedWaitBuilder WithPollingInterval(TimeSpan pollingInterval) Parameters pollingInterval TimeSpan The polling interval to use. Returns NamedWaitBuilder The same wait builder, so that calls may be chained. Remarks The polling interval is the amount of time that the WebDriver will wait between each evaluation of the predicate function. This method is optional. If it is not called then Screenplay will not specify a polling interval. Selenium will then use its own default interval, which is 500ms. Choosing a polling interval is a balance between responsiveness and resource usage. A shorter polling interval may lead to quicker detection of the condition being met (a more responsive predicate), but at the cost of increased network usage as more round-trips are made to the WebDriver. Conversely, a longer polling interval reduces network traffic but may result in a less responsive predicate. If you are not sure what to choose, it's recommended not to use this method; use the default provided by Selenium. Exceptions InvalidOperationException Thrown if the polling interval has already been set."
  },
  "api/CSF.Screenplay.Selenium.Builders.QueryPredicatePrototype-1.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.QueryPredicatePrototype-1.html",
    "title": "Class QueryPredicatePrototype<TQueryable> | Screenplay",
    "summary": "Class QueryPredicatePrototype<TQueryable> Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll A prototype object which may be converted into either a WaitUntilPredicate<T> or an CSF.Specifications.ISpecificationFunction<T>. public sealed class QueryPredicatePrototype<TQueryable> : IBuildsElementPredicates Type Parameters TQueryable The type of value which is returned by Query. Inheritance object QueryPredicatePrototype<TQueryable> Implements IBuildsElementPredicates Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Wait-until predicates and element specifications are conceptually quite similar. Both represent predicates for Selenium elements in one form or another. Becuase of this similarity, it is useful to use just one builder, which is capable of producing either form. This class represents the intermediate form which may be converted into either a wait-until predicate or an element specification. Constructors QueryPredicatePrototype(ISpecificationFunction<TQueryable>, IQuery<TQueryable>, ITarget, Func<ITarget, string>, bool) Initialises a new instance of the QueryPredicatePrototype<TQueryable> class in a manner suitable for using either GetElementSpecification() or GetWaitUntilPredicate(). public QueryPredicatePrototype(ISpecificationFunction<TQueryable> specification, IQuery<TQueryable> query, ITarget target, Func<ITarget, string> summaryCreator, bool multiElement = false) Parameters specification ISpecificationFunction<TQueryable> The specification function for the value returned by the query query IQuery<TQueryable> A query which retrieves a value from a Selenium element target ITarget The target element or elements summaryCreator Func<ITarget, string> A function which creates a summary string for this predicate multiElement bool If true, then the target is expected to be a collection of elements Exceptions ArgumentNullException If any nullable parameter is null Properties MultiElement Gets a value indicating whether this predicate is intended to operate upon multiple elements. public bool MultiElement { get; } Property Value bool Query Gets the query which will be used to obtain value(s) from the target element(s). public IQuery<TQueryable> Query { get; } Property Value IQuery<TQueryable> Specification Gets a specification function which will be evaluated against the value(s) produced by the Query. public ISpecificationFunction<TQueryable> Specification { get; } Property Value ISpecificationFunction<TQueryable> SummaryCreator Gets a function which will create a human-readable summary for this predicate, as would appear in Screenplay reports. public Func<ITarget, string> SummaryCreator { get; } Property Value Func<ITarget, string> Target Gets the target, which represents one or more Selenium elements upon which this predicate will operate. public ITarget Target { get; } Property Value ITarget Methods GetElementSpecification() Gets a specification function which may be used to filter Selenium elements. public ISpecificationFunction<SeleniumElement> GetElementSpecification() Returns ISpecificationFunction<SeleniumElement> A specification function for Selenium elements GetSummary() Gets a human-readable summary for this predicate, as would appear in Screenplay reports. public string GetSummary() Returns string A string summary GetWaitUntilPredicate() Gets a WaitUntilPredicate<T> which may be used to configure a WaitUntilPredicate<T>. public WaitUntilPredicate<bool> GetWaitUntilPredicate() Returns WaitUntilPredicate<bool> A wait-until predicate object Exceptions InvalidOperationException If this instance has not been initialised in a manner compatible with creating Web Driver predicates GetWebDriverPredicate() Gets a Func<T, TResult> which may be used to evaluate this predicate against a web driver. public Func<IWebDriver, bool> GetWebDriverPredicate() Returns Func<IWebDriver, bool> A predicate function Exceptions InvalidOperationException If this instance has not been initialised in a manner compatible with creating Web Driver predicates"
  },
  "api/CSF.Screenplay.Selenium.Builders.QueryPredicatePrototypeBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.QueryPredicatePrototypeBuilder.html",
    "title": "Class QueryPredicatePrototypeBuilder | Screenplay",
    "summary": "Class QueryPredicatePrototypeBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll Provides methods to build WebDriver predicate functions for a target element. public class QueryPredicatePrototypeBuilder Inheritance object QueryPredicatePrototypeBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This first example shows how a Wait action may be written, to wait until the text of a status display reads \"finished\". Note the section .Has.Text(\"finished\"), which demonstrates use of the functionality of this class. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget status = new CssSelector(\"#footer .status\", \"the status display\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(WaitUntil(status.Has().Text(\"finished\"), cancellationToken); // ... other performance logic } The second example, below, shows the usage of FilterElements, matching only elements which are larger than 5050 pixels in both dimensions. Imagine a bubble chart, in which we are looking for bubbles larger than a certain size. Note the section .ForThoseWhich(q => q.Size(s => s.Height > 50 && s.Width > 50)), which demonstrates use of the functionality of this class. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget bubbles = new CssSelector(\".bubble_chart .bubble\", \"the items in the bubble chart\"); // Within the logic of a custom task, deriving from IPerformableWithResult<SeleniumElementCollection> public async ValueTask<SeleniumElementCollection> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic var allBubbles = await actor.PerformAsync(FindElementsOnThePage().WhichMatch(bubbles), cancellationToken); var largeBubbles = await actor.PerformAsync(Filter(allBubbles) .ForThoseWhich(q => q.Size(s => s.Height > 50 && s.Width > 50)), cancellationToken); // ... other performance logic } Remarks Predicates, built by the members of this class, are primarily used for two purposes: The Wait action, to specify the condition under which the wait should end. The FilterElements question, to specify the criteria by which to match elements. For more information about interrogating the state of targets, see Queries; queries are the foundation upon which this predicate functionality is based. Constructors QueryPredicatePrototypeBuilder(ITarget, bool) Initializes a new instance of the QueryPredicatePrototypeBuilder class for creating instances of QueryPredicatePrototype<TQueryable> which are suitable for use as either WaitUntilPredicate<T> or CSF.Specifications.ISpecificationFunction<T>. public QueryPredicatePrototypeBuilder(ITarget target, bool multiElement) Parameters target ITarget The target element for the queries. multiElement bool If set to true then this builder will get a predicate which works for targets which represent a collection of HTML elements; otherwise it will get a predicate for a single HTML element. Methods AllClasses(params string[]) Creates a query predicate for the presence of all the specified HTML classes (amongst the class attribute's values). public QueryPredicatePrototype<string> AllClasses(params string[] classes) Parameters classes string[] The names of the classes to query. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks The underlying implementation of this method makes use of the GetAttribute method of Selenium's IWebElement type to query the current attribute value. The get-attribute behaviour queries the corresponding DOM property of the element first, before querying the HTML attribute. Thus, if the DOM has been updated since the element was rendered onto the page, the current live value of the element will be used. Selenium's get-attribute functionality also has special handling for certain attributes such as class & readonly. When inspecting the DOM properties, these names are transparently normalised to className and readOnly respectively. Finally, 'boolean' attribute values are returned with either the string true if present or null if not. This method inspects the class attribute and determines whether every one of the specified classes are present in the element's class list. Attribute(string) Creates a query predicate for the presence of a specified HTML attribute. public QueryPredicatePrototype<string> Attribute(string attributeName) Parameters attributeName string The name of the attribute to query. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks The underlying implementation of this method makes use of the GetAttribute method of Selenium's IWebElement type to query the current attribute value. The get-attribute behaviour queries the corresponding DOM property of the element first, before querying the HTML attribute. Thus, if the DOM has been updated since the element was rendered onto the page, the current live value of the element will be used. Selenium's get-attribute functionality also has special handling for certain attributes such as class & readonly. When inspecting the DOM properties, these names are transparently normalised to className and readOnly respectively. Finally, 'boolean' attribute values are returned with either the string true if present or null if not. This method specifically targets that last behaviour, described above. It verifies that the response for attribute's value is not null. AttributeValue(string, Func<string, bool>) Creates a query predicate based on a specified HTML attribute and a predicate for the attribute's value. public QueryPredicatePrototype<string> AttributeValue(string attributeName, Func<string, bool> predicate) Parameters attributeName string The name of the attribute to query. predicate Func<string, bool> The predicate to apply to the attribute value. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks The underlying implementation of this method makes use of the GetAttribute method of Selenium's IWebElement type to query the current attribute value. The get-attribute behaviour queries the corresponding DOM property of the element first, before querying the HTML attribute. Thus, if the DOM has been updated since the element was rendered onto the page, the current live value of the element will be used. Selenium's get-attribute functionality also has special handling for certain attributes such as class & readonly. When inspecting the DOM properties, these names are transparently normalised to className and readOnly respectively. Finally, 'boolean' attribute values are returned with either the string true if present or null if not. Note that the last behaviour, described above, means that this method may be used to match elements which do not have the specified attribute, by using a predicate which checks for null. AttributeValue(string, string) Creates a query predicate for the presence of a specified HTML attribute, with a specified value. public QueryPredicatePrototype<string> AttributeValue(string attributeName, string value) Parameters attributeName string The name of the attribute to query. value string The value of the attribute to query. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks The underlying implementation of this method makes use of the GetAttribute method of Selenium's IWebElement type to query the current attribute value. The get-attribute behaviour queries the corresponding DOM property of the element first, before querying the HTML attribute. Thus, if the DOM has been updated since the element was rendered onto the page, the current live value of the element will be used. Selenium's get-attribute functionality also has special handling for certain attributes such as class & readonly. When inspecting the DOM properties, these names are transparently normalised to className and readOnly respectively. Finally, 'boolean' attribute values are returned with either the string true if present or null if not. Note that the last behaviour, described above, means that this method may be used to match elements which do not have the specified attribute, by using null as the desired value. Class(string) Creates a query predicate for the presence of a specified HTML class (amongst the class attribute's values). public QueryPredicatePrototype<string> Class(string @class) Parameters class string The name of the class to query. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks The underlying implementation of this method makes use of the GetAttribute method of Selenium's IWebElement type to query the current attribute value. The get-attribute behaviour queries the corresponding DOM property of the element first, before querying the HTML attribute. Thus, if the DOM has been updated since the element was rendered onto the page, the current live value of the element will be used. Selenium's get-attribute functionality also has special handling for certain attributes such as class & readonly. When inspecting the DOM properties, these names are transparently normalised to className and readOnly respectively. Finally, 'boolean' attribute values are returned with either the string true if present or null if not. This method inspects the class attribute and determines whether the specified class is present amongst the element's class list. Clickability(bool) Creates a query predicate based on whether the element is clickable. public QueryPredicatePrototype<bool> Clickability(bool value) Parameters value bool The value to compare against the element's \"clickability\". Returns QueryPredicatePrototype<bool> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks An element is considered 'clickable' if it is both visible in the web browser and it is not disabled. Clickability(Func<bool, bool>) Creates a query predicate based on the element's clickability. public QueryPredicatePrototype<bool> Clickability(Func<bool, bool> predicate) Parameters predicate Func<bool, bool> The predicate to apply to the element's \"clickability\". Returns QueryPredicatePrototype<bool> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks An element is considered 'clickable' if it is both visible in the web browser and it is not disabled. Clickable() Creates a query predicate for only clickable elements. public QueryPredicatePrototype<bool> Clickable() Returns QueryPredicatePrototype<bool> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks An element is considered 'clickable' if it is both visible in the web browser and it is not disabled. CssProperty(string, Func<string, bool>) Creates a query predicate based on a specified CSS property and a predicate for the property's value. public QueryPredicatePrototype<string> CssProperty(string propertyName, Func<string, bool> predicate) Parameters propertyName string The name of the property to query. predicate Func<string, bool> The predicate to apply to the property value. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks Note that this is not limited to reading the styling of an element/elements as it was defined in a stylesheet. It reads the live styling of the element as it is when the question executes. Thus, if JavaScript or a class change has altered the styling of the element since it was first rendered on-screen, its up-to-date styling information will be inspected. CssProperty(string, string) Creates a query predicate based on a specified CSS property and a desired value for that property. public QueryPredicatePrototype<string> CssProperty(string propertyName, string value) Parameters propertyName string The name of the property to query. value string The value to compare against the property value. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks Note that this is not limited to reading the styling of an element/elements as it was defined in a stylesheet. It reads the live styling of the element as it is when the question executes. Thus, if JavaScript or a class change has altered the styling of the element since it was first rendered on-screen, its up-to-date styling information will be inspected. Location(Point) Creates a query predicate based on the element's location (its top-left corner). public QueryPredicatePrototype<Point> Location(Point value) Parameters value Point The value to compare against the element's location. Returns QueryPredicatePrototype<Point> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Location(Func<Point, bool>) Creates a query predicate based on the element's location (its top-left corner). public QueryPredicatePrototype<Point> Location(Func<Point, bool> predicate) Parameters predicate Func<Point, bool> The predicate to apply to the element's location. Returns QueryPredicatePrototype<Point> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. NotClass(string) Creates a query predicate for the absence of a specified HTML class (amongst the class attribute's values). public QueryPredicatePrototype<string> NotClass(string @class) Parameters class string The name of the class to query. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks The underlying implementation of this method makes use of the GetAttribute method of Selenium's IWebElement type to query the current attribute value. The get-attribute behaviour queries the corresponding DOM property of the element first, before querying the HTML attribute. Thus, if the DOM has been updated since the element was rendered onto the page, the current live value of the element will be used. Selenium's get-attribute functionality also has special handling for certain attributes such as class & readonly. When inspecting the DOM properties, these names are transparently normalised to className and readOnly respectively. Finally, 'boolean' attribute values are returned with either the string true if present or null if not. This method inspects the class attribute and determines whether the specified class is not present amongst the element's class list. NotClickable() Creates a query predicate for only elements which are not clickable. public QueryPredicatePrototype<bool> NotClickable() Returns QueryPredicatePrototype<bool> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks An element is considered 'clickable' if it is both visible in the web browser and it is not disabled. NotVisible() Creates a query predicate for elements that are not visible. public QueryPredicatePrototype<bool> NotVisible() Returns QueryPredicatePrototype<bool> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Options(Func<IReadOnlyList<Option>, bool>) Creates a query predicate based on the <option> elements, which are children of the current element, regardless of their selected state. public QueryPredicatePrototype<IReadOnlyList<Option>> Options(Func<IReadOnlyList<Option>, bool> predicate) Parameters predicate Func<IReadOnlyList<Option>, bool> The predicate to apply to the element's options. Returns QueryPredicatePrototype<IReadOnlyList<Option>> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. OptionsWithText(params string[]) Creates a query predicate based on the <option> elements, which are children of the current element, regardless of their selected state. public QueryPredicatePrototype<IReadOnlyList<Option>> OptionsWithText(params string[] optionTexts) Parameters optionTexts string[] The display text of the options to match against. Returns QueryPredicatePrototype<IReadOnlyList<Option>> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks This specification will match the element if its options are precisely those specified by optionTexts. The order of the options does not matter, but they must match exactly. This method identifies the options by their display text. OptionsWithValue(params string[]) Creates a query predicate based on the <option> elements, which are children of the current element, regardless of their selected state. public QueryPredicatePrototype<IReadOnlyList<Option>> OptionsWithValue(params string[] optionValues) Parameters optionValues string[] The DOM values of the options to match against. Returns QueryPredicatePrototype<IReadOnlyList<Option>> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks This specification will match the element if its options are precisely those specified by optionValues. The order of the options does not matter, but they must match exactly. This method identifies the options by their DOM value. SelectedOptions(Func<IReadOnlyList<Option>, bool>) Creates a query predicate based on the <option> elements, which are children of the current element, which are selected. public QueryPredicatePrototype<IReadOnlyList<Option>> SelectedOptions(Func<IReadOnlyList<Option>, bool> predicate) Parameters predicate Func<IReadOnlyList<Option>, bool> The predicate to apply to the element's selected options. Returns QueryPredicatePrototype<IReadOnlyList<Option>> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. SelectedOptionsWithText(params string[]) Creates a query predicate based on the <option> elements, which are children of the current element, which are selected. public QueryPredicatePrototype<IReadOnlyList<Option>> SelectedOptionsWithText(params string[] optionTexts) Parameters optionTexts string[] The display text of the options to match against. Returns QueryPredicatePrototype<IReadOnlyList<Option>> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks This specification will match the element if its selected options are precisely those specified by optionTexts. The order of the options does not matter, but they must match exactly. This method identifies the options by their display text. SelectedOptionsWithValue(params string[]) Creates a query predicate based on the <option> elements, which are children of the current element, which are selected. public QueryPredicatePrototype<IReadOnlyList<Option>> SelectedOptionsWithValue(params string[] optionValues) Parameters optionValues string[] The DOM values of the options to match against. Returns QueryPredicatePrototype<IReadOnlyList<Option>> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks This specification will match the element if its selected options are precisely those specified by optionValues. The order of the options does not matter, but they must match exactly. This method identifies the options by their DOM value. Size(Size) Creates a query predicate based on the element's size (width & height in pixels). public QueryPredicatePrototype<Size> Size(Size value) Parameters value Size The value to compare against the element's size. Returns QueryPredicatePrototype<Size> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Size(Func<Size, bool>) Creates a query predicate based on the element's size (width & height in pixels). public QueryPredicatePrototype<Size> Size(Func<Size, bool> predicate) Parameters predicate Func<Size, bool> The predicate to apply to the element's size. Returns QueryPredicatePrototype<Size> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Text(Func<string, bool>) Creates a query predicate based on the element's text content. public QueryPredicatePrototype<string> Text(Func<string, bool> predicate) Parameters predicate Func<string, bool> The predicate to apply to the element's text. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks When reading text from the web browser, this predicate will trim leading/trailing whitespace from that text before comparing it. This is because some browsers (Safari) include whitespace at the beginning/end of text read from the browser, which isn't visible to the end user. This is typically the space which is inherent in the markup, but which browsers ignore when actually displaying content. By trimming whitespace, the Selenium extension for Screenplay ensures that behaviour is consistent cross-browser. If this causes an issue and you would like the leading/trailing whitespace included the use TextWithoutTrimmingWhitespace(string) instead. Text(string) Creates a query predicate based on the element's text content. public QueryPredicatePrototype<string> Text(string value) Parameters value string The value to compare against the element's text. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks When reading text from the web browser, this predicate will trim leading/trailing whitespace from that text before comparing it. This is because some browsers (Safari) include whitespace at the beginning/end of text read from the browser, which isn't visible to the end user. This is typically the space which is inherent in the markup, but which browsers ignore when actually displaying content. By trimming whitespace, the Selenium extension for Screenplay ensures that behaviour is consistent cross-browser. If this causes an issue and you would like the leading/trailing whitespace included the use TextWithoutTrimmingWhitespace(string) instead. TextWithoutTrimmingWhitespace(Func<string, bool>) Creates a query predicate based on the element's text content. public QueryPredicatePrototype<string> TextWithoutTrimmingWhitespace(Func<string, bool> predicate) Parameters predicate Func<string, bool> The predicate to apply to the element's text. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks When reading text from the web browser, this predicate will preserve any leading/trailing whitespace in the text without trimming it. Be aware that some browsers (Safari) may include leading/trailing whitespace when reading text, which other WebDriver implementations do not. This can result in inconsistent results when operating cross-browser. If cross-browser consistency is important then consider using Text(Func<string, bool>) instead. TextWithoutTrimmingWhitespace(string) Creates a query predicate based on the element's text content, without trimming leading/trailing whitespace. public QueryPredicatePrototype<string> TextWithoutTrimmingWhitespace(string value) Parameters value string The value to compare against the element's text. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks When reading text from the web browser, this predicate will preserve any leading/trailing whitespace in the text without trimming it. Be aware that some browsers (Safari) may include leading/trailing whitespace when reading text, which other WebDriver implementations do not. This can result in inconsistent results when operating cross-browser. If cross-browser consistency is important then consider using Text(string) instead. UnselectedOptions(Func<IReadOnlyList<Option>, bool>) Creates a query predicate based on the <option> elements, which are children of the current element, which are not selected. public QueryPredicatePrototype<IReadOnlyList<Option>> UnselectedOptions(Func<IReadOnlyList<Option>, bool> predicate) Parameters predicate Func<IReadOnlyList<Option>, bool> The predicate to apply to the element's unselected options. Returns QueryPredicatePrototype<IReadOnlyList<Option>> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. UnselectedOptionsWithText(params string[]) Creates a query predicate based on the <option> elements, which are children of the current element, which are not selected. public QueryPredicatePrototype<IReadOnlyList<Option>> UnselectedOptionsWithText(params string[] optionTexts) Parameters optionTexts string[] The display text of the options to match against. Returns QueryPredicatePrototype<IReadOnlyList<Option>> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks This specification will match the element if its unselected options are precisely those specified by optionTexts. The order of the options does not matter, but they must match exactly. This method identifies the options by their display text. UnselectedOptionsWithValue(params string[]) Creates a query predicate based on the <option> elements, which are children of the current element, which are not selected. public QueryPredicatePrototype<IReadOnlyList<Option>> UnselectedOptionsWithValue(params string[] optionValues) Parameters optionValues string[] The DOM values of the options to match against. Returns QueryPredicatePrototype<IReadOnlyList<Option>> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Remarks This specification will match the element if its unselected options are precisely those specified by optionValues. The order of the options does not matter, but they must match exactly. This method identifies the options by their DOM value. Value(Func<string, bool>) Creates a query predicate based on the element's DOM value. public QueryPredicatePrototype<string> Value(Func<string, bool> predicate) Parameters predicate Func<string, bool> The predicate to apply to the element's DOM value. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Value(string) Creates a query predicate based on the element's DOM value. public QueryPredicatePrototype<string> Value(string value) Parameters value string The value to compare against the element's DOM value. Returns QueryPredicatePrototype<string> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Visibility(bool) Creates a query predicate based on whether the element is visible. public QueryPredicatePrototype<bool> Visibility(bool value) Parameters value bool The value to compare against the element's visibility. Returns QueryPredicatePrototype<bool> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Visibility(Func<bool, bool>) Creates a query predicate based on whether the element is visible. public QueryPredicatePrototype<bool> Visibility(Func<bool, bool> predicate) Parameters predicate Func<bool, bool> The predicate to apply to the element's visibility. Returns QueryPredicatePrototype<bool> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. Visible() Creates a query predicate for elements that are visible. public QueryPredicatePrototype<bool> Visible() Returns QueryPredicatePrototype<bool> A QueryPredicatePrototype<TQueryable>, which may be converted to a full predicate. Examples See the remarks for the class QueryPredicatePrototypeBuilder for two examples of usage. The methods of this type all follow the same broad pattern to create predicates. See Also Wait FilterElements AllHave(ITarget) AreAll(ITarget) Has(ITarget) Is(ITarget) ForThoseWhich(Func<QueryPredicatePrototypeBuilder, IBuildsElementPredicates>)"
  },
  "api/CSF.Screenplay.Selenium.Builders.QuestionMultiQueryBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.QuestionMultiQueryBuilder.html",
    "title": "Class QuestionMultiQueryBuilder | Screenplay",
    "summary": "Class QuestionMultiQueryBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll Provides methods to build performable questions for a collection of Selenium elements, which are based upon querying/interrogating values from those elements. public class QuestionMultiQueryBuilder Inheritance object QuestionMultiQueryBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors QuestionMultiQueryBuilder(ITarget) Initializes a new instance of the QuestionMultiQueryBuilder class with the specified Selenium elements. public QuestionMultiQueryBuilder(ITarget elements) Parameters elements ITarget The Selenium elements to be used by the query builder. Methods AllOptions() Gets a performable question which reads all of the available options (whether selected or not) from a collection of <select> elements. public IPerformableWithResult<IReadOnlyList<IReadOnlyList<Option>>> AllOptions() Returns IPerformableWithResult<IReadOnlyList<IReadOnlyList<Option>>> A performable question Remarks This question is only valid for <select> elements. For any other type of element, the behaviour is undefined. Attribute(string) Gets a performable question which reads the value of the specified attribute from the elements. public IPerformableWithResult<IReadOnlyList<string>> Attribute(string attributeName) Parameters attributeName string The name of the attribute from which to read the value Returns IPerformableWithResult<IReadOnlyList<string>> A performable question Clickability() Gets a performable question which checks the clickability of the elements. public IPerformableWithResult<IReadOnlyList<bool>> Clickability() Returns IPerformableWithResult<IReadOnlyList<bool>> A performable question CssProperty(string) Gets a performable question which reads the value of the specified CSS property from the elements. public IPerformableWithResult<IReadOnlyList<string>> CssProperty(string propertyName) Parameters propertyName string The name of the CSS property from which to read the value Returns IPerformableWithResult<IReadOnlyList<string>> A performable question Location() Gets a performable question which reads the pixel location (top-left corner) of the elements. public IPerformableWithResult<IReadOnlyList<Point>> Location() Returns IPerformableWithResult<IReadOnlyList<Point>> A performable question SelectedOptions() Gets a performable question which reads the selected options from a collection of <select> elements. public IPerformableWithResult<IReadOnlyList<IReadOnlyList<Option>>> SelectedOptions() Returns IPerformableWithResult<IReadOnlyList<IReadOnlyList<Option>>> A performable question Remarks This question is only valid for <select> elements. For any other type of element, the behaviour is undefined. Size() Gets a performable question which reads the pixel size (width and height) of the elements. public IPerformableWithResult<IReadOnlyList<Size>> Size() Returns IPerformableWithResult<IReadOnlyList<Size>> A performable question Text() Gets a performable question which reads the text content of the elements. public IPerformableWithResult<IReadOnlyList<string>> Text() Returns IPerformableWithResult<IReadOnlyList<string>> A performable question UnselectedOptions() Gets a performable question which reads the unselected options from a collection of <select> elements. public IPerformableWithResult<IReadOnlyList<IReadOnlyList<Option>>> UnselectedOptions() Returns IPerformableWithResult<IReadOnlyList<IReadOnlyList<Option>>> A performable question Remarks This question is only valid for <select> elements. For any other type of element, the behaviour is undefined. Value() Gets a performable question which reads the value of the elements. public IPerformableWithResult<IReadOnlyList<string>> Value() Returns IPerformableWithResult<IReadOnlyList<string>> A performable question Visibility() Gets a performable question which checks the visibility of the elements. public IPerformableWithResult<IReadOnlyList<bool>> Visibility() Returns IPerformableWithResult<IReadOnlyList<bool>> A performable question"
  },
  "api/CSF.Screenplay.Selenium.Builders.QuestionQueryBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.QuestionQueryBuilder.html",
    "title": "Class QuestionQueryBuilder | Screenplay",
    "summary": "Class QuestionQueryBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll Provides methods to build performable questions for a Selenium element, which are based upon querying/interrogating values from that element. public class QuestionQueryBuilder Inheritance object QuestionQueryBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples All the usages of SingleElementQuery<TResult> or ElementCollectionQuery<TResult> follow the same pattern, as demonstrated below. This example reads the background-color from a list item. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget warningItem = new CssSelector(\"li.warning\", \"the warning item\"); // Within the logic of a custom task, deriving from IPerformableWithResult<string> public async ValueTask<string> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic var bgColor = await actor.PerformAsync(ReadFromTheElement(warningItem).TheCssProperty(\"background-color\"), cancellationToken); // ... other performance logic return bgColor; } Remarks This class is used with the Screenplay questions SingleElementQuery<TResult> and/or ElementCollectionQuery<TResult>. The builder methods for these questions, ReadFromTheElement(ITarget) and ReadFromTheCollectionOfElements(ITarget) respectively, return an instance of this builder type. From this type, the developer should select what it is that they wish to read from the element(s). For more information about queries and their usage, see Queries. Constructors QuestionQueryBuilder(ITarget) Initializes a new instance of the QuestionQueryBuilder class with the specified Selenium element. public QuestionQueryBuilder(ITarget target) Parameters target ITarget The Selenium element to be used by the query builder. Methods AllOptions() Gets a performable question which reads all of the available options (whether selected or not) from a <select> element. public IPerformableWithResult<IReadOnlyList<Option>> AllOptions() Returns IPerformableWithResult<IReadOnlyList<Option>> A performable question Examples See the class QuestionQueryBuilder for an example; all the methods to this class follow the same pattern. Remarks This question is only valid for <select> elements. For any other type of element, the behaviour is undefined. SelectedOptions() Gets a performable question which reads the selected options from a <select> element. public IPerformableWithResult<IReadOnlyList<Option>> SelectedOptions() Returns IPerformableWithResult<IReadOnlyList<Option>> A performable question Examples See the class QuestionQueryBuilder for an example; all the methods to this class follow the same pattern. Remarks This question is only valid for <select> elements. For any other type of element, the behaviour is undefined. TheAttribute(string) Gets a performable question which reads the value of the specified attribute from the element. public IPerformableWithResult<string> TheAttribute(string attributeName) Parameters attributeName string The name of the attribute from which to read the value Returns IPerformableWithResult<string> A performable question Examples This example shows how to use the SingleElementQuery<TResult> question to read the title attribute from a button. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget cancelButton = new CssSelector(\"button.cancel\", \"the cancel button\"); // Within the logic of a custom task, deriving from IPerformableWithResult<string> public async ValueTask<string> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic var title = await actor.PerformAsync(ReadFromTheElement(cancelButton).TheAttribute(\"title\"), cancellationToken); // ... other performance logic return title; } TheClickability() Gets a performable question which checks the clickability of the element. public IPerformableWithResult<bool> TheClickability() Returns IPerformableWithResult<bool> A performable question Examples See the class QuestionQueryBuilder for an example; all the methods to this class follow the same pattern. Remarks An element is considered 'clickable' if it is both visible in the web browser and it is not disabled. TheCssProperty(string) Gets a performable question which reads the value of the specified CSS property from the element. public IPerformableWithResult<string> TheCssProperty(string propertyName) Parameters propertyName string The name of the CSS property from which to read the value Returns IPerformableWithResult<string> A performable question Examples See the class QuestionQueryBuilder for an example; all the methods to this class follow the same pattern. Remarks Note that this is not limited to reading the styling of an element/elements as it was defined in a stylesheet. It reads the live styling of the element as it is when the question executes. Thus, if JavaScript or a class change has altered the styling of the element since it was first rendered on-screen, its up-to-date styling information will be returned by this query. TheLocation() Gets a performable question which reads the pixel location (top-left corner) of the element. public IPerformableWithResult<Point> TheLocation() Returns IPerformableWithResult<Point> A performable question Examples See the class QuestionQueryBuilder for an example; all the methods to this class follow the same pattern. TheSize() Gets a performable question which reads the pixel size (width and height) of the element. public IPerformableWithResult<Size> TheSize() Returns IPerformableWithResult<Size> A performable question Examples See the class QuestionQueryBuilder for an example; all the methods to this class follow the same pattern. TheText() Gets a performable question which reads the text content of the element. public IPerformableWithResult<string> TheText() Returns IPerformableWithResult<string> A performable question Examples See the class QuestionQueryBuilder for an example; all the methods to this class follow the same pattern. Remarks When reading text from the web browser, this query will trim leading/trailing whitespace. This is because some browsers (Safari) include whitespace at the beginning/end of text read from the browser, which isn't visible to the end user. This is typically the space which is inherent in the markup, but which browsers ignore when actually displaying content. Trimming it by default ensures that Screenplay reproduces functionality reliably cross-browser. If this causes an issue and you would like the leading/trailing whitespace included then use TheTextWithoutTrimmingWhitespace() instead. TheTextWithoutTrimmingWhitespace() Gets a performable question which reads the text content of the element, preserving leading/trailing whitespace if present. public IPerformableWithResult<string> TheTextWithoutTrimmingWhitespace() Returns IPerformableWithResult<string> A performable question Examples See the class QuestionQueryBuilder for an example; all the methods to this class follow the same pattern. Remarks Unlike TheText(), this method will not trim any leading/trailing whitespace. Be aware that some browsers (Safari) may include leading/trailing whitespace when reading text, which other WebDriver implementations do not. This can result in inconsistent results when operating cross-browser. If cross-browser consistency is important then consider using TheText() instead. TheValue() Gets a performable question which reads the value of the element. public IPerformableWithResult<string> TheValue() Returns IPerformableWithResult<string> A performable question Examples See the class QuestionQueryBuilder for an example; all the methods to this class follow the same pattern. Remarks This query is only meaningful for elements which may have a value. Examples of these include <input>, <textarea> or <select> elements. TheVisibility() Gets a performable question which checks the visibility of the element. public IPerformableWithResult<bool> TheVisibility() Returns IPerformableWithResult<bool> A performable question Examples See the class QuestionQueryBuilder for an example; all the methods to this class follow the same pattern. UnselectedOptions() Gets a performable question which reads the unselected options from a <select> element. public IPerformableWithResult<IReadOnlyList<Option>> UnselectedOptions() Returns IPerformableWithResult<IReadOnlyList<Option>> A performable question Examples See the class QuestionQueryBuilder for an example; all the methods to this class follow the same pattern. Remarks This question is only valid for <select> elements. For any other type of element, the behaviour is undefined. See Also SingleElementQuery<TResult> ElementCollectionQuery<TResult>"
  },
  "api/CSF.Screenplay.Selenium.Builders.SaveScreenshotBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.SaveScreenshotBuilder.html",
    "title": "Class SaveScreenshotBuilder | Screenplay",
    "summary": "Class SaveScreenshotBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll A builder class to create an instance of SaveScreenshot. public class SaveScreenshotBuilder : IGetsPerformable Inheritance object SaveScreenshotBuilder Implements IGetsPerformable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Like all builders in this namespace, this class is not to be instantiated directly. Instead, use the SaveTheScreenshot(Screenshot) method. Methods WithTheFormat(ScreenshotImageFormat) Specifies the image format to use when saving the screenshot. public SaveScreenshotBuilder WithTheFormat(ScreenshotImageFormat format) Parameters format ScreenshotImageFormat The file format Returns SaveScreenshotBuilder This same builder, so further customisations may be performed Remarks If the image format is omitted (this method is not used) then the saved screenshot will default to the Png image format. WithTheName(string) Specifies a human-readable name/summary for the screenshot. public SaveScreenshotBuilder WithTheName(string name) Parameters name string A human-readable name for the screenshot. Returns SaveScreenshotBuilder This same builder, so further customisations may be performed Remarks Specifying this name is recommended, as it will form a part of the report which is subsequently generated. The name will serve to identify the screenshot amongst other assets which may be included in the report. The name will also be used as part of the filename by which the screenshot asset file is saved. Operators implicit operator SaveScreenshot(SaveScreenshotBuilder) Implicitly converts a SaveScreenshotBuilder to an SaveScreenshot. public static implicit operator SaveScreenshot(SaveScreenshotBuilder builder) Parameters builder SaveScreenshotBuilder The SaveScreenshotBuilder instance. Returns SaveScreenshot An SaveScreenshot instance."
  },
  "api/CSF.Screenplay.Selenium.Builders.SendKeysBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.SendKeysBuilder.html",
    "title": "Class SendKeysBuilder | Screenplay",
    "summary": "Class SendKeysBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll A builder type to create a performable action which types text (sends keys) to a target element. public class SendKeysBuilder Inheritance object SendKeysBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Like all builders in this namespace, this class is not to be instantiated directly. Instead, use the EnterTheText(params string[]) method. Methods Into(ITarget) Gets a performable action which sends/types the already-specified text to the specified target element. public IPerformable Into(ITarget target) Parameters target ITarget The target element to which the keys will be sent. Returns IPerformable A performable action"
  },
  "api/CSF.Screenplay.Selenium.Builders.TakeAndSaveScreenshotBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.TakeAndSaveScreenshotBuilder.html",
    "title": "Class TakeAndSaveScreenshotBuilder | Screenplay",
    "summary": "Class TakeAndSaveScreenshotBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll A builder class to create an instance of TakeAndSaveScreenshot. public class TakeAndSaveScreenshotBuilder : IGetsPerformable Inheritance object TakeAndSaveScreenshotBuilder Implements IGetsPerformable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Like all builders in this namespace, this class is not to be instantiated directly. Instead, use either of the TakeAndSaveAScreenshot() or TakeAndSaveAScreenshotIfSupported() methods. Methods WithTheFormat(ScreenshotImageFormat) Specifies the image format to use when saving the screenshot. public TakeAndSaveScreenshotBuilder WithTheFormat(ScreenshotImageFormat format) Parameters format ScreenshotImageFormat The file format Returns TakeAndSaveScreenshotBuilder This same builder, so further customisations may be performed Remarks If the image format is omitted (this method is not used) then the saved screenshot will default to the Png image format. WithTheName(string) Specifies a human-readable name/summary for the screenshot. public TakeAndSaveScreenshotBuilder WithTheName(string name) Parameters name string A human-readable name for the screenshot. Returns TakeAndSaveScreenshotBuilder This same builder, so further customisations may be performed Remarks Specifying this name is recommended, as it will form a part of the report which is subsequently generated. The name will serve to identify the screenshot amongst other assets which may be included in the report. The name will also be used as part of the filename by which the screenshot asset file is saved. Operators implicit operator TakeAndSaveScreenshot(TakeAndSaveScreenshotBuilder) Implicitly converts a SaveScreenshotBuilder to an SaveScreenshot. public static implicit operator TakeAndSaveScreenshot(TakeAndSaveScreenshotBuilder builder) Parameters builder TakeAndSaveScreenshotBuilder The SaveScreenshotBuilder instance. Returns TakeAndSaveScreenshot An SaveScreenshot instance."
  },
  "api/CSF.Screenplay.Selenium.Builders.TextMultiQueryBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.TextMultiQueryBuilder.html",
    "title": "Class TextMultiQueryBuilder | Screenplay",
    "summary": "Class TextMultiQueryBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll Builder type for a performable that gets a collection of text values. public class TextMultiQueryBuilder : IGetsPerformableWithResult<IReadOnlyList<string>> Inheritance object TextMultiQueryBuilder Implements IGetsPerformableWithResult<IReadOnlyList<string>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The purpose of this builder is to enable or disable the trimming of whitespace characters at the beginning or end of the returned text. Constructors TextMultiQueryBuilder(ITarget) Initializes a new instance of the TextMultiQueryBuilder class. public TextMultiQueryBuilder(ITarget elements) Parameters elements ITarget The target elements to query. Methods WithoutTrimmingWhitespace() Configures the performable to disable the trimming of whitespace characters at the beginning or end of the returned text. public TextMultiQueryBuilder WithoutTrimmingWhitespace() Returns TextMultiQueryBuilder The current instance of the builder, so calls may be chained. Remarks Trimming of whitespace at the beginning/end of text is enabled by default. This is because some browsers (Safari) include whitespace at the beginning/end of text read from the browser, which isn't visible to the end user. This is typically the space which is inherent in the markup, but which browsers ignore when actually displaying content. Trimming it by default ensures that Screenplay reproduces functionality reliably cross-browser. If this causes an issue and you would like the leading/trailing whitespace included in the result then use this method. Note that you may see different results in browsers which include leading/trailing whitespace anyway."
  },
  "api/CSF.Screenplay.Selenium.Builders.TextQueryBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.TextQueryBuilder.html",
    "title": "Class TextQueryBuilder | Screenplay",
    "summary": "Class TextQueryBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll Builder type for a performable that gets a single text value. public class TextQueryBuilder : IGetsPerformableWithResult<string> Inheritance object TextQueryBuilder Implements IGetsPerformableWithResult<string> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The purpose of this builder is to enable or disable the trimming of whitespace characters at the beginning or end of the returned text. Constructors TextQueryBuilder(ITarget) Initializes a new instance of the TextQueryBuilder class. public TextQueryBuilder(ITarget element) Parameters element ITarget The target element to query. Methods WithoutTrimmingWhitespace() Configures the performable to disable the trimming of whitespace characters at the beginning or end of the returned text. public TextQueryBuilder WithoutTrimmingWhitespace() Returns TextQueryBuilder The current instance of the builder, so calls may be chained. Remarks Trimming of whitespace at the beginning/end of text is enabled by default. This is because some browsers (Safari) include whitespace at the beginning/end of text read from the browser, which isn't visible to the end user. This is typically the space which is inherent in the markup, but which browsers ignore when actually displaying content. Trimming it by default ensures that Screenplay reproduces functionality reliably cross-browser. If this causes an issue and you would like the leading/trailing whitespace included in the result then use this method. Note that you may see different results in browsers which include leading/trailing whitespace anyway."
  },
  "api/CSF.Screenplay.Selenium.Builders.UnnamedWaitBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.UnnamedWaitBuilder.html",
    "title": "Class UnnamedWaitBuilder | Screenplay",
    "summary": "Class UnnamedWaitBuilder Namespace CSF.Screenplay.Selenium.Builders Assembly CSF.Screenplay.Selenium.dll Provides a builder for configuring wait actions in Selenium. public class UnnamedWaitBuilder : NamedWaitBuilder, IGetsPerformable Inheritance object NamedWaitBuilder UnnamedWaitBuilder Implements IGetsPerformable Inherited Members NamedWaitBuilder.Timeout NamedWaitBuilder.PollingInterval NamedWaitBuilder.IgnoredExceptionTypes object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class provides methods for configuring various aspects of a wait action, such as timeout, polling interval, and ignored exception types. It also provides a way to set a human-readable name for the wait condition. Constructors UnnamedWaitBuilder(Func<IWebDriver, bool>) Initializes a new instance of the UnnamedWaitBuilder class with a specified timeout. public UnnamedWaitBuilder(Func<IWebDriver, bool> predicate) Parameters predicate Func<IWebDriver, bool> The predicate which ends the wait when it returns a successful result. Methods ForAtMost(TimeSpan) Configures the wait action to use a specified maximum timeout. public UnnamedWaitBuilder ForAtMost(TimeSpan timeout) Parameters timeout TimeSpan The maximum amount of time to wait. Returns UnnamedWaitBuilder The same wait builder, so that calls may be chained. Remarks If the timeout is reached before the predicate function returns a true result then the wait will end, and an exception will be raised. This method is optional. If it is not called then the default behaviour of the Wait question will be used. See the documentation for that class for more details. GetWaitUntilPredicate() Gets the wait-until predicate, which wraps both the predicate logic and a human-readable name. protected override WaitUntilPredicate<bool> GetWaitUntilPredicate() Returns WaitUntilPredicate<bool> The wait-until predicate instance. IgnoringTheseExceptionTypes(params Type[]) Configures the wait action which will be created to ignore exceptions of the specified types. public UnnamedWaitBuilder IgnoringTheseExceptionTypes(params Type[] ignoredExceptionTypes) Parameters ignoredExceptionTypes Type[] A collection of exception types to be ignored when polling the predicate function. Returns UnnamedWaitBuilder Remarks When evaluating the predicate/condition function, the WebDriver may throw exceptions, such as if an element doesn't exist. Use this method to specify a collection of exception types which should be ignored. If an exception thrown of one of these types then the WebDriver wait will treat it the same as a false outcome and continue to poll the predicate. This method is optional. If it is not called then no exception types will be ignored. Exceptions InvalidOperationException Thrown if the ignored exception types have already been set. Named(string) Configures the wait action to use a short, descriptive, human-readable name summarising what the performable is waiting for. public UnnamedWaitBuilder Named(string name) Parameters name string The name to use. Returns UnnamedWaitBuilder The same wait builder, so that calls may be chained. Remarks Use of this method is optional but strongly recommended. Giving the wait performable a name will make it easier to understand. Exceptions ArgumentNullException Thrown if the name is null. InvalidOperationException Thrown if the name has already been set. WithPollingInterval(TimeSpan) Configures the wait action which will be created to use a specified polling interval. public UnnamedWaitBuilder WithPollingInterval(TimeSpan pollingInterval) Parameters pollingInterval TimeSpan The polling interval to use. Returns UnnamedWaitBuilder The same wait builder, so that calls may be chained. Remarks The polling interval is the amount of time that the WebDriver will wait between each evaluation of the predicate function. This method is optional. If it is not called then Screenplay will not specify a polling interval. Selenium will then use its own default interval, which is 500ms. Choosing a polling interval is a balance between responsiveness and resource usage. A shorter polling interval may lead to quicker detection of the condition being met (a more responsive predicate), but at the cost of increased network usage as more round-trips are made to the WebDriver. Conversely, a longer polling interval reduces network traffic but may result in a less responsive predicate. If you are not sure what to choose, it's recommended not to use this method; use the default provided by Selenium. Exceptions InvalidOperationException Thrown if the polling interval has already been set."
  },
  "api/CSF.Screenplay.Selenium.Builders.html": {
    "href": "api/CSF.Screenplay.Selenium.Builders.html",
    "title": "Namespace CSF.Screenplay.Selenium.Builders | Screenplay",
    "summary": "Namespace CSF.Screenplay.Selenium.Builders Classes ClickBuilder Builder for creating click actions on a target element. EnterTheDateBuilder A builder type which creates an instance of EnterTheDate. ExecuteJavaScriptBuilder A builder type for executing JavaScript in the browser which is not expected to return a result value. ExecuteJavaScriptBuilderBase Base type for a builder which facilitates the execution of JavaScript in the web browser. ExecuteJavaScriptBuilderWithResult<TResult> A builder type for executing JavaScript in the browser, where the script is expected to return a result value. FilterElementsBuilder A builder class for filtering Selenium elements based on a specification. FindElementBuilder A builder class for finding a single element within a specified target. FindElementsBuilder A builder class for finding a collection of elements within a specified target. FromTargetActionBuilder A builder class for creating performable actions which act upon a specified target element. NamedFilterElementsBuilder A builder class which permits specifying an optional name for the collection of elements which match an element filter. NamedWaitBuilder Provides a builder for configuring wait actions in Selenium. QueryPredicatePrototypeBuilder Provides methods to build WebDriver predicate functions for a target element. QueryPredicatePrototype<TQueryable> A prototype object which may be converted into either a WaitUntilPredicate<T> or an CSF.Specifications.ISpecificationFunction<T>. QuestionMultiQueryBuilder Provides methods to build performable questions for a collection of Selenium elements, which are based upon querying/interrogating values from those elements. QuestionQueryBuilder Provides methods to build performable questions for a Selenium element, which are based upon querying/interrogating values from that element. SaveScreenshotBuilder A builder class to create an instance of SaveScreenshot. SendKeysBuilder A builder type to create a performable action which types text (sends keys) to a target element. TakeAndSaveScreenshotBuilder A builder class to create an instance of TakeAndSaveScreenshot. TextMultiQueryBuilder Builder type for a performable that gets a collection of text values. TextQueryBuilder Builder type for a performable that gets a single text value. UnnamedWaitBuilder Provides a builder for configuring wait actions in Selenium. Interfaces IBuildsElementPredicates An object which may be converted into either a WaitUntilPredicate<T> or an CSF.Specifications.ISpecificationFunction<T>."
  },
  "api/CSF.Screenplay.Selenium.Color.html": {
    "href": "api/CSF.Screenplay.Selenium.Color.html",
    "title": "Struct Color | Screenplay",
    "summary": "Struct Color Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll Immutable type represents a color on the web, in a manner which may be converted and compared between web-supported formats. public struct Color : IEquatable<Color>, IEquatable<Color>, IEquatable<string> Implements IEquatable<Color> IEquatable<Color> IEquatable<string> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks An uninitialized instance of this type will represent \"fully-transparent black\". This is equivalent to the value available at TRANSPARENT. Internally, this type stores color as three unsigned byte values (Red, Green, Blue) and a double representing the transparency (Alpha). The Alpha value must be between 0 (fully transparent) and 1 (fully opaque). For a list of the well-known named colors, such as green or rosybrown, see the Colors class. This has static properties to get instances of Color for each of these. It also has methods to get a color based upon a string color name. This struct contains functionality to compare equality with, and convert to/from the .NET built-in Color. It also contains parsing logic to parse/format an instance from/to string representations of color which are used by web browsers. See the MDN writeup of web color for more information about the valid formats. When using a sufficiently high version of .NET & the C# language (.NET 6 or higher), this type is a readonly record struct. This offers improved and extended functionality, such as access to non-destructive mutation using the with keyword. In lower .NET/C# versions, this type is a plain struct with functionality supported by that language version. Constructors Color(byte, byte, byte, double) Creates a new instance of Color from the specified RGBA values. public Color(byte red, byte green, byte blue, double alpha = 1) Parameters red byte The red component in the sRGB color space green byte The green component in the sRGB color space blue byte The blue component in the sRGB color space alpha double The alpha (transparency) component, which must be between zero and one. Remarks The byte data type for the R, G and B components of the color ensure that it is impossible to specify values outside the permitted range. As for the alpha, if a value of less than zero is specified here then it is treated as zero. Likewise if a value of greater than one is specified then it will be treated as one. Properties Alpha Gets the alpha (transparency) component in the sRGB color space. public double Alpha { get; } Property Value double Remarks The value of this property will always be between zero (fully transparent) and one (fully opaque). AlphaAsByte Gets a representation of Alpha, as a byte. public byte AlphaAsByte { get; } Property Value byte Blue Gets the blue component in the sRGB color space. public byte Blue { get; } Property Value byte Green Gets the green component in the sRGB color space. public byte Green { get; } Property Value byte Red Gets the red component in the sRGB color space. public byte Red { get; } Property Value byte Methods Equals(Color) public bool Equals(Color other) Parameters other Color Returns bool Equals(Color) public bool Equals(Color other) Parameters other Color Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool Equals(string) public bool Equals(string other) Parameters other string Returns bool FromSystemDrawingColour(Color) Converts a Color into a Color. public static Color FromSystemDrawingColour(Color color) Parameters color Color Returns Color A Color representation of the specified color. Remarks In some situations, it might be useful to convert to/from the .NET built-in Color type. Use this method and ToSystemDrawingColor() to do so. GetHashCode() public override int GetHashCode() Returns int Parse(string) Parses a Color from a string representation of a color. public static Color Parse(string webColorValue) Parameters webColorValue string A string containing a color value which is compatible with the web. See the MDN writeup on web colors for more information. Returns Color The parsed color. Remarks If webColorValue is a valid representation of a web-compatible color value then this method will return that color as an instance of Color. If not, this method will throw an exception. If you are not certain that the webColorValue represents a valid colour then use TryParse(string, out Color) instead. Exceptions ArgumentNullException If webColorValue is null. FormatException If webColorValue is not a recognized representation of a color. ToHexString() Gets a representation of the current instance in the format #RRGGBB. public string ToHexString() Returns string An RGB-format string. Remarks The characters RR, GG and BB in the format example correpsond to three hexadecimal unsigned byte values (00 to FF, corresponding to decimal 0 to 255). These indicate the red, green and blue components of the color respectively. Note that this format omits the alpha (transparency) component of the color. Thus, the resulting string will not be equal to the Color value which created it if the alpha component is not equal to 1. The only string-formatting methods which preserve all of the information in the color instance are ToRgbaString() and the default ToString() method, which both return equivalent results. ToRgbString() Gets a representation of the current instance in the format rgb(RRR, GGG, BBB). public string ToRgbString() Returns string An RGB-format string. Remarks The characters RRR, GGG and BBB in the format example correpsond to three decimal unsigned byte values (0 to 255) which indicate the red, green and blue components of the color respectively. Note that this format omits the alpha (transparency) component of the color. Thus, the resulting string will not be equal to the Color value which created it if the alpha component is not equal to 1. The only string-formatting methods which preserve all of the information in the color instance are ToRgbaString() and the default ToString() method, which both return equivalent results. ToRgbaString() Gets a representation of the current instance in the format rgba(RRR, GGG, BBB, A). public string ToRgbaString() Returns string An RGBA-format string. Remarks The characters RRR, GGG and BBB in the format example correpsond to three decimal unsigned byte values (0 to 255) which indicate the red, green and blue components of the color respectively. The character A corresponds to the alpha (transparency) component of the color. It will be either the numbers 1 or 0, or it will be a decimal number between one and zero. Out of the string-formatting methods available on the Color type, only this one and the default ToString() method preserve all information in the color instance. Thus this method may be used alongside Parse(string) or TryParse(string, out Color) to reliably round-trip an RGBA string color representation. ToString() Returns a string in the same format as ToRgbaString(). public override string ToString() Returns string An RGBA-format string. Remarks This method and ToRgbaString() are equivalent. ToSystemDrawingColor() Converts this color to a Color. public Color ToSystemDrawingColor() Returns Color A Color representation of this color. Remarks In some situations, it might be useful to convert to/from the .NET built-in Color type. Use this method and FromSystemDrawingColour(Color) to do so. TryParse(string, out Color) Gets a value indicating whether the specified webColorValue is a valid string representation for a Color. If this returns true then exposes the parsed Color value. public static bool TryParse(string webColorValue, out Color color) Parameters webColorValue string A string containing a color value which is compatible with the web. See the MDN writeup on web colors for more information. color Color If this method returns true, then this parameter exposes the parsed color value. If this method returns false then the value of this parameter must be ignored. Returns bool true if parsing is successful (the webColorValue contains a valid & recognized color representation); false if not Remarks If this method returns true then the output parameter color will contain the color parsed from the specified string. If this method returns false then the output parameter has an undefined value and must not be used. This method will not raise an exception and it is safe to use with unknown strings, including those which might be null. Operators operator ==(Color, Color) Gets a value indicating whether the two specified Color instances are equal. public static bool operator ==(Color first, Color second) Parameters first Color The first Color second Color The second Color Returns bool true if the two colors represent the same sRGB color; false if not. Remarks Two colors are equal if they represent the same sRGB color. operator ==(Color, Color) Gets a value indicating whether the specified Color and Color are equal. public static bool operator ==(Color color, Color sysColor) Parameters color Color The Color sysColor Color The Color Returns bool true if the two different colors represent the same sRGB color; false if not. Remarks Despite the type differences, two colors are equal if they represent the same sRGB color. operator ==(Color, string) Gets a value indicating whether the specified Color and string representation of a color are equal. public static bool operator ==(Color color, string stringColor) Parameters color Color The Color stringColor string The string which represents a color Returns bool true if the current color and the string color representation indicate the same sRGB color; false if not. Remarks A color is equal to a string if the result of TryParse(string, out Color) is true and if the resulting parsed Color instance is equal to the current color. Note that this means that a color is never equal to a string which is not a valid color representation, or which is null. operator ==(Color, Color) Gets a value indicating whether the specified Color and Color are equal. public static bool operator ==(Color sysColor, Color color) Parameters sysColor Color The Color color Color The Color Returns bool true if the two different colors represent the same sRGB color; false if not. Remarks Despite the type differences, two colors are equal if they represent the same sRGB color. operator ==(string, Color) Gets a value indicating whether the specified Color and string representation of a color are equal. public static bool operator ==(string stringColor, Color color) Parameters stringColor string The string which represents a color color Color The Color Returns bool true if the current color and the string color representation indicate the same sRGB color; false if not. Remarks A color is equal to a string if the result of TryParse(string, out Color) is true and if the resulting parsed Color instance is equal to the current color. Note that this means that a color is never equal to a string which is not a valid color representation, or which is null. operator !=(Color, Color) Gets a value indicating whether the two specified Color instances are not equal. public static bool operator !=(Color first, Color second) Parameters first Color The first Color second Color The second Color Returns bool false if the two colors represent the same sRGB color; true if not. Remarks Two colors are equal if they represent the same sRGB color. operator !=(Color, Color) Gets a value indicating whether the specified Color and Color are not equal. public static bool operator !=(Color color, Color sysColor) Parameters color Color The Color sysColor Color The Color Returns bool false if the two different colors represent the same sRGB color; true if not. Remarks Despite the type differences, two colors are equal if they represent the same sRGB color. operator !=(Color, string) Gets a value indicating whether the specified Color and string representation of a color are not equal. public static bool operator !=(Color color, string stringColor) Parameters color Color The Color stringColor string The string which represents a color Returns bool false if the current color and the string color representation indicate the same sRGB color; true if not. Remarks A color is equal to a string if the result of TryParse(string, out Color) is true and if the resulting parsed Color instance is equal to the current color. Note that this means that a color is never equal to a string which is not a valid color representation, or which is null. operator !=(Color, Color) Gets a value indicating whether the specified Color and Color are not equal. public static bool operator !=(Color sysColor, Color color) Parameters sysColor Color The Color color Color The Color Returns bool false if the two different colors represent the same sRGB color; true if not. Remarks Despite the type differences, two colors are equal if they represent the same sRGB color. operator !=(string, Color) Gets a value indicating whether the specified Color and string representation of a color are not equal. public static bool operator !=(string stringColor, Color color) Parameters stringColor string The string which represents a color color Color The Color Returns bool false if the current color and the string color representation indicate the same sRGB color; true if not. Remarks A color is equal to a string if the result of TryParse(string, out Color) is true and if the resulting parsed Color instance is equal to the current color. Note that this means that a color is never equal to a string which is not a valid color representation, or which is null."
  },
  "api/CSF.Screenplay.Selenium.Colors.html": {
    "href": "api/CSF.Screenplay.Selenium.Colors.html",
    "title": "Class Colors | Screenplay",
    "summary": "Class Colors Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll Static type containing the pre-defined colors for the web. public static class Colors Inheritance object Colors Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Each static property of this type corresponds to a well-known pre-defined color, according to the W3C HTML4 spec. Alternatively, to get a Color instance which matches a string which names a color (case insensitive) use either TryGetNamedColor(string, out Color) or GetNamedColor(string). Properties ALICEBLUE public static Color ALICEBLUE { get; } Property Value Color ANTIQUEWHITE public static Color ANTIQUEWHITE { get; } Property Value Color AQUA public static Color AQUA { get; } Property Value Color AQUAMARINE public static Color AQUAMARINE { get; } Property Value Color AZURE public static Color AZURE { get; } Property Value Color BEIGE public static Color BEIGE { get; } Property Value Color BISQUE public static Color BISQUE { get; } Property Value Color BLACK public static Color BLACK { get; } Property Value Color BLANCHEDALMOND public static Color BLANCHEDALMOND { get; } Property Value Color BLUE public static Color BLUE { get; } Property Value Color BLUEVIOLET public static Color BLUEVIOLET { get; } Property Value Color BROWN public static Color BROWN { get; } Property Value Color BURLYWOOD public static Color BURLYWOOD { get; } Property Value Color CADETBLUE public static Color CADETBLUE { get; } Property Value Color CHARTREUSE public static Color CHARTREUSE { get; } Property Value Color CHOCOLATE public static Color CHOCOLATE { get; } Property Value Color CORAL public static Color CORAL { get; } Property Value Color CORNFLOWERBLUE public static Color CORNFLOWERBLUE { get; } Property Value Color CORNSILK public static Color CORNSILK { get; } Property Value Color CRIMSON public static Color CRIMSON { get; } Property Value Color CYAN public static Color CYAN { get; } Property Value Color DARKBLUE public static Color DARKBLUE { get; } Property Value Color DARKCYAN public static Color DARKCYAN { get; } Property Value Color DARKGOLDENROD public static Color DARKGOLDENROD { get; } Property Value Color DARKGRAY public static Color DARKGRAY { get; } Property Value Color DARKGREEN public static Color DARKGREEN { get; } Property Value Color DARKGREY public static Color DARKGREY { get; } Property Value Color DARKKHAKI public static Color DARKKHAKI { get; } Property Value Color DARKMAGENTA public static Color DARKMAGENTA { get; } Property Value Color DARKOLIVEGREEN public static Color DARKOLIVEGREEN { get; } Property Value Color DARKORANGE public static Color DARKORANGE { get; } Property Value Color DARKORCHID public static Color DARKORCHID { get; } Property Value Color DARKRED public static Color DARKRED { get; } Property Value Color DARKSALMON public static Color DARKSALMON { get; } Property Value Color DARKSEAGREEN public static Color DARKSEAGREEN { get; } Property Value Color DARKSLATEBLUE public static Color DARKSLATEBLUE { get; } Property Value Color DARKSLATEGRAY public static Color DARKSLATEGRAY { get; } Property Value Color DARKSLATEGREY public static Color DARKSLATEGREY { get; } Property Value Color DARKTURQUOISE public static Color DARKTURQUOISE { get; } Property Value Color DARKVIOLET public static Color DARKVIOLET { get; } Property Value Color DEEPPINK public static Color DEEPPINK { get; } Property Value Color DEEPSKYBLUE public static Color DEEPSKYBLUE { get; } Property Value Color DIMGRAY public static Color DIMGRAY { get; } Property Value Color DIMGREY public static Color DIMGREY { get; } Property Value Color DODGERBLUE public static Color DODGERBLUE { get; } Property Value Color FIREBRICK public static Color FIREBRICK { get; } Property Value Color FLORALWHITE public static Color FLORALWHITE { get; } Property Value Color FORESTGREEN public static Color FORESTGREEN { get; } Property Value Color FUCHSIA public static Color FUCHSIA { get; } Property Value Color GAINSBORO public static Color GAINSBORO { get; } Property Value Color GHOSTWHITE public static Color GHOSTWHITE { get; } Property Value Color GOLD public static Color GOLD { get; } Property Value Color GOLDENROD public static Color GOLDENROD { get; } Property Value Color GRAY public static Color GRAY { get; } Property Value Color GREEN public static Color GREEN { get; } Property Value Color GREENYELLOW public static Color GREENYELLOW { get; } Property Value Color GREY public static Color GREY { get; } Property Value Color HONEYDEW public static Color HONEYDEW { get; } Property Value Color HOTPINK public static Color HOTPINK { get; } Property Value Color INDIANRED public static Color INDIANRED { get; } Property Value Color INDIGO public static Color INDIGO { get; } Property Value Color IVORY public static Color IVORY { get; } Property Value Color KHAKI public static Color KHAKI { get; } Property Value Color LAVENDER public static Color LAVENDER { get; } Property Value Color LAVENDERBLUSH public static Color LAVENDERBLUSH { get; } Property Value Color LAWNGREEN public static Color LAWNGREEN { get; } Property Value Color LEMONCHIFFON public static Color LEMONCHIFFON { get; } Property Value Color LIGHTBLUE public static Color LIGHTBLUE { get; } Property Value Color LIGHTCORAL public static Color LIGHTCORAL { get; } Property Value Color LIGHTCYAN public static Color LIGHTCYAN { get; } Property Value Color LIGHTGOLDENRODYELLOW public static Color LIGHTGOLDENRODYELLOW { get; } Property Value Color LIGHTGRAY public static Color LIGHTGRAY { get; } Property Value Color LIGHTGREEN public static Color LIGHTGREEN { get; } Property Value Color LIGHTGREY public static Color LIGHTGREY { get; } Property Value Color LIGHTPINK public static Color LIGHTPINK { get; } Property Value Color LIGHTSALMON public static Color LIGHTSALMON { get; } Property Value Color LIGHTSEAGREEN public static Color LIGHTSEAGREEN { get; } Property Value Color LIGHTSKYBLUE public static Color LIGHTSKYBLUE { get; } Property Value Color LIGHTSLATEGRAY public static Color LIGHTSLATEGRAY { get; } Property Value Color LIGHTSLATEGREY public static Color LIGHTSLATEGREY { get; } Property Value Color LIGHTSTEELBLUE public static Color LIGHTSTEELBLUE { get; } Property Value Color LIGHTYELLOW public static Color LIGHTYELLOW { get; } Property Value Color LIME public static Color LIME { get; } Property Value Color LIMEGREEN public static Color LIMEGREEN { get; } Property Value Color LINEN public static Color LINEN { get; } Property Value Color MAGENTA public static Color MAGENTA { get; } Property Value Color MAROON public static Color MAROON { get; } Property Value Color MEDIUMAQUAMARINE public static Color MEDIUMAQUAMARINE { get; } Property Value Color MEDIUMBLUE public static Color MEDIUMBLUE { get; } Property Value Color MEDIUMORCHID public static Color MEDIUMORCHID { get; } Property Value Color MEDIUMPURPLE public static Color MEDIUMPURPLE { get; } Property Value Color MEDIUMSEAGREEN public static Color MEDIUMSEAGREEN { get; } Property Value Color MEDIUMSLATEBLUE public static Color MEDIUMSLATEBLUE { get; } Property Value Color MEDIUMSPRINGGREEN public static Color MEDIUMSPRINGGREEN { get; } Property Value Color MEDIUMTURQUOISE public static Color MEDIUMTURQUOISE { get; } Property Value Color MEDIUMVIOLETRED public static Color MEDIUMVIOLETRED { get; } Property Value Color MIDNIGHTBLUE public static Color MIDNIGHTBLUE { get; } Property Value Color MINTCREAM public static Color MINTCREAM { get; } Property Value Color MISTYROSE public static Color MISTYROSE { get; } Property Value Color MOCCASIN public static Color MOCCASIN { get; } Property Value Color NAVAJOWHITE public static Color NAVAJOWHITE { get; } Property Value Color NAVY public static Color NAVY { get; } Property Value Color OLDLACE public static Color OLDLACE { get; } Property Value Color OLIVE public static Color OLIVE { get; } Property Value Color OLIVEDRAB public static Color OLIVEDRAB { get; } Property Value Color ORANGE public static Color ORANGE { get; } Property Value Color ORANGERED public static Color ORANGERED { get; } Property Value Color ORCHID public static Color ORCHID { get; } Property Value Color PALEGOLDENROD public static Color PALEGOLDENROD { get; } Property Value Color PALEGREEN public static Color PALEGREEN { get; } Property Value Color PALETURQUOISE public static Color PALETURQUOISE { get; } Property Value Color PALEVIOLETRED public static Color PALEVIOLETRED { get; } Property Value Color PAPAYAWHIP public static Color PAPAYAWHIP { get; } Property Value Color PEACHPUFF public static Color PEACHPUFF { get; } Property Value Color PERU public static Color PERU { get; } Property Value Color PINK public static Color PINK { get; } Property Value Color PLUM public static Color PLUM { get; } Property Value Color POWDERBLUE public static Color POWDERBLUE { get; } Property Value Color PURPLE public static Color PURPLE { get; } Property Value Color REBECCAPURPLE public static Color REBECCAPURPLE { get; } Property Value Color RED public static Color RED { get; } Property Value Color ROSYBROWN public static Color ROSYBROWN { get; } Property Value Color ROYALBLUE public static Color ROYALBLUE { get; } Property Value Color SADDLEBROWN public static Color SADDLEBROWN { get; } Property Value Color SALMON public static Color SALMON { get; } Property Value Color SANDYBROWN public static Color SANDYBROWN { get; } Property Value Color SEAGREEN public static Color SEAGREEN { get; } Property Value Color SEASHELL public static Color SEASHELL { get; } Property Value Color SIENNA public static Color SIENNA { get; } Property Value Color SILVER public static Color SILVER { get; } Property Value Color SKYBLUE public static Color SKYBLUE { get; } Property Value Color SLATEBLUE public static Color SLATEBLUE { get; } Property Value Color SLATEGRAY public static Color SLATEGRAY { get; } Property Value Color SLATEGREY public static Color SLATEGREY { get; } Property Value Color SNOW public static Color SNOW { get; } Property Value Color SPRINGGREEN public static Color SPRINGGREEN { get; } Property Value Color STEELBLUE public static Color STEELBLUE { get; } Property Value Color TAN public static Color TAN { get; } Property Value Color TEAL public static Color TEAL { get; } Property Value Color THISTLE public static Color THISTLE { get; } Property Value Color TOMATO public static Color TOMATO { get; } Property Value Color TRANSPARENT public static Color TRANSPARENT { get; } Property Value Color TURQUOISE public static Color TURQUOISE { get; } Property Value Color VIOLET public static Color VIOLET { get; } Property Value Color WHEAT public static Color WHEAT { get; } Property Value Color WHITE public static Color WHITE { get; } Property Value Color WHITESMOKE public static Color WHITESMOKE { get; } Property Value Color YELLOW public static Color YELLOW { get; } Property Value Color YELLOWGREEN public static Color YELLOWGREEN { get; } Property Value Color Methods GetNamedColor(string) Gets a Color instance which matches the specified color-name. public static Color GetNamedColor(string colorName) Parameters colorName string A named color (case insensitive) Returns Color A Color which corresponds to the specified named color. Remarks This method will throw an exception if colorName does not correspond to a well-known color name. This is a case-insensitive match. If you are uncertain whether the colorName is a well-known color name or not then consider TryGetNamedColor(string, out Color) instead. Exceptions ArgumentNullException If colorName is null ArgumentException If colorName does not correspond to a well-known named color TryGetNamedColor(string, out Color) Gets a value indicating whether colorName is a well-known color name. Exposes a Color instance which corresponds to that name if it is. public static bool TryGetNamedColor(string colorName, out Color color) Parameters colorName string A string which might correspond to a well-known color name. color Color If this method returns true then this is a Color which corresponds to the color indicated by colorName; if it returns false then this value is undefined and must be ignored. Returns bool true if colorName is a well-known color name; false if not. Remarks This method will never throw an exception for any value of colorName. Note that match with a well-known color name is performed in a case-insensitive manner."
  },
  "api/CSF.Screenplay.Selenium.Elements.ClassName.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.ClassName.html",
    "title": "Class ClassName | Screenplay",
    "summary": "Class ClassName Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll Concrete implementation of Locator which locates elements by their HTML class attribute value. public class ClassName : Locator, ITarget, IHasName Inheritance object Locator ClassName Implements ITarget IHasName Inherited Members Locator.Specification Locator.Name Locator.GetElement(IWebDriver) Locator.GetElements(IWebDriver) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods TargetExtensions.AllHave(ITarget) TargetExtensions.AreAll(ITarget) TargetExtensions.Has(ITarget) TargetExtensions.Is(ITarget) Remarks This class wraps Selenium's ClassName(string) functionality. The purpose is provide a type which derives from ITarget, compatible with the Selenium extension's performables. This class also provides opportunity to add a human-readable Name to the element specification. This optional, but recommended, technique improves the readability of Screenplay reports. Constructors ClassName(string, string) Initializes a new instance of the ClassName class. public ClassName(string className, string name = null) Parameters className string The class attribute value by which to locate elements. name string An optional human-readable name of the locator which describes the elements it matches. Methods GetDefaultName() Gets a value for Name if none has been specified. protected override string GetDefaultName() Returns string A default name GetLocator() Gets the Selenium locator instance for finding HTML elements. public override By GetLocator() Returns By A Selenium By object used to locate elements."
  },
  "api/CSF.Screenplay.Selenium.Elements.CssSelector.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.CssSelector.html",
    "title": "Class CssSelector | Screenplay",
    "summary": "Class CssSelector Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll Concrete implementation of Locator which locates elements by a CSS selector value. public class CssSelector : Locator, ITarget, IHasName Inheritance object Locator CssSelector Implements ITarget IHasName Inherited Members Locator.Specification Locator.Name Locator.GetElement(IWebDriver) Locator.GetElements(IWebDriver) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods TargetExtensions.AllHave(ITarget) TargetExtensions.AreAll(ITarget) TargetExtensions.Has(ITarget) TargetExtensions.Is(ITarget) Remarks This class wraps Selenium's CssSelector(string) functionality. The purpose is provide a type which derives from ITarget, compatible with the Selenium extension's performables. This class also provides opportunity to add a human-readable Name to the element specification. This optional, but recommended, technique improves the readability of Screenplay reports. Constructors CssSelector(string, string) Initializes a new instance of the CssSelector class. public CssSelector(string cssSelector, string name = null) Parameters cssSelector string The CSS selector by which to locate elements. name string An optional human-readable name of the locator which describes the elements it matches. Fields AnyElement Gets a CSS-based locator which matches all/any descendent elements. public static readonly CssSelector AnyElement Field Value CssSelector Remarks This locator is equivalent to the CSS selector *, which matches any & all descendent elements. BodyElement Gets a CSS-based locator which matches the HTML body element. public static readonly CssSelector BodyElement Field Value CssSelector Remarks This locator is equivalent to the CSS selector body, which matches the root of the rendered page. Methods GetDefaultName() Gets a value for Name if none has been specified. protected override string GetDefaultName() Returns string A default name GetLocator() Gets the Selenium locator instance for finding HTML elements. public override By GetLocator() Returns By A Selenium By object used to locate elements."
  },
  "api/CSF.Screenplay.Selenium.Elements.ElementId.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.ElementId.html",
    "title": "Class ElementId | Screenplay",
    "summary": "Class ElementId Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll Concrete implementation of Locator which locates an element by its id attribute. public class ElementId : Locator, ITarget, IHasName Inheritance object Locator ElementId Implements ITarget IHasName Inherited Members Locator.Specification Locator.Name Locator.GetElement(IWebDriver) Locator.GetElements(IWebDriver) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods TargetExtensions.AllHave(ITarget) TargetExtensions.AreAll(ITarget) TargetExtensions.Has(ITarget) TargetExtensions.Is(ITarget) Remarks This class wraps Selenium's Id(string) functionality. The purpose is provide a type which derives from ITarget, compatible with the Selenium extension's performables. This class also provides opportunity to add a human-readable Name to the element specification. This optional, but recommended, technique improves the readability of Screenplay reports. In normal circumstances (with valid HTML) this locator should match a maximum of only one element. Constructors ElementId(string, string) Initializes a new instance of the ElementId class. public ElementId(string id, string name = null) Parameters id string The id by which to locate an element. name string An optional human-readable name of the locator which describes the element it matches. Methods GetDefaultName() Gets a value for Name if none has been specified. protected override string GetDefaultName() Returns string A default name GetLocator() Gets the Selenium locator instance for finding HTML elements. public override By GetLocator() Returns By A Selenium By object used to locate elements."
  },
  "api/CSF.Screenplay.Selenium.Elements.ICanReportForElement.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.ICanReportForElement.html",
    "title": "Interface ICanReportForElement | Screenplay",
    "summary": "Interface ICanReportForElement Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll Similar to ICanReport but provides access to a Selenium element to augment the report data. public interface ICanReportForElement Remarks This interface is often combined with either ISingleElementPerformable or ISingleElementPerformableWithResult<TResult>, for specialised performables which interact with a single Selenium element. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information."
  },
  "api/CSF.Screenplay.Selenium.Elements.ICanReportForElements.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.ICanReportForElements.html",
    "title": "Interface ICanReportForElements | Screenplay",
    "summary": "Interface ICanReportForElements Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll Similar to ICanReport but provides access to a collection of Selenium elements to augment the report data. public interface ICanReportForElements Remarks This interface is often combined with either IElementCollectionPerformableWithResult<TResult> for specialised performables which interact with collections of Selenium elements. Methods GetReportFragment(Actor, Lazy<SeleniumElementCollection>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element collection. ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElementCollection> elements, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment elements Lazy<SeleniumElementCollection> The Selenium elements for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information."
  },
  "api/CSF.Screenplay.Selenium.Elements.ITarget.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.ITarget.html",
    "title": "Interface ITarget | Screenplay",
    "summary": "Interface ITarget Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll A target is an object which represents one or more HTML elements and which may serve as parameters for performables which interact with elements on the web page. public interface ITarget : IHasName Inherited Members IHasName.Name Extension Methods TargetExtensions.AllHave(ITarget) TargetExtensions.AreAll(ITarget) TargetExtensions.Has(ITarget) TargetExtensions.Is(ITarget) Remarks See the targets and elements article for more information. The ITarget interface unifies two Selenium concepts: IWebElement instances and the By class. Targets correspond to the concept of HTML elements on a web page and may be used as the parameters for performable classes which interact with those elements. The SeleniumElement and SeleniumElementCollection classes wrap native Selenium web element instances. They are concrete references to elements which have been retrieved from the WebDriver. In both of these cases, the GetElement(IWebDriver) & GetElements(IWebDriver) methods will often return references to themselves without making any use of the WebDriver parameter. On the other hand, targets which derive from Locator, such as ElementId, ClassName, CssSelector and XPath identify HTML element(s) without being a concrete reference to them. A Locator is conceptually 'a specification for finding elements'. Locator-based targets will use the WebDriver parameter in their GetElement(IWebDriver) and GetElements(IWebDriver) methods, in order to retrieve concrete element references. Methods GetElement(IWebDriver) Gets a single Selenium element which matches the current target. SeleniumElement GetElement(IWebDriver driver) Parameters driver IWebDriver A Selenium Web Driver Returns SeleniumElement A SeleniumElement which matches the target Remarks This method may invoke the specified Selenium IWebDriver to get the element which matches a specification/selector. Alternatively if the target implementation already represents one or more concrete element instances then it will be returned directly. Crucially, if the target represents multiple elements then this method will return only the first element. Exceptions TargetNotFoundException If the target does not yield an HTML element GetElements(IWebDriver) Gets a collection of Selenium elements which match the current target. SeleniumElementCollection GetElements(IWebDriver driver) Parameters driver IWebDriver A Selenium Web Driver Returns SeleniumElementCollection A collection of zero or more Selenium elements Remarks This method may invoke the specified Selenium IWebDriver to find elements which match a specification/selector. Alternatively if the target implementation already represents one or more concrete element instances then these will be returned directly."
  },
  "api/CSF.Screenplay.Selenium.Elements.Locator.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.Locator.html",
    "title": "Class Locator | Screenplay",
    "summary": "Class Locator Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll Base type for implementations of ITarget which serve as a specification for Selenium elements but which do not reference those elements directly. public abstract class Locator : ITarget, IHasName Inheritance object Locator Implements ITarget IHasName Derived ClassName CssSelector ElementId XPath Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods TargetExtensions.AllHave(ITarget) TargetExtensions.AreAll(ITarget) TargetExtensions.Has(ITarget) TargetExtensions.Is(ITarget) Remarks All derived types of this class are Screenplay wrappers (adapters) for the Selenium By class. The 'By' class is a specification of sorts, describing how a WebDriver may find an element on a page. Implementations of this type provide that specification, but additionally a Name, providing human-readable content in Screenplay reports. Constructors Locator(string, string) Initializes a new instance of the Locator class. protected Locator(string specification, string name = null) Parameters specification string The locator specification string. name string An optional human-readable name of the locator which describes the elements it matches. Properties Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Specification Gets the locator specification string. protected string Specification { get; } Property Value string Methods GetDefaultName() Gets a value for Name if none has been specified. protected abstract string GetDefaultName() Returns string A default name GetElement(IWebDriver) Gets a single Selenium element which matches the current target. public SeleniumElement GetElement(IWebDriver driver) Parameters driver IWebDriver A Selenium Web Driver Returns SeleniumElement A SeleniumElement which matches the target Remarks This method may invoke the specified Selenium IWebDriver to get the element which matches a specification/selector. Alternatively if the target implementation already represents one or more concrete element instances then it will be returned directly. Crucially, if the target represents multiple elements then this method will return only the first element. Exceptions TargetNotFoundException If the target does not yield an HTML element GetElements(IWebDriver) Gets a collection of Selenium elements which match the current target. public SeleniumElementCollection GetElements(IWebDriver driver) Parameters driver IWebDriver A Selenium Web Driver Returns SeleniumElementCollection A collection of zero or more Selenium elements Remarks This method may invoke the specified Selenium IWebDriver to find elements which match a specification/selector. Alternatively if the target implementation already represents one or more concrete element instances then these will be returned directly. GetLocator() Gets the Selenium locator instance for finding HTML elements. public abstract By GetLocator() Returns By A Selenium By object used to locate elements. Operators implicit operator By(Locator) Implicitly converts a Locator to a Selenium By object. public static implicit operator By(Locator locator) Parameters locator Locator The locator to convert. Returns By A Selenium By object."
  },
  "api/CSF.Screenplay.Selenium.Elements.SeleniumElement.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.SeleniumElement.html",
    "title": "Class SeleniumElement | Screenplay",
    "summary": "Class SeleniumElement Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll An implementation of ITarget which represents a single native Selenium HTML element. public class SeleniumElement : ITarget, IHasName Inheritance object SeleniumElement Implements ITarget IHasName Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods TargetExtensions.AllHave(ITarget) TargetExtensions.AreAll(ITarget) TargetExtensions.Has(ITarget) TargetExtensions.Is(ITarget) SeleniumElementExtensions.AsSelectElement(SeleniumElement) Remarks This type of ITarget contains a reference to a native Selenium IWebElement. This class provides that element under the ITarget interface, as well as allowing the developer to specify a Name. This optional, but recommended, technique facilitates human-readable reporting. Constructors SeleniumElement(IWebElement, string) Initializes a new instance of the SeleniumElement class. public SeleniumElement(IWebElement webElement, string name = null) Parameters webElement IWebElement The native Selenium web element. name string An optional human-readable name which describes the element. Properties Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. WebElement Gets the native Selenium web element. public IWebElement WebElement { get; } Property Value IWebElement Methods ToString() public override string ToString() Returns string"
  },
  "api/CSF.Screenplay.Selenium.Elements.SeleniumElementCollection.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.SeleniumElementCollection.html",
    "title": "Class SeleniumElementCollection | Screenplay",
    "summary": "Class SeleniumElementCollection Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll An implementation of ITarget which represents a collection of native Selenium HTML elements. public class SeleniumElementCollection : ITarget, IHasName, IReadOnlyList<SeleniumElement>, IReadOnlyCollection<SeleniumElement>, IEnumerable<SeleniumElement>, IEnumerable Inheritance object SeleniumElementCollection Implements ITarget IHasName IReadOnlyList<SeleniumElement> IReadOnlyCollection<SeleniumElement> IEnumerable<SeleniumElement> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods TargetExtensions.AllHave(ITarget) TargetExtensions.AreAll(ITarget) TargetExtensions.Has(ITarget) TargetExtensions.Is(ITarget) Remarks This type of ITarget contains a collection of SeleniumElement, each of which contains a native Selenium IWebElement. This class provides those elements under the ITarget interface, as well as allowing the developer to specify a Name for this collection of elements. This optional, but recommended, technique facilitates human-readable reporting. It is perfectly acceptable for an element collection to contain zero elements. Constructors SeleniumElementCollection(IReadOnlyCollection<IWebElement>, string) Initializes a new instance of the SeleniumElementCollection class. public SeleniumElementCollection(IReadOnlyCollection<IWebElement> elements, string name = null) Parameters elements IReadOnlyCollection<IWebElement> A collection of native Selenium elements. name string An optional human-readable name which describes the collection of elements. SeleniumElementCollection(IReadOnlyList<SeleniumElement>, string) Initializes a new instance of the SeleniumElementCollection class. public SeleniumElementCollection(IReadOnlyList<SeleniumElement> elements, string name = null) Parameters elements IReadOnlyList<SeleniumElement> The list of elements. name string An optional human-readable name which describes the collection of elements. Properties Count public int Count { get; } Property Value int this[int] public SeleniumElement this[int index] { get; } Parameters index int Property Value SeleniumElement Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Methods GetEnumerator() public IEnumerator<SeleniumElement> GetEnumerator() Returns IEnumerator<SeleniumElement> ToString() public override string ToString() Returns string"
  },
  "api/CSF.Screenplay.Selenium.Elements.SeleniumElementExtensions.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.SeleniumElementExtensions.html",
    "title": "Class SeleniumElementExtensions | Screenplay",
    "summary": "Class SeleniumElementExtensions Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll Extension methods for SeleniumElement. public static class SeleniumElementExtensions Inheritance object SeleniumElementExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AsSelectElement(SeleniumElement) Gets a Selenium SelectElement instance from the specified element. public static SelectElement AsSelectElement(this SeleniumElement element) Parameters element SeleniumElement A SeleniumElement which should represent an HTML <select> element Returns SelectElement A Selenium select element Remarks SelectElement is a Selenium type which represents an HTML <select> element, wrapping the native IWebElement. The select element class provides convenience functionality for reading and manipulating the state of the underlying element. Exceptions UnexpectedTagNameException If the element is not a <select> element ArgumentNullException If the element is null"
  },
  "api/CSF.Screenplay.Selenium.Elements.TargetExtensions.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.TargetExtensions.html",
    "title": "Class TargetExtensions | Screenplay",
    "summary": "Class TargetExtensions Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll Extension methods for ITarget instances. public static class TargetExtensions Inheritance object TargetExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AllHave(ITarget) Creates a new QueryPredicatePrototypeBuilder for the specified target, which represents a collection of HTML elements. public static QueryPredicatePrototypeBuilder AllHave(this ITarget target) Parameters target ITarget The target for which to create the query builder. Returns QueryPredicatePrototypeBuilder A new instance of QueryPredicatePrototypeBuilder. Remarks This method is used with the creation of predicates for WaitUntil(Func<IWebDriver, bool>) to wait until every element expsed by the current target instance meets the specified conditions. The method AreAll(ITarget) is functionally identical to this method; the two overloads are provided just so developers may create a more readable fluent method chain. AreAll(ITarget) Creates a new QueryPredicatePrototypeBuilder for the specified target, which represents a collection of HTML elements. public static QueryPredicatePrototypeBuilder AreAll(this ITarget target) Parameters target ITarget The target for which to create the query builder. Returns QueryPredicatePrototypeBuilder A new instance of QueryPredicatePrototypeBuilder. Remarks This method is used with the creation of predicates for WaitUntil(Func<IWebDriver, bool>) to wait until every element expsed by the current target instance meets the specified conditions. The method AllHave(ITarget) is functionally identical to this method; the two overloads are provided just so developers may create a more readable fluent method chain. Has(ITarget) Creates a new QueryPredicatePrototypeBuilder for the specified target, which represents a single HTML element. public static QueryPredicatePrototypeBuilder Has(this ITarget target) Parameters target ITarget The target for which to create the query builder. Returns QueryPredicatePrototypeBuilder A new instance of QueryPredicatePrototypeBuilder. Remarks This method is used with the creation of predicates for WaitUntil(Func<IWebDriver, bool>) to wait until the current target instance meets the specified conditions. The method Is(ITarget) is functionally identical to this method; the two overloads are provided just so developers may create a more readable fluent method chain. Is(ITarget) Creates a new QueryPredicatePrototypeBuilder for the specified target, which represents a single HTML element. public static QueryPredicatePrototypeBuilder Is(this ITarget target) Parameters target ITarget The target for which to create the query builder. Returns QueryPredicatePrototypeBuilder A new instance of QueryPredicatePrototypeBuilder. Remarks This method is used with the creation of predicates for WaitUntil(Func<IWebDriver, bool>) to wait until the current target instance meets the specified conditions. The method Has(ITarget) is functionally identical to this method; the two overloads are provided just so developers may create a more readable fluent method chain."
  },
  "api/CSF.Screenplay.Selenium.Elements.TargetNotFoundException.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.TargetNotFoundException.html",
    "title": "Class TargetNotFoundException | Screenplay",
    "summary": "Class TargetNotFoundException Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll Thrown when GetElement(IWebDriver) is used, but no element can be found. [Serializable] public class TargetNotFoundException : Exception, ISerializable, IFormattableValue Inheritance object Exception TargetNotFoundException Implements ISerializable IFormattableValue Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors TargetNotFoundException() Initializes a new instance of the TargetNotFoundException class. public TargetNotFoundException() TargetNotFoundException(SerializationInfo, StreamingContext) Initializes a new instance of the TargetNotFoundException class from binary serialization. [Obsolete(\"Do not use this constructor overload, see the remarks for more info\")] protected TargetNotFoundException(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo Serialization info context StreamingContext Streaming context Remarks Don't use this API, it's for the deprecated binary serialization API, which is known to pose security vulnerabilities. It is removed and unsupported in modern TFMs. See The BinaryFormatter migration guide for more information. TargetNotFoundException(string) Initializes a new instance of the TargetNotFoundException class. public TargetNotFoundException(string message) Parameters message string An exception message TargetNotFoundException(string, ITarget) Initializes a new instance of the TargetNotFoundException class. public TargetNotFoundException(string message, ITarget target) Parameters message string An exception message target ITarget The target for which no element could be found TargetNotFoundException(string, Exception) Initializes a new instance of the TargetNotFoundException class. public TargetNotFoundException(string message, Exception inner) Parameters message string An exception message inner Exception The inner exception TargetNotFoundException(string, Exception, ITarget) Initializes a new instance of the TargetNotFoundException class. public TargetNotFoundException(string message, Exception inner, ITarget target) Parameters message string An exception message inner Exception The inner exception target ITarget The target for which no element could be found Properties Target Gets the target for which no element could not be found. public ITarget Target { get; } Property Value ITarget Methods FormatForReport() Gets a human-readable formatted string which represents the current object instance, suitable to be used in a Screenplay report. public string FormatForReport() Returns string A formatted string which represents the current instance."
  },
  "api/CSF.Screenplay.Selenium.Elements.XPath.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.XPath.html",
    "title": "Class XPath | Screenplay",
    "summary": "Class XPath Namespace CSF.Screenplay.Selenium.Elements Assembly CSF.Screenplay.Selenium.dll Concrete implementation of Locator which locates elements using an XPath query. public class XPath : Locator, ITarget, IHasName Inheritance object Locator XPath Implements ITarget IHasName Inherited Members Locator.Specification Locator.Name Locator.GetElement(IWebDriver) Locator.GetElements(IWebDriver) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods TargetExtensions.AllHave(ITarget) TargetExtensions.AreAll(ITarget) TargetExtensions.Has(ITarget) TargetExtensions.Is(ITarget) Remarks This class wraps Selenium's XPath(string) functionality. The purpose is provide a type which derives from ITarget, compatible with the Selenium extension's performables. This class also provides opportunity to add a human-readable Name to the element specification. This optional, but recommended, technique improves the readability of Screenplay reports. Constructors XPath(string, string) Initializes a new instance of the XPath class. public XPath(string xpath, string name = null) Parameters xpath string The XPath query by which to locate elements. name string An optional human-readable name of the locator which describes the elements it matches. Methods GetDefaultName() Gets a value for Name if none has been specified. protected override string GetDefaultName() Returns string A default name GetLocator() Gets the Selenium locator instance for finding HTML elements. public override By GetLocator() Returns By A Selenium By object used to locate elements."
  },
  "api/CSF.Screenplay.Selenium.Elements.html": {
    "href": "api/CSF.Screenplay.Selenium.Elements.html",
    "title": "Namespace CSF.Screenplay.Selenium.Elements | Screenplay",
    "summary": "Namespace CSF.Screenplay.Selenium.Elements Classes ClassName Concrete implementation of Locator which locates elements by their HTML class attribute value. CssSelector Concrete implementation of Locator which locates elements by a CSS selector value. ElementId Concrete implementation of Locator which locates an element by its id attribute. Locator Base type for implementations of ITarget which serve as a specification for Selenium elements but which do not reference those elements directly. SeleniumElement An implementation of ITarget which represents a single native Selenium HTML element. SeleniumElementCollection An implementation of ITarget which represents a collection of native Selenium HTML elements. SeleniumElementExtensions Extension methods for SeleniumElement. TargetExtensions Extension methods for ITarget instances. TargetNotFoundException Thrown when GetElement(IWebDriver) is used, but no element can be found. XPath Concrete implementation of Locator which locates elements using an XPath query. Interfaces ICanReportForElement Similar to ICanReport but provides access to a Selenium element to augment the report data. ICanReportForElements Similar to ICanReport but provides access to a collection of Selenium elements to augment the report data. ITarget A target is an object which represents one or more HTML elements and which may serve as parameters for performables which interact with elements on the web page."
  },
  "api/CSF.Screenplay.Selenium.NamedScript-1.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScript-1.html",
    "title": "Class NamedScript<T1> | Screenplay",
    "summary": "Class NamedScript<T1> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 1 parameter and which returns no result. public class NamedScript<T1> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter Inheritance object NamedScriptBasis NamedScript<T1> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScript(string, string) Initialises a new instance of NamedScript. public NamedScript(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScript-2.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScript-2.html",
    "title": "Class NamedScript<T1, T2> | Screenplay",
    "summary": "Class NamedScript<T1, T2> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 2 parameters and which returns no result. public class NamedScript<T1, T2> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter T2 The type of the second parameter Inheritance object NamedScriptBasis NamedScript<T1, T2> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScript(string, string) Initialises a new instance of NamedScript. public NamedScript(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScript-3.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScript-3.html",
    "title": "Class NamedScript<T1, T2, T3> | Screenplay",
    "summary": "Class NamedScript<T1, T2, T3> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 3 parameters and which returns no result. public class NamedScript<T1, T2, T3> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter T2 The type of the second parameter T3 The type of the third parameter Inheritance object NamedScriptBasis NamedScript<T1, T2, T3> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScript(string, string) Initialises a new instance of NamedScript. public NamedScript(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScript-4.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScript-4.html",
    "title": "Class NamedScript<T1, T2, T3, T4> | Screenplay",
    "summary": "Class NamedScript<T1, T2, T3, T4> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 4 parameters and which returns no result. public class NamedScript<T1, T2, T3, T4> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter T2 The type of the second parameter T3 The type of the third parameter T4 The type of the fourth parameter Inheritance object NamedScriptBasis NamedScript<T1, T2, T3, T4> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScript(string, string) Initialises a new instance of NamedScript. public NamedScript(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScript-5.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScript-5.html",
    "title": "Class NamedScript<T1, T2, T3, T4, T5> | Screenplay",
    "summary": "Class NamedScript<T1, T2, T3, T4, T5> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 5 parameters and which returns no result. public class NamedScript<T1, T2, T3, T4, T5> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter T2 The type of the second parameter T3 The type of the third parameter T4 The type of the fourth parameter T5 The type of the fifth parameter Inheritance object NamedScriptBasis NamedScript<T1, T2, T3, T4, T5> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScript(string, string) Initialises a new instance of NamedScript. public NamedScript(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScript-6.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScript-6.html",
    "title": "Class NamedScript<T1, T2, T3, T4, T5, T6> | Screenplay",
    "summary": "Class NamedScript<T1, T2, T3, T4, T5, T6> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 6 parameters and which returns no result. public class NamedScript<T1, T2, T3, T4, T5, T6> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter T2 The type of the second parameter T3 The type of the third parameter T4 The type of the fourth parameter T5 The type of the fifth parameter T6 The type of the sixth parameter Inheritance object NamedScriptBasis NamedScript<T1, T2, T3, T4, T5, T6> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScript(string, string) Initialises a new instance of NamedScript. public NamedScript(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScript-7.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScript-7.html",
    "title": "Class NamedScript<T1, T2, T3, T4, T5, T6, T7> | Screenplay",
    "summary": "Class NamedScript<T1, T2, T3, T4, T5, T6, T7> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 7 parameters and which returns no result. public class NamedScript<T1, T2, T3, T4, T5, T6, T7> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter T2 The type of the second parameter T3 The type of the third parameter T4 The type of the fourth parameter T5 The type of the fifth parameter T6 The type of the sixth parameter T7 The type of the seventh parameter Inheritance object NamedScriptBasis NamedScript<T1, T2, T3, T4, T5, T6, T7> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScript(string, string) Initialises a new instance of NamedScript. public NamedScript(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScript.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScript.html",
    "title": "Class NamedScript | Screenplay",
    "summary": "Class NamedScript Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts no parameters and which returns no result. public class NamedScript : NamedScriptBasis, IHasName Inheritance object NamedScriptBasis NamedScript Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NamedScript(string, string) Initialises a new instance of NamedScript. public NamedScript(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScriptBasis.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScriptBasis.html",
    "title": "Class NamedScriptBasis | Screenplay",
    "summary": "Class NamedScriptBasis Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A basis class for named scripts, not for use in applications of Screenplay. public abstract class NamedScriptBasis : IHasName Inheritance object NamedScriptBasis Implements IHasName Derived NamedScript NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult> NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NamedScriptBasis(string, string) Initialises a new instance of NamedScriptBasis protected NamedScriptBasis(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. Properties Name Gets a human-readable name for this script, as would be displayed in a report. public string Name { get; } Property Value string ScriptBody Gets the body of the JavaScript. public string ScriptBody { get; } Property Value string"
  },
  "api/CSF.Screenplay.Selenium.NamedScriptWithResult-1.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScriptWithResult-1.html",
    "title": "Class NamedScriptWithResult<TResult> | Screenplay",
    "summary": "Class NamedScriptWithResult<TResult> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts no parameters, but which is expected to return a result. public class NamedScriptWithResult<TResult> : NamedScriptBasis, IHasName Type Parameters TResult The expected result/return type from the script Inheritance object NamedScriptBasis NamedScriptWithResult<TResult> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScriptWithResult(string, string) Initialises a new instance of NamedScriptWithResult<TResult>. public NamedScriptWithResult(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScriptWithResult-2.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScriptWithResult-2.html",
    "title": "Class NamedScriptWithResult<T1, TResult> | Screenplay",
    "summary": "Class NamedScriptWithResult<T1, TResult> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 1 parameter, but which is expected to return a result. public class NamedScriptWithResult<T1, TResult> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter TResult The expected result/return type from the script Inheritance object NamedScriptBasis NamedScriptWithResult<T1, TResult> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScriptWithResult(string, string) Initialises a new instance of NamedScriptWithResult<TResult>. public NamedScriptWithResult(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScriptWithResult-3.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScriptWithResult-3.html",
    "title": "Class NamedScriptWithResult<T1, T2, TResult> | Screenplay",
    "summary": "Class NamedScriptWithResult<T1, T2, TResult> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 2 parameters, but which is expected to return a result. public class NamedScriptWithResult<T1, T2, TResult> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter T2 The type of the second parameter TResult The expected result/return type from the script Inheritance object NamedScriptBasis NamedScriptWithResult<T1, T2, TResult> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScriptWithResult(string, string) Initialises a new instance of NamedScriptWithResult<TResult>. public NamedScriptWithResult(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScriptWithResult-4.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScriptWithResult-4.html",
    "title": "Class NamedScriptWithResult<T1, T2, T3, TResult> | Screenplay",
    "summary": "Class NamedScriptWithResult<T1, T2, T3, TResult> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 3 parameters, but which is expected to return a result. public class NamedScriptWithResult<T1, T2, T3, TResult> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter T2 The type of the second parameter T3 The type of the third parameter TResult The expected result/return type from the script Inheritance object NamedScriptBasis NamedScriptWithResult<T1, T2, T3, TResult> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScriptWithResult(string, string) Initialises a new instance of NamedScriptWithResult<TResult>. public NamedScriptWithResult(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScriptWithResult-5.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScriptWithResult-5.html",
    "title": "Class NamedScriptWithResult<T1, T2, T3, T4, TResult> | Screenplay",
    "summary": "Class NamedScriptWithResult<T1, T2, T3, T4, TResult> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 4 parameters, but which is expected to return a result. public class NamedScriptWithResult<T1, T2, T3, T4, TResult> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter T2 The type of the second parameter T3 The type of the third parameter T4 The type of the fourth parameter TResult The expected result/return type from the script Inheritance object NamedScriptBasis NamedScriptWithResult<T1, T2, T3, T4, TResult> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScriptWithResult(string, string) Initialises a new instance of NamedScriptWithResult<TResult>. public NamedScriptWithResult(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScriptWithResult-6.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScriptWithResult-6.html",
    "title": "Class NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> | Screenplay",
    "summary": "Class NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 5 parameters, but which is expected to return a result. public class NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter T2 The type of the second parameter T3 The type of the third parameter T4 The type of the fourth parameter T5 The type of the fifth parameter TResult The expected result/return type from the script Inheritance object NamedScriptBasis NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScriptWithResult(string, string) Initialises a new instance of NamedScriptWithResult<TResult>. public NamedScriptWithResult(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScriptWithResult-7.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScriptWithResult-7.html",
    "title": "Class NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> | Screenplay",
    "summary": "Class NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 6 parameters, but which is expected to return a result. public class NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter T2 The type of the second parameter T3 The type of the third parameter T4 The type of the fourth parameter T5 The type of the fifth parameter T6 The type of the sixth parameter TResult The expected result/return type from the script Inheritance object NamedScriptBasis NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScriptWithResult(string, string) Initialises a new instance of NamedScriptWithResult<TResult>. public NamedScriptWithResult(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedScriptWithResult-8.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedScriptWithResult-8.html",
    "title": "Class NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult> | Screenplay",
    "summary": "Class NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult> Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A model representing a pre-written piece of executable JavaScript, which accepts 7 parameters, but which is expected to return a result. public class NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult> : NamedScriptBasis, IHasName Type Parameters T1 The type of the first parameter T2 The type of the second parameter T3 The type of the third parameter T4 The type of the fourth parameter T5 The type of the fifth parameter T6 The type of the sixth parameter T7 The type of the seventh parameter TResult The expected result/return type from the script Inheritance object NamedScriptBasis NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult> Implements IHasName Inherited Members NamedScriptBasis.ScriptBody NamedScriptBasis.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Whilst the generic type parameters of this type have no direct bearing upon its members (such as properties), they are very useful when combined with the many overloads of the builder method ExecuteAScript in the PerformableBuilder class. Developers are encouraged to store JavaScripts in their apps/tests as instances of this type and other related types (see the \"See Also\" section). This improves the reusability of the script, improves its presence in Screenplay reports and provides type safety. For more information, see the named scripts article. For scripts which are created in this manner, getting an IPerformable or IPerformableWithResult<TResult> for those scripts is very easy and type safe. Use the ExecuteAScript method from the PerformableBuilder and the compiler will use generic type inference to select an appropriate overload. The parameters and return type will then be type-safe and of the appropriate number. Another benefit is that scripts defined and stored in instances of this type are reusable and easily catalogued. See the Scripts helper class for an example of a catalogue of script objects which may be executed. Once again, developers are encouraged to follow this pattern in their own applications/tests which use Screenplay & Selenium. Constructors NamedScriptWithResult(string, string) Initialises a new instance of NamedScriptWithResult<TResult>. public NamedScriptWithResult(string scriptBody, string name) Parameters scriptBody string The body of the JavaScript name string The human-readable name of the script Exceptions ArgumentException If either parameter is null or whitespace-only. See Also NamedScript NamedScript<T1> NamedScript<T1, T2> NamedScript<T1, T2, T3> NamedScript<T1, T2, T3, T4> NamedScript<T1, T2, T3, T4, T5> NamedScript<T1, T2, T3, T4, T5, T6> NamedScript<T1, T2, T3, T4, T5, T6, T7> NamedScriptWithResult<TResult> NamedScriptWithResult<T1, TResult> NamedScriptWithResult<T1, T2, TResult> NamedScriptWithResult<T1, T2, T3, TResult> NamedScriptWithResult<T1, T2, T3, T4, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult>"
  },
  "api/CSF.Screenplay.Selenium.NamedUri.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedUri.html",
    "title": "Class NamedUri | Screenplay",
    "summary": "Class NamedUri Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll Model containing a Uri with a corresponding human-readable name. public sealed class NamedUri : IHasName Inheritance object NamedUri Implements IHasName Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods NamedUriExtensions.RebaseTo(NamedUri, string) Remarks This model allows for the association of human-readable names with URIs. This is most useful when making use of Screenplay reports, where the human-readable name can be used to describe the URI in a more user-friendly way. Named Uris are used with the OpenUrl and OpenUrlRespectingBase performables to facilitate direct web browser navigation. Note the inclusion of implicit conversion operators which allow for seamless conversion from Uri and/or string instances to instances of this type. It is not recommended to use them, though, as neither supplies a name. This would mean that the naked Uri would appear in reports, instead of a human-readable name. If you have a need to switch environments at runtime, consider specifying named Uris using relative Uri fragments. This may be combined with the UseABaseUri ability to rebase the relative Uri onto a base Uri at runtime. This could be useful in testing, for example, whereby the same test suite must be run against a number of environments: Locally, on a developer's computer, with a base Uri such as https://localhost:8080/ On a testing environment, with a base Uri such as https://testing.example.com/ On a staging environment, with a base Uri such as https://staging.example.com/ Constructors NamedUri(string, string) Initializes a new instance of the NamedUri class. public NamedUri(string uri, string name = null) Parameters uri string The URI to associate with this instance. name string The human-readable name for the URI. If null, the URI string will be used as the name. NamedUri(Uri, string) Initializes a new instance of the NamedUri class. public NamedUri(Uri uri, string name = null) Parameters uri Uri The URI to associate with this instance. name string The human-readable name for the URI. If null, the URI string will be used as the name. Properties Name Gets the human-readable name for this Uri. public string Name { get; } Property Value string Uri Gets the Uri associated with this instance. public Uri Uri { get; } Property Value Uri Methods RebaseTo(Uri) Gets a copy of the current named URI, except 'rebased' using the specified base URI. public NamedUri RebaseTo(Uri baseUri) Parameters baseUri Uri A new base URI Returns NamedUri A URI which might have been rebased onto the new base URI Remarks If the current Uri is Absolute then this method has not effect and the named URI which is returned is the unmodified current instance. If the current Uri is not absolute, then the specified base URI is prepended to the current URI, serving as a base. The new URI is then returned from this method. Note that this method will never result in the current instance being mutated, at most it will only return a copy of the current instance, which has the newly-rebased URI. Operators implicit operator NamedUri(string) Converts a string to a NamedUri. public static implicit operator NamedUri(string uri) Parameters uri string The URI to convert. Returns NamedUri A new NamedUri instance. implicit operator NamedUri(Uri) Converts a Uri to a NamedUri. public static implicit operator NamedUri(Uri uri) Parameters uri Uri The URI to convert. Returns NamedUri A new NamedUri instance. See Also OpenUrl OpenUrlRespectingBase UseABaseUri"
  },
  "api/CSF.Screenplay.Selenium.NamedUriExtensions.html": {
    "href": "api/CSF.Screenplay.Selenium.NamedUriExtensions.html",
    "title": "Class NamedUriExtensions | Screenplay",
    "summary": "Class NamedUriExtensions Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll Extension methods for NamedUri. public static class NamedUriExtensions Inheritance object NamedUriExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods RebaseTo(NamedUri, string) Gets a copy of the current named URI, except 'rebased' using the specified base URI. public static NamedUri RebaseTo(this NamedUri namedUri, string baseUri) Parameters namedUri NamedUri The named URI to rebase baseUri string A new base URI Returns NamedUri A URI which might have been rebased onto the new base URI Remarks If the current Uri is Absolute then this method has not effect and the named URI which is returned is the unmodified current instance. If the current Uri is not absolute, then the specified base URI is prepended to the current URI, serving as a base. The new URI is then returned from this method. Note that this method will never result in the current instance being mutated, at most it will only return a copy of the current instance, which has the newly-rebased URI."
  },
  "api/CSF.Screenplay.Selenium.PerformableBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.PerformableBuilder.html",
    "title": "Class PerformableBuilder | Screenplay",
    "summary": "Class PerformableBuilder Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll Builder type for creating performables which interact with Selenium WebDriver via Screenplay. public static class PerformableBuilder Inheritance object PerformableBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Consume this class from your own Screenplay logic with using static CSF.Screenplay.Selenium.PerformableBuilder;. Methods ClearAllDomainCookies() Gets a performable action which clears all cookies for the current domain. public static IPerformable ClearAllDomainCookies() Returns IPerformable A performable action ClearLocalStorage() Gets a performable action which clears the local storage for the current domain. public static IPerformable ClearLocalStorage() Returns IPerformable A performable action ClearTheContentsOf(ITarget) Gets a performable action which clears the contents of the specified target element. public static IPerformable ClearTheContentsOf(ITarget target) Parameters target ITarget The target element whose contents will be cleared. Returns IPerformable A performable action ClickOn(ITarget) Gets a performable action which represents an actor clicking on a specified target element. public static ClickBuilder ClickOn(ITarget target) Parameters target ITarget The target element on which to click. Returns ClickBuilder A performable action DeleteTheCookieNamed(string) Gets a performable action which deletes a single named cookie. public static IPerformable DeleteTheCookieNamed(string cookieName) Parameters cookieName string Returns IPerformable A performable action DeselectEverythingFrom(ITarget) Gets a performable which represents an actor deselecting everything from a <select> element. public static IPerformable DeselectEverythingFrom(ITarget target) Parameters target ITarget A target which represents an HTML <select> element Returns IPerformable A performable action Remarks As might be expected, the target parameter must represent a <select> element or the resulting performable will raise an exception. DeselectTheOption(int) Gets a builder which will create a performable which represents an actor deselecting a specified option from a <select> element. public static FromTargetActionBuilder DeselectTheOption(int optionIndex) Parameters optionIndex int The zero-based index of an option to deselect Returns FromTargetActionBuilder A builder by which a target element is chosen Remarks This overload deselects the option by its zero-based index. As might be expected, the target which is specified in the builder must represent a <select> element or the resulting performable will raise an exception. DeselectTheOption(string) Gets a builder which will create a performable which represents an actor deselecting a specified option from a <select> element. public static FromTargetActionBuilder DeselectTheOption(string optionText) Parameters optionText string The text of the option to deselect Returns FromTargetActionBuilder A builder by which a target element is chosen Remarks This overload deselects the option by its displayed text. As might be expected, the target which is specified in the builder must represent a <select> element or the resulting performable will raise an exception. DeselectTheOptionWithValue(string) Gets a builder which will create a performable which represents an actor deselecting a specified option from a <select> element. public static FromTargetActionBuilder DeselectTheOptionWithValue(string optionValue) Parameters optionValue string The underlying value of the option to deselect Returns FromTargetActionBuilder A builder by which a target element is chosen Remarks This overload deselects the option by its underlying value attribute, instead of its displayed text. As might be expected, the target which is specified in the builder must represent a <select> element or the resulting performable will raise an exception. EnterTheDate(DateTime?) Gets a builder for creating a performable action which represents an actor entering a date into an <input type=\"date\"> element. public static EnterTheDateBuilder EnterTheDate(DateTime? date) Parameters date DateTime? The date to enter into the input control. Returns EnterTheDateBuilder A builder with which the user may select a target element and optionally a culture. Remarks If the specified date is null then the input element will be cleared. EnterTheText(params string[]) Gets a builder for creating a performable action which represents an actor typing text into a target element. public static SendKeysBuilder EnterTheText(params string[] text) Parameters text string[] The text/keys for the actor to type. Returns SendKeysBuilder A builder with which the user may select a target element. Remarks This may be used to send more than normal/printable text to the specified element. Special/nonprintable keys may be sent by using the OpenQA.Selenium.Keys class. For convenience, especially when using the Selenium Keys class mentioned above, this method accepts a params array of strings. If an array of strings is passed, they will be concatenated together before being sent to the element as a single string. The array/params syntax is used to allow a consumer to pass multiple strings (perhaps each only one character) as a single argument, without needing to manually concatenate them. ExecuteAScript(NamedScript) Gets a a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScript ExecuteAScript(NamedScript script) Parameters script NamedScript A named JavaScript. Returns ExecuteJavaScript A builder object Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<TResult>(NamedScriptWithResult<TResult>) Gets a a performable action which executes some JavaScript in the web browser, and gets the result returned by the script. public static ExecuteJavaScriptAndGetResult<TResult> ExecuteAScript<TResult>(NamedScriptWithResult<TResult> script) Parameters script NamedScriptWithResult<TResult> A named JavaScript. Returns ExecuteJavaScriptAndGetResult<TResult> A builder object Type Parameters TResult The expected return type of the script Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. ExecuteAScript<T1>(NamedScript<T1>, T1) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScript ExecuteAScript<T1>(NamedScript<T1> script, T1 p1) Parameters script NamedScript<T1> A named JavaScript. p1 T1 The value for the first script parameter. Returns ExecuteJavaScript A builder object Type Parameters T1 The type of script parameter 1 Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, TResult>(NamedScriptWithResult<T1, TResult>, T1) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScriptAndGetResult<TResult> ExecuteAScript<T1, TResult>(NamedScriptWithResult<T1, TResult> script, T1 p1) Parameters script NamedScriptWithResult<T1, TResult> A named JavaScript. p1 T1 The value for the first script parameter. Returns ExecuteJavaScriptAndGetResult<TResult> A builder object Type Parameters T1 The type of script parameter 1 TResult The expected return type of the script Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, T2>(NamedScript<T1, T2>, T1, T2) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScript ExecuteAScript<T1, T2>(NamedScript<T1, T2> script, T1 p1, T2 p2) Parameters script NamedScript<T1, T2> A named JavaScript. p1 T1 The value for the first script parameter. p2 T2 The value for the second script parameter. Returns ExecuteJavaScript A builder object Type Parameters T1 The type of script parameter 1 T2 The type of script parameter 2 Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, T2, TResult>(NamedScriptWithResult<T1, T2, TResult>, T1, T2) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScriptAndGetResult<TResult> ExecuteAScript<T1, T2, TResult>(NamedScriptWithResult<T1, T2, TResult> script, T1 p1, T2 p2) Parameters script NamedScriptWithResult<T1, T2, TResult> A named JavaScript. p1 T1 The value for the first script parameter. p2 T2 The value for the second script parameter. Returns ExecuteJavaScriptAndGetResult<TResult> A builder object Type Parameters T1 The type of script parameter 1 T2 The type of script parameter 2 TResult The expected return type of the script Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, T2, T3>(NamedScript<T1, T2, T3>, T1, T2, T3) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScript ExecuteAScript<T1, T2, T3>(NamedScript<T1, T2, T3> script, T1 p1, T2 p2, T3 p3) Parameters script NamedScript<T1, T2, T3> A named JavaScript. p1 T1 The value for the first script parameter. p2 T2 The value for the second script parameter. p3 T3 The value for the third script parameter. Returns ExecuteJavaScript A builder object Type Parameters T1 The type of script parameter 1 T2 The type of script parameter 2 T3 The type of script parameter 3 Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, T2, T3, TResult>(NamedScriptWithResult<T1, T2, T3, TResult>, T1, T2, T3) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScriptAndGetResult<TResult> ExecuteAScript<T1, T2, T3, TResult>(NamedScriptWithResult<T1, T2, T3, TResult> script, T1 p1, T2 p2, T3 p3) Parameters script NamedScriptWithResult<T1, T2, T3, TResult> A named JavaScript. p1 T1 The value for the first script parameter. p2 T2 The value for the second script parameter. p3 T3 The value for the third script parameter. Returns ExecuteJavaScriptAndGetResult<TResult> A builder object Type Parameters T1 The type of script parameter 1 T2 The type of script parameter 2 T3 The type of script parameter 3 TResult The expected return type of the script Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, T2, T3, T4>(NamedScript<T1, T2, T3, T4>, T1, T2, T3, T4) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScript ExecuteAScript<T1, T2, T3, T4>(NamedScript<T1, T2, T3, T4> script, T1 p1, T2 p2, T3 p3, T4 p4) Parameters script NamedScript<T1, T2, T3, T4> A named JavaScript. p1 T1 The value for the first script parameter. p2 T2 The value for the second script parameter. p3 T3 The value for the third script parameter. p4 T4 The value for the fourth script parameter. Returns ExecuteJavaScript A builder object Type Parameters T1 The type of script parameter 1 T2 The type of script parameter 2 T3 The type of script parameter 3 T4 The type of script parameter 4 Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, T2, T3, T4, TResult>(NamedScriptWithResult<T1, T2, T3, T4, TResult>, T1, T2, T3, T4) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScriptAndGetResult<TResult> ExecuteAScript<T1, T2, T3, T4, TResult>(NamedScriptWithResult<T1, T2, T3, T4, TResult> script, T1 p1, T2 p2, T3 p3, T4 p4) Parameters script NamedScriptWithResult<T1, T2, T3, T4, TResult> A named JavaScript. p1 T1 The value for the first script parameter. p2 T2 The value for the second script parameter. p3 T3 The value for the third script parameter. p4 T4 The value for the fourth script parameter. Returns ExecuteJavaScriptAndGetResult<TResult> A builder object Type Parameters T1 The type of script parameter 1 T2 The type of script parameter 2 T3 The type of script parameter 3 T4 The type of script parameter 4 TResult The expected return type of the script Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, T2, T3, T4, T5>(NamedScript<T1, T2, T3, T4, T5>, T1, T2, T3, T4, T5) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScript ExecuteAScript<T1, T2, T3, T4, T5>(NamedScript<T1, T2, T3, T4, T5> script, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) Parameters script NamedScript<T1, T2, T3, T4, T5> A named JavaScript. p1 T1 The value for the first script parameter. p2 T2 The value for the second script parameter. p3 T3 The value for the third script parameter. p4 T4 The value for the fourth script parameter. p5 T5 The value for the fifth script parameter. Returns ExecuteJavaScript A builder object Type Parameters T1 The type of script parameter 1 T2 The type of script parameter 2 T3 The type of script parameter 3 T4 The type of script parameter 4 T5 The type of script parameter 5 Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, T2, T3, T4, T5, TResult>(NamedScriptWithResult<T1, T2, T3, T4, T5, TResult>, T1, T2, T3, T4, T5) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScriptAndGetResult<TResult> ExecuteAScript<T1, T2, T3, T4, T5, TResult>(NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> script, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) Parameters script NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> A named JavaScript. p1 T1 The value for the first script parameter. p2 T2 The value for the second script parameter. p3 T3 The value for the third script parameter. p4 T4 The value for the fourth script parameter. p5 T5 The value for the fifth script parameter. Returns ExecuteJavaScriptAndGetResult<TResult> A builder object Type Parameters T1 The type of script parameter 1 T2 The type of script parameter 2 T3 The type of script parameter 3 T4 The type of script parameter 4 T5 The type of script parameter 5 TResult The expected return type of the script Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, T2, T3, T4, T5, T6>(NamedScript<T1, T2, T3, T4, T5, T6>, T1, T2, T3, T4, T5, T6) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScript ExecuteAScript<T1, T2, T3, T4, T5, T6>(NamedScript<T1, T2, T3, T4, T5, T6> script, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) Parameters script NamedScript<T1, T2, T3, T4, T5, T6> A named JavaScript. p1 T1 The value for the first script parameter. p2 T2 The value for the second script parameter. p3 T3 The value for the third script parameter. p4 T4 The value for the fourth script parameter. p5 T5 The value for the fifth script parameter. p6 T6 The value for the sixth script parameter. Returns ExecuteJavaScript A builder object Type Parameters T1 The type of script parameter 1 T2 The type of script parameter 2 T3 The type of script parameter 3 T4 The type of script parameter 4 T5 The type of script parameter 5 T6 The type of script parameter 6 Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, T2, T3, T4, T5, T6, TResult>(NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult>, T1, T2, T3, T4, T5, T6) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScriptAndGetResult<TResult> ExecuteAScript<T1, T2, T3, T4, T5, T6, TResult>(NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> script, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) Parameters script NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> A named JavaScript. p1 T1 The value for the first script parameter. p2 T2 The value for the second script parameter. p3 T3 The value for the third script parameter. p4 T4 The value for the fourth script parameter. p5 T5 The value for the fifth script parameter. p6 T6 The value for the sixth script parameter. Returns ExecuteJavaScriptAndGetResult<TResult> A builder object Type Parameters T1 The type of script parameter 1 T2 The type of script parameter 2 T3 The type of script parameter 3 T4 The type of script parameter 4 T5 The type of script parameter 5 T6 The type of script parameter 6 TResult The expected return type of the script Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, T2, T3, T4, T5, T6, T7>(NamedScript<T1, T2, T3, T4, T5, T6, T7>, T1, T2, T3, T4, T5, T6, T7) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScript ExecuteAScript<T1, T2, T3, T4, T5, T6, T7>(NamedScript<T1, T2, T3, T4, T5, T6, T7> script, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) Parameters script NamedScript<T1, T2, T3, T4, T5, T6, T7> A named JavaScript. p1 T1 The value for the first script parameter. p2 T2 The value for the second script parameter. p3 T3 The value for the third script parameter. p4 T4 The value for the fourth script parameter. p5 T5 The value for the fifth script parameter. p6 T6 The value for the sixth script parameter. p7 T7 The value for the seventh script parameter. Returns ExecuteJavaScript A builder object Type Parameters T1 The type of script parameter 1 T2 The type of script parameter 2 T3 The type of script parameter 3 T4 The type of script parameter 4 T5 The type of script parameter 5 T6 The type of script parameter 6 T7 The type of script parameter 7 Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteAScript<T1, T2, T3, T4, T5, T6, T7, TResult>(NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>, T1, T2, T3, T4, T5, T6, T7) Gets a performable action which executes some JavaScript in the web browser. public static ExecuteJavaScriptAndGetResult<TResult> ExecuteAScript<T1, T2, T3, T4, T5, T6, T7, TResult>(NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult> script, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) Parameters script NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult> A named JavaScript. p1 T1 The value for the first script parameter. p2 T2 The value for the second script parameter. p3 T3 The value for the third script parameter. p4 T4 The value for the fourth script parameter. p5 T5 The value for the fifth script parameter. p6 T6 The value for the sixth script parameter. p7 T7 The value for the seventh script parameter. Returns ExecuteJavaScriptAndGetResult<TResult> A builder object Type Parameters T1 The type of script parameter 1 T2 The type of script parameter 2 T3 The type of script parameter 3 T4 The type of script parameter 4 T5 The type of script parameter 5 T6 The type of script parameter 6 T7 The type of script parameter 7 TResult The expected return type of the script Remarks This is the recommended way to execute JavaScript in the browser. Use of the NamedScript, NamedScriptWithResult<TResult> and their other related generic types provides a simple type-safe mechanism of executing scripts. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteCustomScript(string) Gets a builder for a performable action which executes some arbitrary JavaScript in the web browser. public static ExecuteJavaScriptBuilder ExecuteCustomScript(string scriptBody) Parameters scriptBody string The body of the JavaScript to execute. Returns ExecuteJavaScriptBuilder A builder object Remarks This method may be used for building an arbitrary script, but where possible it is recommended to use one of the overloads of ExecuteAScript(NamedScript). These methods accept either a NamedScript, a NamedScriptWithResult<TResult>, or one of their other related generic types. These overloads provide type safety for parameters, return types, and ensure that the name of the script is pre-specified at design time. Scripts executed with this method are not expected to return a result. If they do, their result is discarded and unused. ExecuteCustomScriptWithResult<TResult>(string) Gets a builder for a performable action which executes some JavaScript in the web browser and returns a result from that script. public static ExecuteJavaScriptBuilderWithResult<TResult> ExecuteCustomScriptWithResult<TResult>(string scriptBody) Parameters scriptBody string The body of the JavaScript to execute. Returns ExecuteJavaScriptBuilderWithResult<TResult> A builder object Type Parameters TResult Remarks This action is for executing a script which is expected to return a result. This method may be used for building an arbitrary script, but where possible it is recommended to use one of the overloads of this method which accepts either a NamedScript, a NamedScriptWithResult<TResult>, or one of their other related generic types. These overloads provide type safety for parameters, return types, and ensure that the name of the script is pre-specified at design time. Filter(SeleniumElementCollection) Gets a builder which may be used to create a performable question which filters a collection of elements for those which match a specification. public static FilterElementsBuilder Filter(SeleniumElementCollection elements) Parameters elements SeleniumElementCollection The collection of elements to filter. Returns FilterElementsBuilder A builder with which consuming logic must provide a specification. Examples Here is a sample usage which combines both the QueryPredicatePrototypeBuilder and FilterElementsBuilder classes: using static CSF.Screenplay.Selenium.PerformableBuilder; var buyNowButtons = await actor.PerformAsync(Filter(someElements).ForThoseWhich(have => have.Clickability(true).And(have.Text(\"Buy now\")), cancellationToken); The code sample above assumes that actor is an instance of ICanPerform, that someElements is a collection of SeleniumElement instances, and that cancellationToken is a CancellationToken instance. It would filter the elements in someElements to only those which are clickable and have the text \"Buy now\". See Also FilterElementsBuilder QueryPredicatePrototypeBuilder FindAnElementOnThePage() Gets a builder which may be used to create a performable action which finds a single element within the body of the page. public static FindElementBuilder FindAnElementOnThePage() Returns FindElementBuilder A builder, which may be used to configure/get a question that finds an element Remarks If you want to find an element which is a descendent of a specified target, consider using FindAnElementWithin(ITarget) instead. FindAnElementWithin(ITarget) Gets a builder which may be used to create a performable action which finds a single element within a specified target. public static FindElementBuilder FindAnElementWithin(ITarget target) Parameters target ITarget The target within which to find HTML elements Returns FindElementBuilder A builder, which may be used to configure/get a question that finds an element Remarks If you only want to find an element within the <body> element of the page, consider using FindAnElementOnThePage() instead. FindElementsOnThePage() Gets a builder which may be used to create a performable action which finds a collection of elements within the body of the page. public static FindElementsBuilder FindElementsOnThePage() Returns FindElementsBuilder A builder, which may be used to configure/get a question that finds elements Remarks If you want to find elements which are descendents of a specified target, consider using FindElementsWithin(ITarget) instead. FindElementsWithin(ITarget) Gets a builder which may be used to create a performable action which finds a collection of elements within a specified target. public static FindElementsBuilder FindElementsWithin(ITarget target) Parameters target ITarget The target within which to find HTML elements Returns FindElementsBuilder A builder, which may be used to configure/get a question that finds elements Remarks If you only want to find elements within the <body> element of the page, consider using FindElementsOnThePage() instead. OpenTheUrl(NamedUri) Gets a performable action which opens a URL. public static IPerformable OpenTheUrl(NamedUri uri) Parameters uri NamedUri The uri at which to open the web browser. Returns IPerformable A performable Remarks If the specified Uri is a relative Uri, then this task will use the actor's UseABaseUri ability (if present) to transform the relative Uri into an absolute one. The specified Uri will be used directly if it is already absolute. ReadFromTheCollectionOfElements(ITarget) Gets a builder which may be used to create a performable question which reads a collection of the same information from a collection of elements. public static QuestionMultiQueryBuilder ReadFromTheCollectionOfElements(ITarget element) Parameters element ITarget The elements to interrogate for values. Returns QuestionMultiQueryBuilder A builder which chooses the query Remarks This question makes use of an IQuery<T> to interrogate each element element in the collection and return a series of corresponding values. ReadFromTheElement(ITarget) Gets a builder which may be used to create a performable question which reads a piece of information from a single element. public static QuestionQueryBuilder ReadFromTheElement(ITarget element) Parameters element ITarget The element to interrogate for a value. Returns QuestionQueryBuilder A builder which chooses the query Remarks This question makes use of an IQuery<T> to interrogate a single element and return a value. ReadTheWindowTitle() Gets a performable question which reads the title of the current browser window. public static GetWindowTitle ReadTheWindowTitle() Returns GetWindowTitle A performable question. SaveTheScreenshot(Screenshot) Gets a performable action which saves a screenshot to a file. public static SaveScreenshotBuilder SaveTheScreenshot(Screenshot screenshot) Parameters screenshot Screenshot The Selenium screenshot instance Returns SaveScreenshotBuilder A performable Remarks This method returns a builder object which may be used to specify a short name for the screenshot. This allows it to be quickly identified in the report. If you only want to take a screenshot and save it as an asset file, please consider TakeAndSaveAScreenshot() instead of this method. SelectTheOption(int) Gets a builder which will create a performable which represents an actor selecting a specified option from a <select> element. public static FromTargetActionBuilder SelectTheOption(int optionIndex) Parameters optionIndex int The zero-based index of an option to select Returns FromTargetActionBuilder A builder by which a target element is chosen Remarks This overload selects the option by its zero-based index. As might be expected, the target which is specified in the builder must represent a <select> element or the resulting performable will raise an exception. SelectTheOption(string) Gets a builder which will create a performable which represents an actor selecting a specified option from a <select> element. public static FromTargetActionBuilder SelectTheOption(string optionText) Parameters optionText string The text of the option to select Returns FromTargetActionBuilder A builder by which a target element is chosen Remarks This overload selects the option by its displayed text. As might be expected, the target which is specified in the builder must represent a <select> element or the resulting performable will raise an exception. SelectTheOptionWithValue(string) Gets a builder which will create a performable which represents an actor selecting a specified option from a <select> element. public static FromTargetActionBuilder SelectTheOptionWithValue(string optionValue) Parameters optionValue string The underlying value of the option to select Returns FromTargetActionBuilder A builder by which a target element is chosen Remarks This overload selects the option by its underlying value attribute, instead of its displayed text. As might be expected, the target which is specified in the builder must represent a <select> element or the resulting performable will raise an exception. SetTheValueOf(ITarget) Gets a builder for an action which sets the value of an element programatically, using JavaScript. public static SetTheValueBuilder.IChoosesValue SetTheValueOf(ITarget target) Parameters target ITarget The target HTML element, to have its value updated. Returns SetTheValueBuilder.IChoosesValue A builder with which to choose the new value Remarks It is advised to use this technique and others like it sparingly, particularly when using Screenplay/Selenium for testing. Whilst it is possible to set values and update the web page's state via JavaScript, this does not properly mimic the manner in which a real human being would interact with the page. TakeAScreenshot() Gets a performable question which takes a screenshot of the current web page and returns it. public static IPerformableWithResult<Screenshot> TakeAScreenshot() Returns IPerformableWithResult<Screenshot> A performable Remarks If you only want to take a screenshot and save it as an asset file, please consider TakeAndSaveAScreenshot() instead of this method. This method will raise an exception if the WebDriver is not capable of taking screenshots. If you want to avoid this, consider using TakeAScreenshotIfSupported() instead. TakeAScreenshotIfSupported() Gets a performable question which takes a screenshot of the current web page and returns it, if the WebDriver is capable of doing so. public static IPerformableWithResult<Screenshot> TakeAScreenshotIfSupported() Returns IPerformableWithResult<Screenshot> A performable Remarks If you only want to take a screenshot and save it as an asset file, please consider TakeAndSaveAScreenshot() instead of this method. This method will not raise an exception if the WebDriver is not capable of taking screenshots. Instead, it will return a value task of null. If you wish to use a performable which will raise an exception if the WebDriver is not capable of taking screenshots, consider using TakeAScreenshot() instead. TakeAndSaveAScreenshot() Gets a performable taek which takes a screenshot and saves it to a file, using an optional short name. public static TakeAndSaveScreenshotBuilder TakeAndSaveAScreenshot() Returns TakeAndSaveScreenshotBuilder A performable Remarks This method may be used to specify a short name for the screenshot. This allows it to be quickly identified in the report. This method will raise an exception if the WebDriver is not capable of taking screenshots. If you want to avoid this, consider using TakeAndSaveAScreenshotIfSupported() instead. TakeAndSaveAScreenshotIfSupported() Gets a performable taek which takes a screenshot and saves it to a file, using an optional short name. public static TakeAndSaveScreenshotBuilder TakeAndSaveAScreenshotIfSupported() Returns TakeAndSaveScreenshotBuilder A performable Remarks This method may be used to specify a short name for the screenshot. This allows it to be quickly identified in the report. This method will not raise an exception if the WebDriver is not capable of taking screenshots. Instead, it will do nothing. If you wish to use a performable which will raise an exception if the WebDriver is not capable of taking screenshots, consider using TakeAndSaveAScreenshot() instead. WaitFor(TimeSpan) Gets a performable action that waits for a specified amount of time. public static WaitForSomeTime WaitFor(TimeSpan duration) Parameters duration TimeSpan The duration for which to wait. Returns WaitForSomeTime A performable action. Remarks This kind of wait waits for a specified time. If you want to wait until a condition is met, consider using either WaitUntil(Func<IWebDriver, bool>) or WaitUntil(IBuildsElementPredicates) instead. WaitUntil(IBuildsElementPredicates) Gets a builder which will create a performable question that waits until a predicate returns a successful result. public static NamedWaitBuilder WaitUntil(IBuildsElementPredicates predicate) Parameters predicate IBuildsElementPredicates A predicate which, when it returns a successful result, the wait is over. Returns NamedWaitBuilder A builder for creating a wait action. Remarks The prupose of waiting in this manner is to wait for something to happen on the web page, such as an element being present, or having content that matches a specification. The builder object returned by this method has a number of optional configuration methods. Create the predicate paramater value by using one of the following extension methods. These extension methods provide a fluent interface to create a predicate for one or more elements (described by a single ITarget), as well as providing a human-readable name for the predicate. Has(ITarget) AllHave(ITarget) Exceptions ArgumentNullException Thrown if the predicate is null. ArgumentException Thrown if the result type of the predicate is a value type other than boolean. WaitUntil(Func<IWebDriver, bool>) Gets a builder which will create a performable question that waits until a predicate returns a true result. public static UnnamedWaitBuilder WaitUntil(Func<IWebDriver, bool> predicate) Parameters predicate Func<IWebDriver, bool> A predicate which, when it returns a true result, the wait is over. Returns UnnamedWaitBuilder A builder for creating a wait action. Remarks The purpose of waiting in this manner is to wait for something to happen on the web page, such as an element being present, or having content that matches a specification. The builder object returned by this method has a number of optional configuration methods. Of these, consumers are strongly encouraged to use Named(string) to give the wait action a short, descriptive name which will appear in reports. Take note that it is very normal for the predicate to make use of closures to access elements from outside its own scope. For example, the predicate function may refer to an element which is referenced by a variable in the calling method. Where possible, consider using the other overload of this method: WaitUntil(IBuildsElementPredicates), as it provides a more fluent interface for describing the predicate. This overload is provided only for scenarios in which the predicate to end the wait is too complex to be easily expressed using the fluent interface. Exceptions ArgumentNullException Thrown if the predicate is null. ArgumentException Thrown if the result type of the predicate is a value type other than boolean."
  },
  "api/CSF.Screenplay.Selenium.Queries.AttributeQuery.html": {
    "href": "api/CSF.Screenplay.Selenium.Queries.AttributeQuery.html",
    "title": "Class AttributeQuery | Screenplay",
    "summary": "Class AttributeQuery Namespace CSF.Screenplay.Selenium.Queries Assembly CSF.Screenplay.Selenium.dll A query to get the value of a specified HTML attribute from a Selenium element. public class AttributeQuery : IQuery<string>, IHasName Inheritance object AttributeQuery Implements IQuery<string> IHasName Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors AttributeQuery(string) Initializes a new instance of the AttributeQuery class with the specified attribute name. public AttributeQuery(string attributeName) Parameters attributeName string The name of the HTML attribute to query. Properties Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Methods GetValue(SeleniumElement) Gets the current value from a Selenium element. public string GetValue(SeleniumElement element) Parameters element SeleniumElement The Selenium element. Returns string The value of type string."
  },
  "api/CSF.Screenplay.Selenium.Queries.ClickableQuery.html": {
    "href": "api/CSF.Screenplay.Selenium.Queries.ClickableQuery.html",
    "title": "Class ClickableQuery | Screenplay",
    "summary": "Class ClickableQuery Namespace CSF.Screenplay.Selenium.Queries Assembly CSF.Screenplay.Selenium.dll Represents a query to determine if a Selenium element is clickable. public class ClickableQuery : IQuery<bool>, IHasName Inheritance object ClickableQuery Implements IQuery<bool> IHasName Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Methods GetValue(SeleniumElement) Gets the current value from a Selenium element. public bool GetValue(SeleniumElement element) Parameters element SeleniumElement The Selenium element. Returns bool The value of type bool."
  },
  "api/CSF.Screenplay.Selenium.Queries.CssPropertyQuery.html": {
    "href": "api/CSF.Screenplay.Selenium.Queries.CssPropertyQuery.html",
    "title": "Class CssPropertyQuery | Screenplay",
    "summary": "Class CssPropertyQuery Namespace CSF.Screenplay.Selenium.Queries Assembly CSF.Screenplay.Selenium.dll A query to get the value of a specified CSS property from a Selenium element. public class CssPropertyQuery : IQuery<string>, IHasName Inheritance object CssPropertyQuery Implements IQuery<string> IHasName Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CssPropertyQuery(string) Initializes a new instance of the CssPropertyQuery class with the specified property name. public CssPropertyQuery(string propertyName) Parameters propertyName string The name of the CSS property to query. Properties Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Methods GetValue(SeleniumElement) Gets the current value from a Selenium element. public string GetValue(SeleniumElement element) Parameters element SeleniumElement The Selenium element. Returns string The value of type string."
  },
  "api/CSF.Screenplay.Selenium.Queries.IQuery-1.html": {
    "href": "api/CSF.Screenplay.Selenium.Queries.IQuery-1.html",
    "title": "Interface IQuery<T> | Screenplay",
    "summary": "Interface IQuery<T> Namespace CSF.Screenplay.Selenium.Queries Assembly CSF.Screenplay.Selenium.dll An object which can get a value from a Selenium element. public interface IQuery<out T> : IHasName Type Parameters T The type of the value returned. Inherited Members IHasName.Name Remarks Each implementation of IQuery<T> is responsible for getting a specific kind of value from a Selenium element. Methods GetValue(SeleniumElement) Gets the current value from a Selenium element. T GetValue(SeleniumElement element) Parameters element SeleniumElement The Selenium element. Returns T The value of type T."
  },
  "api/CSF.Screenplay.Selenium.Queries.LocationQuery.html": {
    "href": "api/CSF.Screenplay.Selenium.Queries.LocationQuery.html",
    "title": "Class LocationQuery | Screenplay",
    "summary": "Class LocationQuery Namespace CSF.Screenplay.Selenium.Queries Assembly CSF.Screenplay.Selenium.dll A query to get the location of the top-left corner of a Selenium element. public class LocationQuery : IQuery<Point>, IHasName Inheritance object LocationQuery Implements IQuery<Point> IHasName Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Methods GetValue(SeleniumElement) Gets the current value from a Selenium element. public Point GetValue(SeleniumElement element) Parameters element SeleniumElement The Selenium element. Returns Point The value of type Point."
  },
  "api/CSF.Screenplay.Selenium.Queries.Option.html": {
    "href": "api/CSF.Screenplay.Selenium.Queries.Option.html",
    "title": "Class Option | Screenplay",
    "summary": "Class Option Namespace CSF.Screenplay.Selenium.Queries Assembly CSF.Screenplay.Selenium.dll Represents a single HTML <option> element within an HTML <select> element. public sealed class Option : IEquatable<Option>, IHasName Inheritance object Option Implements IEquatable<Option> IHasName Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Option(string, string) Initializes a new instance of the Option class with the specified text and value. public Option(string text, string value) Parameters text string The displayed text of the option. value string The underlying value of the option. Properties Text Gets the option's displayed text. public string Text { get; } Property Value string Value Gets the option's underlying value. public string Value { get; } Property Value string Methods Equals(Option) public bool Equals(Option other) Parameters other Option Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string"
  },
  "api/CSF.Screenplay.Selenium.Queries.OptionsQuery.html": {
    "href": "api/CSF.Screenplay.Selenium.Queries.OptionsQuery.html",
    "title": "Class OptionsQuery | Screenplay",
    "summary": "Class OptionsQuery Namespace CSF.Screenplay.Selenium.Queries Assembly CSF.Screenplay.Selenium.dll A query to get the options within a <select> element. public class OptionsQuery : IQuery<IReadOnlyList<Option>>, IHasName Inheritance object OptionsQuery Implements IQuery<IReadOnlyList<Option>> IHasName Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks If the queried element is not an HTML <select> element then the outcome of this query is undefined. Constructors OptionsQuery(bool, bool) Initializes a new instance of the OptionsQuery class. public OptionsQuery(bool excludeSelectedOptions = false, bool excludeUnselectedOptions = false) Parameters excludeSelectedOptions bool If set to true, then options which are currently selected will not be included in the output. excludeUnselectedOptions bool If set to true, then options which are currently not selected will not be included in the output. Properties Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Methods GetValue(SeleniumElement) Gets the current value from a Selenium element. public IReadOnlyList<Option> GetValue(SeleniumElement element) Parameters element SeleniumElement The Selenium element. Returns IReadOnlyList<Option> The value of type IReadOnlyList<Option>."
  },
  "api/CSF.Screenplay.Selenium.Queries.SizeQuery.html": {
    "href": "api/CSF.Screenplay.Selenium.Queries.SizeQuery.html",
    "title": "Class SizeQuery | Screenplay",
    "summary": "Class SizeQuery Namespace CSF.Screenplay.Selenium.Queries Assembly CSF.Screenplay.Selenium.dll A query to get the pixel size a Selenium element. public class SizeQuery : IQuery<Size>, IHasName Inheritance object SizeQuery Implements IQuery<Size> IHasName Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Methods GetValue(SeleniumElement) Gets the current value from a Selenium element. public Size GetValue(SeleniumElement element) Parameters element SeleniumElement The Selenium element. Returns Size The value of type Size."
  },
  "api/CSF.Screenplay.Selenium.Queries.TextQuery.html": {
    "href": "api/CSF.Screenplay.Selenium.Queries.TextQuery.html",
    "title": "Class TextQuery | Screenplay",
    "summary": "Class TextQuery Namespace CSF.Screenplay.Selenium.Queries Assembly CSF.Screenplay.Selenium.dll A query to get the text content of a Selenium element. public class TextQuery : IQuery<string>, IHasName Inheritance object TextQuery Implements IQuery<string> IHasName Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks When reading text from the web browser, depending upon the whitespace-trimming parameter, this query will or will not trim leading/trailing whitespace. This functionality is present because some browsers (Safari) include whitespace at the beginning/end of text read from the browser which isn't visible to the end user. This is typically the space which is inherent in the markup, but which browsers ignore when actually displaying content. Other WebDriver implementations do not include this leading/trailing whitespace. When whitespace is trimmed, this provides a more consistent cross-browser experience when reading the text of an element. The consequence is that sometimes, when reading leading/trailing whitespace is intended, we must pass a different parameter value. Constructors TextQuery(bool) Initializes a new instance of the TextQuery class. public TextQuery(bool trimWhitespace = true) Parameters trimWhitespace bool If true, leading & trailing whitespace will be trimmed from the returned text content; if true it will not. Properties Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Methods GetValue(SeleniumElement) Gets the current value from a Selenium element. public string GetValue(SeleniumElement element) Parameters element SeleniumElement The Selenium element. Returns string The value of type string. See Also TheText() TheTextWithoutTrimmingWhitespace() Text(string) Text(Func<string, bool>) TextWithoutTrimmingWhitespace(string) TextWithoutTrimmingWhitespace(Func<string, bool>)"
  },
  "api/CSF.Screenplay.Selenium.Queries.ValueQuery.html": {
    "href": "api/CSF.Screenplay.Selenium.Queries.ValueQuery.html",
    "title": "Class ValueQuery | Screenplay",
    "summary": "Class ValueQuery Namespace CSF.Screenplay.Selenium.Queries Assembly CSF.Screenplay.Selenium.dll A query to get the value of the value attribute of a Selenium element. public class ValueQuery : IQuery<string>, IHasName Inheritance object ValueQuery Implements IQuery<string> IHasName Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Methods GetValue(SeleniumElement) Gets the current value from a Selenium element. public string GetValue(SeleniumElement element) Parameters element SeleniumElement The Selenium element. Returns string The value of type string."
  },
  "api/CSF.Screenplay.Selenium.Queries.VisibilityQuery.html": {
    "href": "api/CSF.Screenplay.Selenium.Queries.VisibilityQuery.html",
    "title": "Class VisibilityQuery | Screenplay",
    "summary": "Class VisibilityQuery Namespace CSF.Screenplay.Selenium.Queries Assembly CSF.Screenplay.Selenium.dll A query to get the visibility of a Selenium element. public class VisibilityQuery : IQuery<bool>, IHasName Inheritance object VisibilityQuery Implements IQuery<bool> IHasName Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This query will have a value of true if the element is visible on the web page; false if it is not. Properties Name Gets the human-readable name of the current object. public string Name { get; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Methods GetValue(SeleniumElement) Gets the current value from a Selenium element. public bool GetValue(SeleniumElement element) Parameters element SeleniumElement The Selenium element. Returns bool The value of type bool."
  },
  "api/CSF.Screenplay.Selenium.Queries.html": {
    "href": "api/CSF.Screenplay.Selenium.Queries.html",
    "title": "Namespace CSF.Screenplay.Selenium.Queries | Screenplay",
    "summary": "Namespace CSF.Screenplay.Selenium.Queries Classes AttributeQuery A query to get the value of a specified HTML attribute from a Selenium element. ClickableQuery Represents a query to determine if a Selenium element is clickable. CssPropertyQuery A query to get the value of a specified CSS property from a Selenium element. LocationQuery A query to get the location of the top-left corner of a Selenium element. Option Represents a single HTML <option> element within an HTML <select> element. OptionsQuery A query to get the options within a <select> element. SizeQuery A query to get the pixel size a Selenium element. TextQuery A query to get the text content of a Selenium element. ValueQuery A query to get the value of the value attribute of a Selenium element. VisibilityQuery A query to get the visibility of a Selenium element. Interfaces IQuery<T> An object which can get a value from a Selenium element."
  },
  "api/CSF.Screenplay.Selenium.Questions.ElementCollectionPerformableWithResultAdapter-1.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.ElementCollectionPerformableWithResultAdapter-1.html",
    "title": "Class ElementCollectionPerformableWithResultAdapter<TResult> | Screenplay",
    "summary": "Class ElementCollectionPerformableWithResultAdapter<TResult> Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll Adapter class which allows a IElementCollectionPerformableWithResult<TResult> to be used as an IPerformableWithResult<TResult>. public class ElementCollectionPerformableWithResultAdapter<TResult> : IPerformableWithResult<IReadOnlyList<TResult>>, ICanReport Type Parameters TResult Inheritance object ElementCollectionPerformableWithResultAdapter<TResult> Implements IPerformableWithResult<IReadOnlyList<TResult>> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This adapter class is provided as a convenience to perform some of the boilerplate logic required to scaffold the parameters required by IElementCollectionPerformableWithResult<TResult>. This method also caches the SeleniumElementCollection which is returned by the ITarget, avoiding the need to fetch it using the WebDriver more than once. As such, instances of this adapter (like all performables) should not be re-used. Constructors ElementCollectionPerformableWithResultAdapter(IElementCollectionPerformableWithResult<TResult>, ITarget) Initializes a new instance of the ElementCollectionPerformableWithResultAdapter<TResult> class with the specified performable and target. public ElementCollectionPerformableWithResultAdapter(IElementCollectionPerformableWithResult<TResult> performable, ITarget target) Parameters performable IElementCollectionPerformableWithResult<TResult> The performable to be adapted. target ITarget A target which describes the elements for the performable. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<IReadOnlyList<TResult>> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<IReadOnlyList<TResult>> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Selenium.Questions.ElementCollectionPerformableWithResultAdapter.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.ElementCollectionPerformableWithResultAdapter.html",
    "title": "Class ElementCollectionPerformableWithResultAdapter | Screenplay",
    "summary": "Class ElementCollectionPerformableWithResultAdapter Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll Static helper methods for creating instances of ElementCollectionPerformableWithResultAdapter<TResult>. public static class ElementCollectionPerformableWithResultAdapter Inheritance object ElementCollectionPerformableWithResultAdapter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods From<TResult>(IElementCollectionPerformableWithResult<TResult>, ITarget) Creates a new instance of ElementCollectionPerformableWithResultAdapter<TResult> from the specified performable and target. public static ElementCollectionPerformableWithResultAdapter<TResult> From<TResult>(IElementCollectionPerformableWithResult<TResult> performable, ITarget target) Parameters performable IElementCollectionPerformableWithResult<TResult> The performable to be adapted. target ITarget The target elements for the performable. Returns ElementCollectionPerformableWithResultAdapter<TResult> A new instance of ElementCollectionPerformableWithResultAdapter<TResult>. Type Parameters TResult The type of the result."
  },
  "api/CSF.Screenplay.Selenium.Questions.ElementCollectionQuery-1.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.ElementCollectionQuery-1.html",
    "title": "Class ElementCollectionQuery<TResult> | Screenplay",
    "summary": "Class ElementCollectionQuery<TResult> Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll A question which reads or observes the state from a collection of HTML elements and returns the results. public class ElementCollectionQuery<TResult> : IElementCollectionPerformableWithResult<TResult>, ICanReportForElements Type Parameters TResult The type of the result returned by the query. Inheritance object ElementCollectionQuery<TResult> Implements IElementCollectionPerformableWithResult<TResult> ICanReportForElements Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example gets the text of every list item which has the class todo. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget todoItems = new CssSelector(\"li.todo\", \"the todo items\"); // Within the logic of a custom task, deriving from IPerformableWithResult<IReadOnlyList<string>> public async ValueTask<IReadOnlyList<string>> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic var texts = await actor.PerformAsync(ReadFromTheCollectionOfElements(todoItems).Text(), cancellationToken); // ... other performance logic return texts; } Remarks Use this question via the builder method ReadFromTheCollectionOfElements(ITarget). The builder will then guide you through inspecting the state of the targets. The corresponding state information from each of the elements which are found by the target will be returned as the result of this question. Crucially, to decide which piece of information to retrieve from the target elements, you will build and use a Query. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElementCollection which it queries. It has this in common with a number of Screenplay questions in the Selenium Plugin which observe collections of elements, those which derive from IElementCollectionPerformableWithResult<TResult>. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of ElementCollectionPerformableWithResultAdapter<TResult>. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element Collection. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Constructors ElementCollectionQuery(IQuery<TResult>) Initializes a new instance of the ElementCollectionQuery<TResult> class with the specified query. public ElementCollectionQuery(IQuery<TResult> query) Parameters query IQuery<TResult> The query to be used for retrieving the value from each Selenium element. Methods GetReportFragment(Actor, Lazy<SeleniumElementCollection>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element collection. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElementCollection> elements, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment elements Lazy<SeleniumElementCollection> The Selenium elements for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElementCollection>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask<IReadOnlyList<TResult>> PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElementCollection> elements, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. elements Lazy<SeleniumElementCollection> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<IReadOnlyList<TResult>> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete. See Also ReadFromTheCollectionOfElements(ITarget)"
  },
  "api/CSF.Screenplay.Selenium.Questions.ElementCollectionQuery.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.ElementCollectionQuery.html",
    "title": "Class ElementCollectionQuery | Screenplay",
    "summary": "Class ElementCollectionQuery Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll Provides a factory method for creating instances of ElementCollectionQuery<TResult>. public static class ElementCollectionQuery Inheritance object ElementCollectionQuery Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods From<TResult>(IQuery<TResult>) Creates a new instance of ElementCollectionQuery<TResult> with the specified query. public static ElementCollectionQuery<TResult> From<TResult>(IQuery<TResult> query) Parameters query IQuery<TResult> The query to be used for retrieving the value from each Selenium element. Returns ElementCollectionQuery<TResult> A new instance of SingleElementQuery<TResult>. Type Parameters TResult The type of the result returned by the query."
  },
  "api/CSF.Screenplay.Selenium.Questions.ExecuteJavaScriptAndGetResult-1.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.ExecuteJavaScriptAndGetResult-1.html",
    "title": "Class ExecuteJavaScriptAndGetResult<TResult> | Screenplay",
    "summary": "Class ExecuteJavaScriptAndGetResult<TResult> Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll A question which executes some arbitrary JavaScript in the web browser and returns the result returned by that script. public class ExecuteJavaScriptAndGetResult<TResult> : IPerformableWithResult<TResult>, ICanReport Type Parameters TResult The expected type of the result from the script Inheritance object ExecuteJavaScriptAndGetResult<TResult> Implements IPerformableWithResult<TResult> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples In this example, the script will return the integer value 10 to the performance. using static CSF.Screenplay.Selenium.PerformableBuilder; var addFour = new NamedScriptWithResult<int, int>(\"4 + arguments[0]\", \"add four\"); // Within the logic of a custom task, deriving from IPerformableWithResult<int> public async ValueTask<int> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { return await actor.PerformAsync(ExecuteAScript(addFour, 6), cancellationToken); } Remarks The best way to use this action is via the builder method ExecuteAScript<TResult>(NamedScriptWithResult<TResult>) or one of its same-named overloads. The NamedScriptWithResult<TResult> class, and its counterparts with additional generic type parameters, provide a manner in which scripts to be executed by this action may be stored within the application or test logic, providing type safety for their parameters and return value. Performing this action, as an actor which has the BrowseTheWeb ability, sends the body of the script and its parameter values to the web browser and executes it. This is roughly equivalent to a user opening the developer tools Console, typing the script and its parameters there, and pressing enter, then reading the result which is returned by the console. This action returns the from the script back to the IPerformance. If the result is unimportant or you wish to execute a script which does not return a result then use ExecuteJavaScript instead. Within the script body, any parameters are accessible via the arguments object. That object exposes the parameter values by their zero-based index (position) in the parameters list. So, a script which takes three parameters will expose these to the script as arguments[0], arguments[1] and arguments[2], respectively for the first, second and third parameter values. Constructors ExecuteJavaScriptAndGetResult(string, string, params object[]) Initialises a new instance of ExecuteJavaScriptAndGetResult<TResult>. public ExecuteJavaScriptAndGetResult(string script, string scriptName, params object[] arguments) Parameters script string The JavaScript to be executed. scriptName string A human-readable name for the script, which may be displayed in a Screenplay report. arguments object[] A collection of arguments/parameters to the script. Exceptions ArgumentException If either script or scriptName are null or whitespace-only. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<TResult> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TResult> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete. See Also ExecuteAScript<TResult>(NamedScriptWithResult<TResult>) ExecuteAScript<T1, TResult>(NamedScriptWithResult<T1, TResult>, T1) ExecuteAScript<T1, T2, TResult>(NamedScriptWithResult<T1, T2, TResult>, T1, T2) ExecuteAScript<T1, T2, T3, TResult>(NamedScriptWithResult<T1, T2, T3, TResult>, T1, T2, T3) ExecuteAScript<T1, T2, T3, T4, TResult>(NamedScriptWithResult<T1, T2, T3, T4, TResult>, T1, T2, T3, T4) ExecuteAScript<T1, T2, T3, T4, T5, TResult>(NamedScriptWithResult<T1, T2, T3, T4, T5, TResult>, T1, T2, T3, T4, T5) ExecuteAScript<T1, T2, T3, T4, T5, T6, TResult>(NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult>, T1, T2, T3, T4, T5, T6) ExecuteAScript<T1, T2, T3, T4, T5, T6, T7, TResult>(NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult>, T1, T2, T3, T4, T5, T6, T7)"
  },
  "api/CSF.Screenplay.Selenium.Questions.FilterElements.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.FilterElements.html",
    "title": "Class FilterElements | Screenplay",
    "summary": "Class FilterElements Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll A question which filters a collection of elements by specified criteria, getting a new collection which contains only those which match. public class FilterElements : IPerformableWithResult<SeleniumElementCollection>, ICanReport Inheritance object FilterElements Implements IPerformableWithResult<SeleniumElementCollection> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example filters a collection of items in a todo list, only for those with red background colors. using CSF.Screenplay.Selenium; using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget todoListItems = new CssSelector(\"ul#todo li\", \"the to-do list items\"); // Within the logic of a custom task, deriving from IPerformableWithResult<SeleniumElementCollection> public async ValueTask<SeleniumElementCollection> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { var elements = await actor.PerformAsync(FindElementsOnThePage().WhichMatch(todoListItems), cancellationToken); var redElements = await actor.PerformAsync(Filter(elements) .ForThoseWhich(q => q.CssProperty(\"background-color\", x => x == Colors.RED)), cancellationToken); return redElements; } Remarks Use this question via the builder method Filter(SeleniumElementCollection). The builder will then guide you through specifying the criteria by which you wish to filter those elements. There are two primary routes by which to do this, which depend upon which overload of ForThoseWhich you choose. You may specify the criteria within a Specification class. That is a class which implements ISpecificationFunction<SeleniumElement>, from the CSF.Specifications package. This allows you to pass just a variable into the builder, containing an instance of that specification. This is the recommended technique, as the specification class becomes a reusable and first-class named part of the Screenplay. When using this technique, use the ForThoseWhich(ISpecificationFunction<SeleniumElement>) overload. Alternatively, you may specify the criteria ad-hoc within the filter-elements builder. To use this technique, use the ForThoseWhich(Func<QueryPredicatePrototypeBuilder, IBuildsElementPredicates>) overload. You must specify a function which interrogates one or more aspects of the element, specifying each criterion individually. This approach allows fast specification of criteria, but at the cost of reusability. Note that this question is evaluated with an already-in-memory collection of SeleniumElement. However, each criterion that is evaluated may cause communication with the WebDriver, for each element in the source collection. This nested loop could lead to unexpected impacts upon performance, particularly with larger collections of elements or where the WebDriver is hosted remotely. If you are able to find the elements you want using an implementation of Locator, then prefer using FindElements instead. Finding elements performs far better than this question. On the other hand, this question offers far greater power in the creation of custom criteria. Constructors FilterElements(IReadOnlyCollection<SeleniumElement>, ISpecificationFunction<SeleniumElement>, string) Initializes a new instance of the FilterElements class. public FilterElements(IReadOnlyCollection<SeleniumElement> elements, ISpecificationFunction<SeleniumElement> specification, string resultsName = null) Parameters elements IReadOnlyCollection<SeleniumElement> The collection of elements to be filtered. specification ISpecificationFunction<SeleniumElement> The specification function to filter the elements. resultsName string An optional short, descriptive, human-readable name which summarizes the elements matched by the filter. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<SeleniumElementCollection> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<SeleniumElementCollection> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete. See Also Filter(SeleniumElementCollection)"
  },
  "api/CSF.Screenplay.Selenium.Questions.FilterSpecification-1.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.FilterSpecification-1.html",
    "title": "Class FilterSpecification<T> | Screenplay",
    "summary": "Class FilterSpecification<T> Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll A specification class which matches elements based upon the value of a query and a specification for that value. public class FilterSpecification<T> : ISpecificationFunction<SeleniumElement> Type Parameters T Inheritance object FilterSpecification<T> Implements ISpecificationFunction<SeleniumElement> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class is intended for use alongside the FilterElements question. It is used to specify the filtering criteria by which a collection of SeleniumElement should be filtered. Constructors FilterSpecification(IQuery<T>, ISpecificationFunction<T>) Initializes a new instance of the FilterSpecification<T> class. public FilterSpecification(IQuery<T> query, ISpecificationFunction<T> valueSpec) Parameters query IQuery<T> The query to get the value from the element. valueSpec ISpecificationFunction<T> The specification function to match the value. Methods GetFunction() Gets the predicate function provided by the current specification instance. public Func<SeleniumElement, bool> GetFunction() Returns Func<SeleniumElement, bool> A predicate function"
  },
  "api/CSF.Screenplay.Selenium.Questions.FindElement.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.FindElement.html",
    "title": "Class FindElement | Screenplay",
    "summary": "Class FindElement Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll A question which searches for an HTML element that matches some criteria, optionally within a specified target, returning the element it finds as a SeleniumElement. public class FindElement : ISingleElementPerformableWithResult<SeleniumElement>, ICanReportForElement Inheritance object FindElement Implements ISingleElementPerformableWithResult<SeleniumElement> ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example gets a SeleniumElement within the list which has the ID todo which has the class urgent. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget todoList = new CssSelector(\"ul#todo\", \"the to-do list\"); readonly Locator urgent = new ClassName(\"urgent\", \"the urgent item\"); // Within the logic of a custom task, deriving from IPerformableWithResult<SeleniumElement> public async ValueTask<SeleniumElement> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic var element = await actor.PerformAsync(FindAnElementWithin(todoList).WhichMatches(urgent), cancellationToken); // ... other performance logic return element; } Remarks Use this question via either of the builder methods FindAnElementWithin(ITarget) or FindAnElementOnThePage(). The first searches within a specified target, the second searches within the whole page <body>. This question will only ever return a single SeleniumElement, or it will raise an exception if the search does not find any matching elements. If multiple elements are found which match the criteria then this question will return only the first. If you are expecting to find multiple elements, then consider using the FindElements question instead. The criteria by which an element is searched by this question is a class that derives from Locator. Particularly useful are the CssSelector, ClassName and XPath locators. ElementId is less likely to be useful, as it should only ever match a single element per web page. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement which it queries. It has this in common with a number of Screenplay questions in the Selenium Plugin which observe a single element, those which derive from ISingleElementPerformableWithResult<TResult>. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableWithResultAdapter<TResult>. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Constructors FindElement(string, Locator) Initializes a new instance of the FindElement class. public FindElement(string elementsName = null, Locator locatorBasedMatcher = null) Parameters elementsName string An optional short, descriptive, human-readable name to give to the collection of elements which are found. locatorBasedMatcher Locator An optional Locator which should be used to filter the elements which are returned. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask<SeleniumElement> PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<SeleniumElement> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete. See Also FindAnElementOnThePage() FindAnElementWithin(ITarget)"
  },
  "api/CSF.Screenplay.Selenium.Questions.FindElements.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.FindElements.html",
    "title": "Class FindElements | Screenplay",
    "summary": "Class FindElements Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll A question which searches for HTML elements that matche some criteria, optionally within a specified target, returning the results as a SeleniumElementCollection. public class FindElements : ISingleElementPerformableWithResult<SeleniumElementCollection>, ICanReportForElement Inheritance object FindElements Implements ISingleElementPerformableWithResult<SeleniumElementCollection> ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example gets a SeleniumElementCollection which contains every element in the list which has the ID todo, which also the class low_priority. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget todoList = new CssSelector(\"ul#todo\", \"the to-do list\"); readonly Locator lowPriority = new ClassName(\"low_priority\", \"the low priority items\"); // Within the logic of a custom task, deriving from IPerformableWithResult<SeleniumElementCollection> public async ValueTask<SeleniumElementCollection> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic var elements = await actor.PerformAsync(FindElementsWithin(todoList).WhichMatch(lowPriority), cancellationToken); // ... other performance logic return elements; } Remarks Use this question via either of the builder methods FindElementsWithin(ITarget) or FindElementsOnThePage(). The first searches within a specified target, the second searches within the whole page <body>. This question returns a collection of elements but that collection could be empty if the search does not find any matching elements. If you are looking for a single element and a 'nothing found' result should raise an exception then consider using the FindElement question instead. The criteria by which an element is searched by this question is a class that derives from Locator. Particularly useful are the CssSelector, ClassName and XPath locators. ElementId is less likely to be useful, as it should only ever match a single element per web page. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement which it queries. It has this in common with a number of Screenplay questions in the Selenium Plugin which observe a single element, those which derive from ISingleElementPerformableWithResult<TResult>. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableWithResultAdapter<TResult>. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Constructors FindElements(string, Locator) Initializes a new instance of the FindElements class. public FindElements(string elementsName = null, Locator locatorBasedMatcher = null) Parameters elementsName string An optional short, descriptive, human-readable name to give to the collection of elements which are found. locatorBasedMatcher Locator An optional Locator which should be used to filter the elements which are returned. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask<SeleniumElementCollection> PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<SeleniumElementCollection> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete. See Also FindElementsOnThePage() FindElementsWithin(ITarget)"
  },
  "api/CSF.Screenplay.Selenium.Questions.GetWindowTitle.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.GetWindowTitle.html",
    "title": "Class GetWindowTitle | Screenplay",
    "summary": "Class GetWindowTitle Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll A question which reads and returns the title of the current browser window. public class GetWindowTitle : IPerformableWithResult<string>, ICanReport Inheritance object GetWindowTitle Implements IPerformableWithResult<string> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples using static CSF.Screenplay.Selenium.PerformableBuilder; // Within the logic of a custom task, deriving from IPerformableWithResult<string> public async ValueTask<string> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { return await actor.PerformAsync(ReadTheWindowTitle(), cancellationToken); } Remarks The best way to use this action is via the builder method ReadTheWindowTitle(). This very simple question gets the text which is displayed as the browser window (or tab) title. In a normal web page, that would be what's contained in the <title> element. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<string> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<string> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete. See Also ReadTheWindowTitle()"
  },
  "api/CSF.Screenplay.Selenium.Questions.IElementCollectionPerformableWithResult-1.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.IElementCollectionPerformableWithResult-1.html",
    "title": "Interface IElementCollectionPerformableWithResult<TResult> | Screenplay",
    "summary": "Interface IElementCollectionPerformableWithResult<TResult> Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll Similar to IPerformableWithResult<TResult> but provides access to a Selenium WebDriver and a collection of Selenium elements. public interface IElementCollectionPerformableWithResult<TResult> : ICanReportForElements Type Parameters TResult Inherited Members ICanReportForElements.GetReportFragment(Actor, Lazy<SeleniumElementCollection>, IFormatsReportFragment) Remarks This interface is specialised for performables which interact with collections of Selenium elements. It allows for the provision of some of the boilerplate to set up such a performable. See IPerformableWithResult<TResult> for more information about how this interface would be used in general terms. In order to actually use implementations of this interface as performables, they should be wrapped in an SingleElementPerformableWithResultAdapter<TResult>. Methods PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElementCollection>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. ValueTask<IReadOnlyList<TResult>> PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElementCollection> elements, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. elements Lazy<SeleniumElementCollection> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<IReadOnlyList<TResult>> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Selenium.Questions.ISingleElementPerformableWithResult-1.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.ISingleElementPerformableWithResult-1.html",
    "title": "Interface ISingleElementPerformableWithResult<TResult> | Screenplay",
    "summary": "Interface ISingleElementPerformableWithResult<TResult> Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll Similar to IPerformableWithResult<TResult> but provides access to a Selenium WebDriver and a Selenium element. public interface ISingleElementPerformableWithResult<TResult> : ICanReportForElement Type Parameters TResult Inherited Members ICanReportForElement.GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Remarks This interface is specialised for performables which interact with a single Selenium element. It allows for the provision of some of the boilerplate to set up such a performable. See IPerformableWithResult<TResult> for more information about how this interface would be used in general terms. In order to actually use implementations of this interface as performables, they should be wrapped in an SingleElementPerformableWithResultAdapter<TResult>. Methods PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. ValueTask<TResult> PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TResult> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Selenium.Questions.SingleElementPerformableWithResultAdapter-1.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.SingleElementPerformableWithResultAdapter-1.html",
    "title": "Class SingleElementPerformableWithResultAdapter<TResult> | Screenplay",
    "summary": "Class SingleElementPerformableWithResultAdapter<TResult> Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll Adapter class which allows a ISingleElementPerformableWithResult<TResult> to be used as an IPerformableWithResult<TResult>. public class SingleElementPerformableWithResultAdapter<TResult> : IPerformableWithResult<TResult>, ICanReport Type Parameters TResult Inheritance object SingleElementPerformableWithResultAdapter<TResult> Implements IPerformableWithResult<TResult> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This adapter class is provided as a convenience to perform some of the boilerplate logic required to scaffold the parameters required by ISingleElementPerformableWithResult<TResult>. This method also caches the SeleniumElement which is returned by the ITarget, avoiding the need to fetch it using the WebDriver more than once. As such, instances of this adapter (like all performables) should not be re-used. Constructors SingleElementPerformableWithResultAdapter(ISingleElementPerformableWithResult<TResult>, ITarget, bool) Initializes a new instance of the SingleElementPerformableWithResultAdapter<TResult> class with the specified performable and target. public SingleElementPerformableWithResultAdapter(ISingleElementPerformableWithResult<TResult> performable, ITarget target, bool doNotThrowOnMissingElement = false) Parameters performable ISingleElementPerformableWithResult<TResult> The performable to be adapted. target ITarget The target element for the performable. doNotThrowOnMissingElement bool If set to true then this performable will not throw an exception when the element does not exist. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<TResult> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TResult> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.Selenium.Questions.SingleElementPerformableWithResultAdapter.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.SingleElementPerformableWithResultAdapter.html",
    "title": "Class SingleElementPerformableWithResultAdapter | Screenplay",
    "summary": "Class SingleElementPerformableWithResultAdapter Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll Static helper methods for creating instances of SingleElementPerformableWithResultAdapter<TResult>. public static class SingleElementPerformableWithResultAdapter Inheritance object SingleElementPerformableWithResultAdapter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods From<TResult>(ISingleElementPerformableWithResult<TResult>, ITarget, bool) Creates a new instance of SingleElementPerformableWithResultAdapter<TResult> from the specified performable and target. public static SingleElementPerformableWithResultAdapter<TResult> From<TResult>(ISingleElementPerformableWithResult<TResult> performable, ITarget target, bool doNotThrowOnMissingElement = false) Parameters performable ISingleElementPerformableWithResult<TResult> The performable to be adapted. target ITarget The target element for the performable. doNotThrowOnMissingElement bool If set to true then this performable will not throw an exception when the element does not exist. Returns SingleElementPerformableWithResultAdapter<TResult> A new instance of SingleElementPerformableWithResultAdapter<TResult>. Type Parameters TResult The type of the result."
  },
  "api/CSF.Screenplay.Selenium.Questions.SingleElementQuery-1.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.SingleElementQuery-1.html",
    "title": "Class SingleElementQuery<TResult> | Screenplay",
    "summary": "Class SingleElementQuery<TResult> Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll A question which reads or observes the state of a single HTML element and returns the result. public class SingleElementQuery<TResult> : ISingleElementPerformableWithResult<TResult>, ICanReportForElement Type Parameters TResult The type of the result returned by the query. Inheritance object SingleElementQuery<TResult> Implements ISingleElementPerformableWithResult<TResult> ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example gets the background color of a list item which has the class warning. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget warningItem = new CssSelector(\"li.warning\", \"the warning item\"); // Within the logic of a custom task, deriving from IPerformableWithResult<string> public async ValueTask<string> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic var bgColor = await actor.PerformAsync(ReadFromTheElement(warningItem).TheCssProperty(\"background-color\"), cancellationToken); // ... other performance logic return bgColor; } Remarks Use this question via the builder method ReadFromTheElement(ITarget). The builder will then guide you through inspecting the state of the target. That state information will be returned as the result of this question. Crucially, to decide which piece of information to retrieve from the target, you will build and use a Query. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement which it queries. It has this in common with a number of Screenplay questions in the Selenium Plugin which observe a single element, those which derive from ISingleElementPerformableWithResult<TResult>. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableWithResultAdapter<TResult>. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Constructors SingleElementQuery(IQuery<TResult>) Initializes a new instance of the SingleElementQuery<TResult> class with the specified query. public SingleElementQuery(IQuery<TResult> query) Parameters query IQuery<TResult> The query to be used for retrieving the value from the Selenium element. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask<TResult> PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TResult> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete. See Also ReadFromTheElement(ITarget)"
  },
  "api/CSF.Screenplay.Selenium.Questions.SingleElementQuery.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.SingleElementQuery.html",
    "title": "Class SingleElementQuery | Screenplay",
    "summary": "Class SingleElementQuery Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll Provides a factory method for creating instances of SingleElementQuery<TResult>. public static class SingleElementQuery Inheritance object SingleElementQuery Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods From<TResult>(IQuery<TResult>) Creates a new instance of SingleElementQuery<TResult> with the specified query. public static SingleElementQuery<TResult> From<TResult>(IQuery<TResult> query) Parameters query IQuery<TResult> The query to be used for retrieving the value from the Selenium element. Returns SingleElementQuery<TResult> A new instance of SingleElementQuery<TResult>. Type Parameters TResult The type of the result returned by the query."
  },
  "api/CSF.Screenplay.Selenium.Questions.TakeScreenshot.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.TakeScreenshot.html",
    "title": "Class TakeScreenshot | Screenplay",
    "summary": "Class TakeScreenshot Namespace CSF.Screenplay.Selenium.Questions Assembly CSF.Screenplay.Selenium.dll A question which represents an actor taking a screenshot of the current web page. public class TakeScreenshot : IPerformableWithResult<Screenshot>, ICanReport Inheritance object TakeScreenshot Implements IPerformableWithResult<Screenshot> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples using OpenQA.Selenium; using static CSF.Screenplay.Selenium.PerformableBuilder; // Within the logic of a custom task, deriving from IPerformableWithResult<Screenshot> public async ValueTask<Screenshot> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { return await actor.PerformAsync(TakeAScreenshot(), cancellationToken); } Remarks The best way to use this action is via the builder method TakeAScreenshot() or TakeAScreenshotIfSupported(). The second method will not raise an exception if the browser is incapable of providing screenshots. This question instructs the WebDriver to capture the currently-visible area of the browser window (the viewport) in a screenshot, and return that screenshot to the IPerformance. Since the most common thing to do with a Screenshot object is to save it to disk, consumers should consider using the TakeAndSaveScreenshot task instead, via either the builder methods TakeAndSaveAScreenshot() or TakeAndSaveAScreenshotIfSupported(). These deal with both the taking and saving of the screenshot in a single step. Constructors TakeScreenshot(bool) Initializes a new instance of the TakeScreenshot class. public TakeScreenshot(bool throwIfUnsupported = true) Parameters throwIfUnsupported bool If set to true, throws an exception if the WebDriver does not support taking screenshots. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<Screenshot> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<Screenshot> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete. See Also TakeAScreenshot() TakeAScreenshotIfSupported() SaveScreenshot TakeAndSaveScreenshot"
  },
  "api/CSF.Screenplay.Selenium.Questions.html": {
    "href": "api/CSF.Screenplay.Selenium.Questions.html",
    "title": "Namespace CSF.Screenplay.Selenium.Questions | Screenplay",
    "summary": "Namespace CSF.Screenplay.Selenium.Questions Classes ElementCollectionPerformableWithResultAdapter Static helper methods for creating instances of ElementCollectionPerformableWithResultAdapter<TResult>. ElementCollectionPerformableWithResultAdapter<TResult> Adapter class which allows a IElementCollectionPerformableWithResult<TResult> to be used as an IPerformableWithResult<TResult>. ElementCollectionQuery Provides a factory method for creating instances of ElementCollectionQuery<TResult>. ElementCollectionQuery<TResult> A question which reads or observes the state from a collection of HTML elements and returns the results. ExecuteJavaScriptAndGetResult<TResult> A question which executes some arbitrary JavaScript in the web browser and returns the result returned by that script. FilterElements A question which filters a collection of elements by specified criteria, getting a new collection which contains only those which match. FilterSpecification<T> A specification class which matches elements based upon the value of a query and a specification for that value. FindElement A question which searches for an HTML element that matches some criteria, optionally within a specified target, returning the element it finds as a SeleniumElement. FindElements A question which searches for HTML elements that matche some criteria, optionally within a specified target, returning the results as a SeleniumElementCollection. GetWindowTitle A question which reads and returns the title of the current browser window. SingleElementPerformableWithResultAdapter Static helper methods for creating instances of SingleElementPerformableWithResultAdapter<TResult>. SingleElementPerformableWithResultAdapter<TResult> Adapter class which allows a ISingleElementPerformableWithResult<TResult> to be used as an IPerformableWithResult<TResult>. SingleElementQuery Provides a factory method for creating instances of SingleElementQuery<TResult>. SingleElementQuery<TResult> A question which reads or observes the state of a single HTML element and returns the result. TakeScreenshot A question which represents an actor taking a screenshot of the current web page. Interfaces IElementCollectionPerformableWithResult<TResult> Similar to IPerformableWithResult<TResult> but provides access to a Selenium WebDriver and a collection of Selenium elements. ISingleElementPerformableWithResult<TResult> Similar to IPerformableWithResult<TResult> but provides access to a Selenium WebDriver and a Selenium element."
  },
  "api/CSF.Screenplay.Selenium.Reporting.OptionsFormatter.html": {
    "href": "api/CSF.Screenplay.Selenium.Reporting.OptionsFormatter.html",
    "title": "Class OptionsFormatter | Screenplay",
    "summary": "Class OptionsFormatter Namespace CSF.Screenplay.Selenium.Reporting Assembly CSF.Screenplay.Selenium.dll An IValueFormatter for collections of Option for reporting. public class OptionsFormatter : IValueFormatter Inheritance object OptionsFormatter Implements IValueFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CanFormat(object) Gets a value indicating whether this object is suitable for formatting the specified value. public bool CanFormat(object value) Parameters value object The value to be formatted Returns bool true if this formatter is suitable for formatting the specified value; false if not. FormatForReport(object) Gets a formatted string which represents the specified value. public string FormatForReport(object value) Parameters value object The value to be formatted Returns string A formatted string which represents the specified value. Remarks Ensure that the value has been tested with CanFormat(object) before executing this method. The behaviour of this method is undefined for any value for which the can-format method does not return true. It may lead to exceptions or garbage output."
  },
  "api/CSF.Screenplay.Selenium.Reporting.ScreenshotFormatter.html": {
    "href": "api/CSF.Screenplay.Selenium.Reporting.ScreenshotFormatter.html",
    "title": "Class ScreenshotFormatter | Screenplay",
    "summary": "Class ScreenshotFormatter Namespace CSF.Screenplay.Selenium.Reporting Assembly CSF.Screenplay.Selenium.dll An IValueFormatter for Selenium Screenshot objects, for reporting. public class ScreenshotFormatter : IValueFormatter Inheritance object ScreenshotFormatter Implements IValueFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CanFormat(object) Gets a value indicating whether this object is suitable for formatting the specified value. public bool CanFormat(object value) Parameters value object The value to be formatted Returns bool true if this formatter is suitable for formatting the specified value; false if not. FormatForReport(object) Gets a formatted string which represents the specified value. public string FormatForReport(object value) Parameters value object The value to be formatted Returns string A formatted string which represents the specified value. Remarks Ensure that the value has been tested with CanFormat(object) before executing this method. The behaviour of this method is undefined for any value for which the can-format method does not return true. It may lead to exceptions or garbage output."
  },
  "api/CSF.Screenplay.Selenium.Reporting.html": {
    "href": "api/CSF.Screenplay.Selenium.Reporting.html",
    "title": "Namespace CSF.Screenplay.Selenium.Reporting | Screenplay",
    "summary": "Namespace CSF.Screenplay.Selenium.Reporting Classes OptionsFormatter An IValueFormatter for collections of Option for reporting. ScreenshotFormatter An IValueFormatter for Selenium Screenshot objects, for reporting."
  },
  "api/CSF.Screenplay.Selenium.Scripts.html": {
    "href": "api/CSF.Screenplay.Selenium.Scripts.html",
    "title": "Class Scripts | Screenplay",
    "summary": "Class Scripts Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll A repository of named JavaScripts which are distributed with Screenplay's Selenium integration. public static class Scripts Inheritance object Scripts Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Developers who use Screenplay & Selenium and who need to develop their own custom JavaScripts are encouraged to devise their own classes similar to this one. This provides a rapid and type-safe mechanism of retrieving and reusing well-known/predefined JavaScripts. See the named scripts article for more information about defining scripts with human-readable names and type safety. Properties ClearLocalStorage Gets a NamedScript which clears the Local Storage of the browser, for the current domain. public static NamedScript ClearLocalStorage { get; } Property Value NamedScript GetTheDocumentReadyState Gets a NamedScriptWithResult<TResult> which gets the value of document.readyState for the current page. public static NamedScriptWithResult<string> GetTheDocumentReadyState { get; } Property Value NamedScriptWithResult<string> Remarks You may use this script to determine whether the page has finished loading. SetElementValue Gets a NamedScript<T1, T2> which sets the value of a specified HTML element. public static NamedScript<IWebElement, object> SetElementValue { get; } Property Value NamedScript<IWebElement, object> SetElementValueSimulatedInteractively Gets a NamedScript<T1, T2> which sets the value of a specified HTML element, simulating setting it interactively. public static NamedScript<IWebElement, object> SetElementValueSimulatedInteractively { get; } Property Value NamedScript<IWebElement, object>"
  },
  "api/CSF.Screenplay.Selenium.ServiceCollectionExtensions.html": {
    "href": "api/CSF.Screenplay.Selenium.ServiceCollectionExtensions.html",
    "title": "Class ServiceCollectionExtensions | Screenplay",
    "summary": "Class ServiceCollectionExtensions Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll Extension methods for IServiceCollection. public static class ServiceCollectionExtensions Inheritance object ServiceCollectionExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddSelenium(IServiceCollection) Activates the Selenium extension for Screenplay by adding relevant services to the dependency injection container. public static IServiceCollection AddSelenium(this IServiceCollection services) Parameters services IServiceCollection The service collection Returns IServiceCollection The same service collection, so calls may be chained."
  },
  "api/CSF.Screenplay.Selenium.SetTheValueBuilder.IChoosesValue.html": {
    "href": "api/CSF.Screenplay.Selenium.SetTheValueBuilder.IChoosesValue.html",
    "title": "Interface SetTheValueBuilder.IChoosesValue | Screenplay",
    "summary": "Interface SetTheValueBuilder.IChoosesValue Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll An object from which a consumer may choose a value to set into the element. public interface SetTheValueBuilder.IChoosesValue Methods To(object) Gets a builder for a performable which sets the target element to the value specified in this method. SetTheValueBuilder To(object value) Parameters value object The new value for the element Returns SetTheValueBuilder A builder for a performable Remarks If you are using this method to update the value of an element because you are working around a limitation in a web browser/ WebDriver, then strongly consider following it with AsIfSetInteractively()."
  },
  "api/CSF.Screenplay.Selenium.SetTheValueBuilder.html": {
    "href": "api/CSF.Screenplay.Selenium.SetTheValueBuilder.html",
    "title": "Class SetTheValueBuilder | Screenplay",
    "summary": "Class SetTheValueBuilder Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll Builds actions for setting values in Selenium web elements. public class SetTheValueBuilder : IGetsPerformable, SetTheValueBuilder.IChoosesValue Inheritance object SetTheValueBuilder Implements IGetsPerformable SetTheValueBuilder.IChoosesValue Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SetTheValueBuilder(ITarget) Initializes a new instance of the SetTheValueBuilder class with the specified target. public SetTheValueBuilder(ITarget target) Parameters target ITarget The target web element for which to build value-setting actions. Methods AsIfSetInteractively() Gets a performable which, whilst setting the value programatically, attempts to simulate setting it interactively in the browser. public IPerformable AsIfSetInteractively() Returns IPerformable A performable Remarks Use this method to work around limitations in the web browser/WebDriver, as it is an imperfect solution. When this method is used, it configures the performable to use JavaScript which will not only update the value of the specified element. It will additionally trigger HTML/JavaScript events upon the element such as focus, input, change and blur in an attempt to simulate an interactive change. The reason for this is that client web page functionality may be listening to these events and would be exercised if the element value were updated by a human being interacting with the web page. However when JS is used to update the value, those events are not fired. This method fires the events artificially. To(object) Gets a builder for a performable which sets the target element to the value specified in this method. public SetTheValueBuilder To(object value) Parameters value object The new value for the element Returns SetTheValueBuilder A builder for a performable Remarks If you are using this method to update the value of an element because you are working around a limitation in a web browser/ WebDriver, then strongly consider following it with AsIfSetInteractively()."
  },
  "api/CSF.Screenplay.Selenium.Tasks.ClickAndWaitForDocumentReady.html": {
    "href": "api/CSF.Screenplay.Selenium.Tasks.ClickAndWaitForDocumentReady.html",
    "title": "Class ClickAndWaitForDocumentReady | Screenplay",
    "summary": "Class ClickAndWaitForDocumentReady Namespace CSF.Screenplay.Selenium.Tasks Assembly CSF.Screenplay.Selenium.dll A Screenplay task which combines a Click action with cross-browser waiting logic, for navigating to a new web page. public class ClickAndWaitForDocumentReady : ISingleElementPerformable, ICanReportForElement Inheritance object ClickAndWaitForDocumentReady Implements ISingleElementPerformable ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example demonstrates clicking a link to a settings page and waiting for the page to be ready. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget settingsLink = new CssSelector(\"nav#app_navigation .settings a\", \"the link to the settings page\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { await actor.PerformAsync(ClickOn(settingsLink).AndWaitForANewPageToLoad(), cancellationToken); // regardless of WebDriver implementation, further performables here will not execute // until the settings page has completely loaded. } Remarks Use this task in performance logic using the builder method ClickOn(ITarget), following this up with the AndWaitForANewPageToLoad(TimeSpan?) method. That builder functionality differentiates the returned performable from the normal Click action. The rationale for this task's existence is primarily to deal with web browsers which are affected by the quirk NeedsToWaitAfterPageLoad. See the documentation for that quirk for more information on what it means for web browser. This task deals with browsers affected by that quirk by extending the click behaviour. When the WebDriver is affected by this quirk, as well as clicking upon an element, a reference to that element is saved. The WebDriver is then polled until the element clicked has become stale. A stale element is one which is no longer present in the web browser. The staleness of the clicked element is used as a proxy for the unloading of the 'outgoing' web page. Once the mechanism describe above has determined that the outgoing web page has unloaded, this task begins a second waiting process. The second wait executes the JavaScript GetTheDocumentReadyState repeatedly until it returns the result complete. At that point, the waiting is over and the performance may continue. The mechanism described above also includes an optional (constructor injected) timeout. The timeout is used twice; it applies both to the unloading of the old page the ready-state of the new page returning complete. Thus in a theoretical worst-case scenario, this task could lead to a wait of twice the specified timeout value. If the timeout is not specified then it will use the value from UseADefaultWaitTime if the actor has that ability. If not then the hardcoded fall-back DefaultTimeout of 5 seconds will be used. Constructors ClickAndWaitForDocumentReady(TimeSpan?) Initializes a new instance of the ClickAndWaitForDocumentReady class. public ClickAndWaitForDocumentReady(TimeSpan? waitTimeout) Parameters waitTimeout TimeSpan? The timeout duration for both the page-unload and document-ready waits. See the remarks on this class for more info. Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also NeedsToWaitAfterPageLoad ClickOn(ITarget) AndWaitForANewPageToLoad(TimeSpan?) UseADefaultWaitTime DefaultTimeout"
  },
  "api/CSF.Screenplay.Selenium.Tasks.EnterTheDate.html": {
    "href": "api/CSF.Screenplay.Selenium.Tasks.EnterTheDate.html",
    "title": "Class EnterTheDate | Screenplay",
    "summary": "Class EnterTheDate Namespace CSF.Screenplay.Selenium.Tasks Assembly CSF.Screenplay.Selenium.dll A Screenplay task for entering a value into an <input type=\"date\"> element. public class EnterTheDate : IPerformable, ICanReport Inheritance object EnterTheDate Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples A British English browser en-GB expects dates to be entered in the format ddMMyyyy. However, a US English browser en-US expects dates to be entered in the format MMddyyyy. The code sample below shows how to enter the date 5th April 2025 into a date input element with the id due_date, using the British English format. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget dueDate = new ElementId(\"due_date\", \"the due date\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(EnterTheDate(new DateTime(2025, 4, 5)).Into(dueDate).ForTheCultureNamed(\"en-GB\"), cancellationToken); // ... other performance logic } Remarks Use this task with the builder method EnterTheDate(DateTime?). This builder will guide you through picking the element into which the date should be entered. The rationale for this task is that web browsers or WebDriver implementations are inconsistent in the manner in which they support interacting with Date input elements. Browsers which require a JavaScript workaround are marked with the browser quirk CannotSetInputTypeDateWithSendKeys. See the documentation for that quirk for more information. This task provides date-setting capabilities in a cross-browser manner. For browsers which are affected by the quirk, the date is set via a separate task: SetTheElementValue, with the 'simulate setting the value interactively' behaviour enabled. For browsers which are not affected by the quirk, the date is first cleared via the action ClearTheContents, and then keypresses are sent to the web browser to enter the date in a locale-specific format via SendKeys. Note that because entering a date interactively (by sending keys) requires a locale-specific format, that makes this task culture-sensitive. It is important to ensure that the date value entered into the browser is entered using the same culture as which the browser is currently operating. If the culture does not match then this could lead to mistakes in the value; consider muddling up US English and UK English dates. In US English 04/05/2010 means the 5th April 2010. In UK English that same date string means 4th May 2010, because the days and months are transposed in that format. If no culture information is specified in the constructor then this task defaults to the current culture: CurrentCulture. That is often sufficient, particularly if the WebDriver is running locally on the same computer as is executing the Screenplay Performance. It could be problematic, though, if a Remote WebDriver is in use. A Remote WebDriver could be hosted in another nation and thus be operating under a different culture to the Screenplay Performance. In this case, be sure to specify the correct culture in the constructor of this task. If the date specified to this task is null then this task will clear the date from the target. Constructors EnterTheDate(DateTime?, ITarget, CultureInfo) Initializes a new instance of the EnterTheDate class with the specified date. public EnterTheDate(DateTime? date, ITarget target, CultureInfo culture = null) Parameters date DateTime? The date to enter into the element. target ITarget The element into which to enter the data culture CultureInfo The culture for which to enter the date Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also EnterTheDate(DateTime?) CannotSetInputTypeDateWithSendKeys SetTheElementValue ClearTheContents SendKeys"
  },
  "api/CSF.Screenplay.Selenium.Tasks.OpenUrlRespectingBase.html": {
    "href": "api/CSF.Screenplay.Selenium.Tasks.OpenUrlRespectingBase.html",
    "title": "Class OpenUrlRespectingBase | Screenplay",
    "summary": "Class OpenUrlRespectingBase Namespace CSF.Screenplay.Selenium.Tasks Assembly CSF.Screenplay.Selenium.dll A Screenplay task which navigates directly to a specified URL using the actor's WebDriver. If the specified Uri is relative then it is made absolute by basing it upon the Uri indicated by the UseABaseUri ability. public class OpenUrlRespectingBase : IPerformable, ICanReport Inheritance object OpenUrlRespectingBase Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This task is used in exactly the same way as OpenUrl. The example below shows the opening of the URL https://example.com/user/shoppingCart. Note that in a real performance, the actor would be granted the UseABaseUri ability at a far higher-level performable than the position in which they are performing navigation. This example is 'compressed' for brevity. using static CSF.Screenplay.Selenium.PerformableBuilder; var examplePage = new NamedUri(\"user/shoppingCart\", \"the user's shopping cart\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { actor.IsAbleTo(new UseABaseUri(new Uri(\"https://example.com\"))); await actor.PerformAsync(OpenTheUrl(examplePage), cancellationToken); } Remarks Use this task via the builder method OpenTheUrl(NamedUri), which automatically makes use of this task. This task behaves very similarly to the action OpenUrl, except for base-URI-replacement. When this task is used, if the specified named Uri (constructor injected) is already absolute then this task has no effect beyond passing that same absolute Uri to OpenUrl. If the specified Uri is relative then the UseABaseUri ability is retrieved from the actor; this will throw if the actor does not possess the ability. If they do, then the Uri specified to this task will be rebased onto the BaseUri, via RebaseTo(Uri). The rebased Uri will then be used with OpenUrl. The purpose of this task is to permit developers to specify NamedUri instances using relative Uri values instead of absolute ones. When doing so, the performance must grant the UseABaseUri ability to the actor who is making use of the WebDriver (via BrowseTheWeb). This allows the final absolute Uris for the functionality to be determined at runtime, via the combination of a base Uri and a relative part. This is expected to be useful to developers, who may need their Screenplay logic to operate upon a specified environment (determined by a base Uri) at runtime. However, the relative Uri paths to pages within that environment remain identical regardless of the environment. The combination of the UseABaseUri ability and this task make such an architecture possible. Constructors OpenUrlRespectingBase(NamedUri) Initializes a new instance of the OpenUrlRespectingBase class with the specified URL. public OpenUrlRespectingBase(NamedUri uri) Parameters uri NamedUri The URL to open. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also UseABaseUri OpenTheUrl(NamedUri) OpenUrl"
  },
  "api/CSF.Screenplay.Selenium.Tasks.SetTheElementValue.html": {
    "href": "api/CSF.Screenplay.Selenium.Tasks.SetTheElementValue.html",
    "title": "Class SetTheElementValue | Screenplay",
    "summary": "Class SetTheElementValue Namespace CSF.Screenplay.Selenium.Tasks Assembly CSF.Screenplay.Selenium.dll A Screenplay task which uses JavaScript to directly set the value of an HTML element. public class SetTheElementValue : ISingleElementPerformable, ICanReportForElement Inheritance object SetTheElementValue Implements ISingleElementPerformable ICanReportForElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples This example sets the value of an element that has id impossible_input to \"I worked around it!\" and triggers events which simulate a user changing the value interactively. using CSF.Screenplay.Selenium.Elements; using static CSF.Screenplay.Selenium.PerformableBuilder; readonly ITarget impossibleInput = new ElementId(\"impossible_input\", \"the input field which a WebDriver cannot reach\"); // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(SetTheValueOf(impossibleInput).To(\"I worked around it!\").AsIfSetInteractively(), cancellationToken); // ... other performance logic } Remarks Use this task via the builder method SetTheValueOf(ITarget), optionally also using the builder method AsIfSetInteractively(). When AsIfSetInteractively is used then additional JavaScript will be executed in an attempt to simulate a human user interactively setting the value. The rationale for this task is that sometimes, due to limitations of the WebDriver implementation, it is not possible to interact with an HTML element in the same way that a human user would. An example of this is web browsers which are affected by CannotSetInputTypeDateWithSendKeys. When these limitations are encountered, the only recourse is to work around them with JavaScript. If this task is not instructed to simulate setting the value interactively then this task does no more than use JavaScript to set the value of the element. However, if it is simulating setting the value interactively then a number of HTML/JavaScript events are manually invoked, to give UI behaviour an opportunity to respond. These events (and the order in which they are triggered) are: focus, input, change and then blur. The element value is actually updated between the focus and input events. Use this task judiciously and sparingly. It is best to interact with the web browser/WebDriver in the same manner in which a human user would, particularly when using Screenplay/Selenium for testing. This task is provided just to work around difficulties/limitations; it is not intended to be the standard way to update elements on a web page. This class is not a complete performable, as it relies upon shared logic to retrieve the SeleniumElement upon which it shall act. It has this in common with many Screenplay actions & tasks in the Selenium extension which operate upon a single element. These performables derive from ISingleElementPerformable. In order for this class to be used as a full-fledged performable, an instance of this type must be wrapped within an instance of SingleElementPerformableAdapter. The adapter class provides the shared boilerplate logic which provides access to the Selenium Element. Note that the builder method(s) which create instances of this type include the 'wrap within an adapter' logic. Normal usage of this performable, when creating it from a builder, does not need to be concerned with this factor. Constructors SetTheElementValue(object, bool) Initializes a new instance of the SetTheElementValue class. public SetTheElementValue(object value, bool simulateInteractiveSet) Parameters value object The value to set on the element. simulateInteractiveSet bool If true then the JavaScript will fire UI events to simulate having set the element interactively Methods GetReportFragment(Actor, Lazy<SeleniumElement>, IFormatsReportFragment) Counterpart to GetReportFragment(Actor, IFormatsReportFragment) except that this method also offers a Selenium element. public ReportFragment GetReportFragment(Actor actor, Lazy<SeleniumElement> element, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment element Lazy<SeleniumElement> The Selenium element for which the report is being written formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Remarks Please see the documentation for GetReportFragment(Actor, IFormatsReportFragment) for more information. PerformAsAsync(ICanPerform, IWebDriver, Lazy<SeleniumElement>, CancellationToken) Counterpart to PerformAsAsync(ICanPerform, CancellationToken) except that this method also offers a Selenium WebDriver and element. public ValueTask PerformAsAsync(ICanPerform actor, IWebDriver webDriver, Lazy<SeleniumElement> element, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. webDriver IWebDriver The Selenium WebDriver provided from the actor's abilities. element Lazy<SeleniumElement> The single Selenium Element upon which this method should operate. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also SetTheValueOf(ITarget) SetTheValueBuilder ExecuteAScript(NamedScript) ExecuteJavaScript"
  },
  "api/CSF.Screenplay.Selenium.Tasks.TakeAndSaveScreenshot.html": {
    "href": "api/CSF.Screenplay.Selenium.Tasks.TakeAndSaveScreenshot.html",
    "title": "Class TakeAndSaveScreenshot | Screenplay",
    "summary": "Class TakeAndSaveScreenshot Namespace CSF.Screenplay.Selenium.Tasks Assembly CSF.Screenplay.Selenium.dll A Screenplay task which combines the taking of a screenshot of the current web browser viewport and saving it as an asset file. public class TakeAndSaveScreenshot : IPerformable, ICanReport Inheritance object TakeAndSaveScreenshot Implements IPerformable ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples using OpenQA.Selenium; using static CSF.Screenplay.Selenium.PerformableBuilder; // Within the logic of a custom task, deriving from IPerformable public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { // ... other performance logic await actor.PerformAsync(TakeAndSaveAScreenshot().WithTheName(\"Shopping cart items\"), cancellationToken); // ... other performance logic } Remarks Use this task via one of the builder methods TakeAndSaveAScreenshot() or TakeAndSaveAScreenshotIfSupported(). This performable task is a composition of two others: TakeScreenshot and SaveScreenshot. See the documentation for this question and action for more information. As with SaveScreenshot, this performable requires the actor to have the ability GetAssetFilePaths. Constructors TakeAndSaveScreenshot(string, ScreenshotImageFormat, bool) Initializes a new instance of the TakeAndSaveScreenshot class. public TakeAndSaveScreenshot(string name = null, ScreenshotImageFormat format = ScreenshotImageFormat.Png, bool throwIfUnsupported = true) Parameters name string An optional human-readable name for the screenshot. format ScreenshotImageFormat An optional image format by which to save the screenshot. throwIfUnsupported bool If set to true, throws an exception if the WebDriver does not support taking screenshots. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask A task which completes when the performable represented by the current instance is complete. See Also TakeAndSaveAScreenshot() TakeAndSaveAScreenshotIfSupported() TakeScreenshot SaveScreenshot GetAssetFilePaths"
  },
  "api/CSF.Screenplay.Selenium.Tasks.html": {
    "href": "api/CSF.Screenplay.Selenium.Tasks.html",
    "title": "Namespace CSF.Screenplay.Selenium.Tasks | Screenplay",
    "summary": "Namespace CSF.Screenplay.Selenium.Tasks Classes ClickAndWaitForDocumentReady A Screenplay task which combines a Click action with cross-browser waiting logic, for navigating to a new web page. EnterTheDate A Screenplay task for entering a value into an <input type=\"date\"> element. OpenUrlRespectingBase A Screenplay task which navigates directly to a specified URL using the actor's WebDriver. If the specified Uri is relative then it is made absolute by basing it upon the Uri indicated by the UseABaseUri ability. SetTheElementValue A Screenplay task which uses JavaScript to directly set the value of an HTML element. TakeAndSaveScreenshot A Screenplay task which combines the taking of a screenshot of the current web browser viewport and saving it as an asset file."
  },
  "api/CSF.Screenplay.Selenium.UseABaseUri.html": {
    "href": "api/CSF.Screenplay.Selenium.UseABaseUri.html",
    "title": "Class UseABaseUri | Screenplay",
    "summary": "Class UseABaseUri Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll Screenplay ability which allows an Actor to use a base Uri, 'completing' relative Uris at runtime. public class UseABaseUri : ICanReport Inheritance object UseABaseUri Implements ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This ability enables the use of a technique whereby the environment/location of a web application (which is being tested or manipulated by the Selenium Extension for Screenplay) may be set and changed at runtime, instead of hard-coded. This could be particularly useful if you are using this extension for testing and wish to be able to run the same suite of tests against multiple environments. For example: Locally, on a developer's computer, with a base Uri such as https://localhost:8080/ On a testing environment, with a base Uri such as https://testing.example.com/ On a staging environment, with a base Uri such as https://staging.example.com/ If you wish to use this technique then when writing instances of NamedUri, specify these using relative Uris, such as new NamedUri(\"user/shoppingCart\", \"the user's shopping cart\"). Then, grant your actor this ability, using IsAbleTo(object): // The following would not realistically be expected to be seen together in one place. // This is a 'compressed' example for brevity. // In a realistic Screenplay, the Actor set-up would be in an IPersona implementation, // the NamedUri would be declared in a library class and the Actor's performance would // be within an IPerformable implementation. using CSF.Screenplay.Selenium; using static CSF.Screenplay.Selenium.PerformableBuilder; var useABaseUri = new UseABaseUri(new Uri(\"https://testing.example.com/\")); myActor.IsAbleTo(useABaseUri); // Details of getting a BrowseTheWeb ability instance are omitted for brevity. myActor.IsAbleTo(GetBrowseTheWeb()); var shoppingCart = new NamedUri(\"user/shoppingCart\", \"the user's shopping cart\"); await myActor.PerformAsync(OpenTheUrl(shoppingCart)); // Actually opens the URL https://testing.example.com/user/shoppingCart The Uri to use as the base Uri does not need to be hard-coded, it could come from configuration or an environment variable etc. When the actor makes use of the BrowseTheWeb ability and opens a Url using the performable returned from OpenTheUrl(NamedUri), the specified named Uri will be rebased to the base Uri specified by this ability. Constructors UseABaseUri(Uri) Initializes a new instance of the UseABaseUri class. public UseABaseUri(Uri baseUri) Parameters baseUri Uri The base URI. Remarks When specifying a base URI via this ability, remember to include a trailing slash where applicable. The manner in which relative URIs will be resolved into absolute ones, when this ability is present, is via the two-parameter overload of the Uri constructor, taking a Uri and a string. As stated in the documentation for this constructor: If the baseUri has relative parts (like /api), then the relative part must be terminated with a slash, (like /api/), if the relative part of baseUri is to be preserved in the constructed Uri. The Uri held within this ability will be used as that base URI, as described above. Properties BaseUri Gets the base URI which is associated with the current ability instance. public Uri BaseUri { get; } Property Value Uri Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. See Also OpenUrl OpenUrlRespectingBase NamedUri"
  },
  "api/CSF.Screenplay.Selenium.UseADefaultWaitTime.html": {
    "href": "api/CSF.Screenplay.Selenium.UseADefaultWaitTime.html",
    "title": "Class UseADefaultWaitTime | Screenplay",
    "summary": "Class UseADefaultWaitTime Namespace CSF.Screenplay.Selenium Assembly CSF.Screenplay.Selenium.dll An ability which specifies a default amount of time for performables which involve waiting. that allows an Actor to use a default time for which to wait for BrowseTheWeb WebDriver operations to complete. public class UseADefaultWaitTime : ICanReport Inheritance object UseADefaultWaitTime Implements ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks A small number of performables within the Selenium extension for Screenplay involve waiting, along with the opportunity to specify a timeout. If no timeout is specified and the Actor does not have this ability then the default timeout is 5 seconds, as specified by DefaultTimeout. If the Actor has this ability then, if they perform a waiting-type action and no timeout is explicitly specified, they will use the default timeout which is specified within this ability instead of the 5-second hard-coded default. Constructors UseADefaultWaitTime(TimeSpan) Initializes a new instance of the UseADefaultWaitTime class with the specified wait time. public UseADefaultWaitTime(TimeSpan waitTime) Parameters waitTime TimeSpan The default time for which to wait. Properties WaitTime Gets the default time for which to wait. public TimeSpan WaitTime { get; } Property Value TimeSpan Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. See Also Wait ClickAndWaitForDocumentReady"
  },
  "api/CSF.Screenplay.Selenium.html": {
    "href": "api/CSF.Screenplay.Selenium.html",
    "title": "Namespace CSF.Screenplay.Selenium | Screenplay",
    "summary": "Namespace CSF.Screenplay.Selenium Classes ActorExtensions Extension methods for actors. BrowseTheWeb Screenplay ability which allows an Actor to browse the web using a Selenium WebDriver. BrowseTheWebExtensions Extension methods for the BrowseTheWeb ability. BrowserQuirks Static class which holds known browser quirks information. Colors Static type containing the pre-defined colors for the web. NamedScript A model representing a pre-written piece of executable JavaScript, which accepts no parameters and which returns no result. NamedScriptBasis A basis class for named scripts, not for use in applications of Screenplay. NamedScriptWithResult<TResult> A model representing a pre-written piece of executable JavaScript, which accepts no parameters, but which is expected to return a result. NamedScriptWithResult<T1, TResult> A model representing a pre-written piece of executable JavaScript, which accepts 1 parameter, but which is expected to return a result. NamedScriptWithResult<T1, T2, TResult> A model representing a pre-written piece of executable JavaScript, which accepts 2 parameters, but which is expected to return a result. NamedScriptWithResult<T1, T2, T3, TResult> A model representing a pre-written piece of executable JavaScript, which accepts 3 parameters, but which is expected to return a result. NamedScriptWithResult<T1, T2, T3, T4, TResult> A model representing a pre-written piece of executable JavaScript, which accepts 4 parameters, but which is expected to return a result. NamedScriptWithResult<T1, T2, T3, T4, T5, TResult> A model representing a pre-written piece of executable JavaScript, which accepts 5 parameters, but which is expected to return a result. NamedScriptWithResult<T1, T2, T3, T4, T5, T6, TResult> A model representing a pre-written piece of executable JavaScript, which accepts 6 parameters, but which is expected to return a result. NamedScriptWithResult<T1, T2, T3, T4, T5, T6, T7, TResult> A model representing a pre-written piece of executable JavaScript, which accepts 7 parameters, but which is expected to return a result. NamedScript<T1> A model representing a pre-written piece of executable JavaScript, which accepts 1 parameter and which returns no result. NamedScript<T1, T2> A model representing a pre-written piece of executable JavaScript, which accepts 2 parameters and which returns no result. NamedScript<T1, T2, T3> A model representing a pre-written piece of executable JavaScript, which accepts 3 parameters and which returns no result. NamedScript<T1, T2, T3, T4> A model representing a pre-written piece of executable JavaScript, which accepts 4 parameters and which returns no result. NamedScript<T1, T2, T3, T4, T5> A model representing a pre-written piece of executable JavaScript, which accepts 5 parameters and which returns no result. NamedScript<T1, T2, T3, T4, T5, T6> A model representing a pre-written piece of executable JavaScript, which accepts 6 parameters and which returns no result. NamedScript<T1, T2, T3, T4, T5, T6, T7> A model representing a pre-written piece of executable JavaScript, which accepts 7 parameters and which returns no result. NamedUri Model containing a Uri with a corresponding human-readable name. NamedUriExtensions Extension methods for NamedUri. PerformableBuilder Builder type for creating performables which interact with Selenium WebDriver via Screenplay. Scripts A repository of named JavaScripts which are distributed with Screenplay's Selenium integration. ServiceCollectionExtensions Extension methods for IServiceCollection. SetTheValueBuilder Builds actions for setting values in Selenium web elements. UseABaseUri Screenplay ability which allows an Actor to use a base Uri, 'completing' relative Uris at runtime. UseADefaultWaitTime An ability which specifies a default amount of time for performables which involve waiting. that allows an Actor to use a default time for which to wait for BrowseTheWeb WebDriver operations to complete. Structs Color Immutable type represents a color on the web, in a manner which may be converted and compared between web-supported formats. Interfaces SetTheValueBuilder.IChoosesValue An object from which a consumer may choose a value to set into the element."
  },
  "api/CSF.Screenplay.ServiceCollectionAdapter.html": {
    "href": "api/CSF.Screenplay.ServiceCollectionAdapter.html",
    "title": "Class ServiceCollectionAdapter | Screenplay",
    "summary": "Class ServiceCollectionAdapter Namespace CSF.Screenplay Assembly CSF.Screenplay.ReqnrollPlugin.dll Adapter class which allows a Reqnroll/BoDi IObjectContainer to be used as an IServiceCollection. public class ServiceCollectionAdapter : IServiceCollection, IList<ServiceDescriptor>, ICollection<ServiceDescriptor>, IEnumerable<ServiceDescriptor>, IEnumerable Inheritance object ServiceCollectionAdapter Implements IServiceCollection IList<ServiceDescriptor> ICollection<ServiceDescriptor> IEnumerable<ServiceDescriptor> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods ScreenplayServiceCollectionExtensions.AddScreenplay(IServiceCollection) ServiceCollectionExtensions.AddSelenium(IServiceCollection) ServiceCollectionExtensions.AddEnumerableAdapter<TService>(IServiceCollection) ServiceCollectionExtensions.AddOptionsAdapters<TOptions>(IServiceCollection) ServiceCollectionExtensions.AddScreenplayPlugin(IServiceCollection) Remarks This adapter class is highly limited and supports only a tiny subset of IServiceCollection's functionality. For many methods, and the indexer for ServiceDescriptor, it will raise NotSupportedException. The only functionality supported is IsReadOnly and Add(ServiceDescriptor). Constructors ServiceCollectionAdapter(IObjectContainer) Initialises an instance of ServiceCollectionAdapter. public ServiceCollectionAdapter(IObjectContainer wrapped) Parameters wrapped IObjectContainer The BoDi object container Exceptions ArgumentNullException If wrapped is null. Properties Count Not supported, always returns zero. public int Count { get; } Property Value int IsReadOnly Partially supported, always returns false public bool IsReadOnly { get; } Property Value bool this[int] Not supported; always throws NotSupportedException. public ServiceDescriptor this[int index] { get; set; } Parameters index int Property Value ServiceDescriptor Exceptions NotSupportedException Always thrown Methods Add(ServiceDescriptor) Partially-supported, will add the specified service descriptor to the current object container. public void Add(ServiceDescriptor item) Parameters item ServiceDescriptor The service descriptor Remarks This method supports only transient or singleton services. If the Lifetime present on the item specified is Scoped then the service descriptor will not be added and will be silently ignored. In reality, the Reqnroll BoDi object container only really supports singleton services at this level. So, any services added as Transient will actually become singletons here. Whilst the BoDi container does support scoped services, they must be added directly to the scope instance and cannot be added in advance. Exceptions ArgumentNullException If item is null. ArgumentException If the item has a null ServiceType. Clear() Not supported; always throws NotSupportedException. public void Clear() Exceptions NotSupportedException Always thrown Contains(ServiceDescriptor) Not supported; always throws NotSupportedException. public bool Contains(ServiceDescriptor item) Parameters item ServiceDescriptor Returns bool Exceptions NotSupportedException Always thrown CopyTo(ServiceDescriptor[], int) Not supported; always throws NotSupportedException. public void CopyTo(ServiceDescriptor[] array, int arrayIndex) Parameters array ServiceDescriptor[] arrayIndex int Exceptions NotSupportedException Always thrown GetEnumerator() Not supported; always throws NotSupportedException. public IEnumerator<ServiceDescriptor> GetEnumerator() Returns IEnumerator<ServiceDescriptor> Exceptions NotSupportedException Always thrown IndexOf(ServiceDescriptor) Not supported; always throws NotSupportedException. public int IndexOf(ServiceDescriptor item) Parameters item ServiceDescriptor Returns int Exceptions NotSupportedException Always thrown Insert(int, ServiceDescriptor) Not supported; always throws NotSupportedException. public void Insert(int index, ServiceDescriptor item) Parameters index int item ServiceDescriptor Exceptions NotSupportedException Always thrown Remove(ServiceDescriptor) Not supported; always throws NotSupportedException. public bool Remove(ServiceDescriptor item) Parameters item ServiceDescriptor Returns bool Exceptions NotSupportedException Always thrown RemoveAt(int) Not supported; always throws NotSupportedException. public void RemoveAt(int index) Parameters index int Exceptions NotSupportedException Always thrown"
  },
  "api/CSF.Screenplay.ServiceCollectionExtensions.html": {
    "href": "api/CSF.Screenplay.ServiceCollectionExtensions.html",
    "title": "Class ServiceCollectionExtensions | Screenplay",
    "summary": "Class ServiceCollectionExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.ReqnrollPlugin.dll Extension methods for IServiceCollection. public static class ServiceCollectionExtensions Inheritance object ServiceCollectionExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddEnumerableAdapter<TService>(IServiceCollection) Adds EnumerableResolutionAdapter<T> to the DI container for the service type TService. public static IServiceCollection AddEnumerableAdapter<TService>(this IServiceCollection services) where TService : class Parameters services IServiceCollection A service collection Returns IServiceCollection The same service collection, so calls may be chained Type Parameters TService The service type for which to add the adapter Remarks This is required to work around a limitation of the BoDi DI container which ships with Reqnroll/SpecFlow. See EnumerableResolutionAdapter<T> for more information. AddOptionsAdapters<TOptions>(IServiceCollection) Adds enumerable adapters for service types which are required in order to enable the Microsoft Options Pattern with the specified options type. public static IServiceCollection AddOptionsAdapters<TOptions>(this IServiceCollection services) where TOptions : class Parameters services IServiceCollection A service collection Returns IServiceCollection The same service collection, so calls may be chained Type Parameters TOptions The options type Remarks This is required to work around a limitation of the BoDi DI container which ships with Reqnroll/SpecFlow. See EnumerableResolutionAdapter<T> for more information. Use of the options pattern requires the resolution of three enumerable types: IConfigureOptions<TOptions>, IPostConfigureOptions<TOptions> and IValidateOptions<TOptions>. This method uses AddEnumerableAdapter<TService>(IServiceCollection) for each of those types. AddScreenplayPlugin(IServiceCollection) Adds the services to DI which are required to use the Reqnroll/SpecFlow plugin. public static IServiceCollection AddScreenplayPlugin(this IServiceCollection services) Parameters services IServiceCollection A service collection Returns IServiceCollection The same service collection, so calls may be chained"
  },
  "api/CSF.Screenplay.ServiceProviderAdapter.html": {
    "href": "api/CSF.Screenplay.ServiceProviderAdapter.html",
    "title": "Class ServiceProviderAdapter | Screenplay",
    "summary": "Class ServiceProviderAdapter Namespace CSF.Screenplay Assembly CSF.Screenplay.ReqnrollPlugin.dll Adapter class which allows a Reqnroll/BoDi IObjectContainer to be used as an IServiceProvider. public class ServiceProviderAdapter : IServiceProvider Inheritance object ServiceProviderAdapter Implements IServiceProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ServiceProviderAdapter(IObjectContainer) Initialises an instance of ServiceProviderAdapter. public ServiceProviderAdapter(IObjectContainer wrapped) Parameters wrapped IObjectContainer The BoDi object container Exceptions ArgumentNullException If wrapped is null. Methods GetService(Type) public object GetService(Type serviceType) Parameters serviceType Type Returns object"
  },
  "api/CSF.Screenplay.StageAdapter.html": {
    "href": "api/CSF.Screenplay.StageAdapter.html",
    "title": "Class StageAdapter | Screenplay",
    "summary": "Class StageAdapter Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll An adapter which enables the use of IStage within an NUnit3 test, without needing to parameter-inject the instance as Lazy<IStage>. public sealed class StageAdapter : IStage Inheritance object StageAdapter Implements IStage Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Due to NUnit architectural limitations, injectable parameters cannot be resolved from DI at the point the test method is built. If we were to attempt this, then the parameter value would not be associated with the correct Screenplay/DI scope (and thus Event Bus). This is due to the two-process model which NUnit uses; one process for building the test methods and another process for running the tests. By using an adapter with Lazy resolution of the real implementation, we ensure that DI resolution is deferred into the test-run process and not the test-building process. Constructors StageAdapter(Guid) Creates a new instance of StageAdapter for the specified performance identity. public StageAdapter(Guid performanceIdentity) Parameters performanceIdentity Guid A performance identity, corresponding to PerformanceIdentity. Properties Cast Gets the cast to which the current stage is linked. public ICast Cast { get; } Property Value ICast Methods GetSpotlitActor() Gets the actor which is currently in the spotlight. public Actor GetSpotlitActor() Returns Actor The actor who has previously been placed in the spotlight, or a null reference if there is presently no actor in the spotlight. Spotlight(Actor) Places the specified actor into the spotlight, making them 'the current actor' on this stage. public void Spotlight(Actor actor) Parameters actor Actor Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the specified actor. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If the specified actor is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Exceptions ArgumentNullException If the actor is null. Spotlight(IPersona) Places an actor matching the specified persona into the spotlight, making them 'the current actor' on this stage. public Actor Spotlight(IPersona persona) Parameters persona IPersona Returns Actor The actor instance which was placed into the spotlight. Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the actor derived from the persona. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If actor indicated by the persona is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. When spotlighting a persona, the actor instance is retrieved from an ICast based upon that same persona. See GetActor(IPersona) for more information. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). Consider using Spotlight<TPersona>(IStage) instead of this method; the generic version takes care of resolving the persona instance from dependency injection for you. Exceptions ArgumentNullException If the actor is null. TurnSpotlightOff() Removes any existing actor from the spotlight, ensuring that no actor is in the spotlight. public Actor TurnSpotlightOff() Returns Actor If an actor was previously in the spotlight, and has now been removed, then this method returns that actor; otherwise it will return a null reference. Remarks If there was already no actor in the spotlight when this method is executed then it will have no effect, the spotlight will remain empty and this method will return null."
  },
  "api/CSF.Screenplay.StageExtensions.html": {
    "href": "api/CSF.Screenplay.StageExtensions.html",
    "title": "Class StageExtensions | Screenplay",
    "summary": "Class StageExtensions Namespace CSF.Screenplay Assembly CSF.Screenplay.Abstractions.dll Extension methods for IStage. public static class StageExtensions Inheritance object StageExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Spotlight<TPersona>(IStage) Places an actor matching the specified persona into the spotlight, making them 'the current actor' on this stage. public static Actor Spotlight<TPersona>(this IStage stage) where TPersona : class, IPersona Parameters stage IStage The stage on which to spotlight the actor. Returns Actor The actor instance which was placed into the spotlight. Type Parameters TPersona A concrete type of IPersona from which to get an actor. Remarks A maximum of one actor may be in the spotlight at any time, so if a different actor is already in the spotlight as this method is used, then they will be implicitly removed and replaced by the actor derived from the persona. The actor who is in the spotlight may be retrieved by calling GetSpotlitActor(). If actor indicated by the persona is already in the spotlight then this method will have no effect, the actor will remain in the spotlight. When spotlighting a persona, the actor instance is retrieved from an ICast based upon that same persona. See GetActor(IPersona) for more information. To remove an actor from the spotlight without replacing them, use TurnSpotlightOff(). This method is the recommended way of putting an actor based upon a persona in the spotlight, as it takes care of resolving the persona from dependency injection automatically. Exceptions ArgumentNullException If the actor is null."
  },
  "api/CSF.Screenplay.TestMethodBuilder.html": {
    "href": "api/CSF.Screenplay.TestMethodBuilder.html",
    "title": "Class TestMethodBuilder | Screenplay",
    "summary": "Class TestMethodBuilder Namespace CSF.Screenplay Assembly CSF.Screenplay.NUnit.dll Builder class which is used to create NUnit3 test method instances for a Screenplay-based test. public static class TestMethodBuilder Inheritance object TestMethodBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods BuildFrom(IMethodInfo, Test) Gets a collection of NUnit3 TestMethod instances for the specified method and test. public static IEnumerable<TestMethod> BuildFrom(IMethodInfo method, Test suite) Parameters method IMethodInfo The NUnit method object for a test suite Test The NUnit test suite object Returns IEnumerable<TestMethod> A collection of NUnit test method instances Remarks This method handles the resolution of the supported injectable services, which may be used in tests by adding them as parameters to the NUnit test method. Exceptions ArgumentNullException If any parameter is null"
  },
  "api/CSF.Screenplay.WebApis.Endpoint-1.html": {
    "href": "api/CSF.Screenplay.WebApis.Endpoint-1.html",
    "title": "Class Endpoint<TResult> | Screenplay",
    "summary": "Class Endpoint<TResult> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll A Web API endpoint which has no expected request payload and which is expected to return a response body that exposes a strongly-typed object. public class Endpoint<TResult> : EndpointBase, IHasName Type Parameters TResult The type of object which is expected to be exposed by the HTTP response content Inheritance object EndpointBase Endpoint<TResult> Implements IHasName Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. The manner in which this endpoint exposes the strongly typed response object is undefined within the endpoint itself. It is down to a performable implementation to deserialize the result object from the HTTP response content. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should override GetHttpRequestMessageBuilder() with a method that calls the base implementation and then further manipulates the message builder before returning it. When using or deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors Endpoint(string, HttpMethod) Initializes a new instance of Endpoint<TResult> with a relative URI and an optional HTTP method. public Endpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Endpoint(Uri, HttpMethod) Initializes a new instance of Endpoint<TResult> with a URI and an optional HTTP method. public Endpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder() Gets a HttpRequestMessageBuilder from the state of the current instance. public virtual HttpRequestMessageBuilder<TResult> GetHttpRequestMessageBuilder() Returns HttpRequestMessageBuilder<TResult> An HTTP request message builder See Also EndpointBase Endpoint ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResult> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.Endpoint.html": {
    "href": "api/CSF.Screenplay.WebApis.Endpoint.html",
    "title": "Class Endpoint | Screenplay",
    "summary": "Class Endpoint Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll A Web API endpoint which has no expected request payload and which is not expected to return a response body. public class Endpoint : EndpointBase, IHasName Inheritance object EndpointBase Endpoint Implements IHasName Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should override GetHttpRequestMessageBuilder() with a method that calls the base implementation and then further manipulates the message builder before returning it. When using or deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors Endpoint(string, HttpMethod) Initializes a new instance of Endpoint with a relative URI and an optional HTTP method. public Endpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Endpoint(Uri, HttpMethod) Initializes a new instance of Endpoint with a URI and an optional HTTP method. public Endpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder() Gets a HttpRequestMessageBuilder from the state of the current instance. public virtual HttpRequestMessageBuilder GetHttpRequestMessageBuilder() Returns HttpRequestMessageBuilder An HTTP request message builder See Also EndpointBase Endpoint<TResult> ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResult> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.EndpointBase.html": {
    "href": "api/CSF.Screenplay.WebApis.EndpointBase.html",
    "title": "Class EndpointBase | Screenplay",
    "summary": "Class EndpointBase Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Abstract base class for types which represent web API endpoints. public abstract class EndpointBase : IHasName Inheritance object EndpointBase Implements IHasName Derived Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResult> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks An endpoint is broadly a description of a Web API URL and the corresponding HTTP method (aka \"verb\") such as GET or POST. Instances of endpoints (types which derive from this base class) are typically stored as static readonly values in Screenplay-based logic. Here, they can be reused by tasks or other performables. Choose an appropriate implementation of this type based upon your intended use case. Endpoints which expect the API to return a strongly-typed result within the response body include a generic type parameter for the type of that result object. Also, endpoints which expect a request body: \"parameterized endpoints\" include a generic type parameter for the type of that request payload. There are also specialisations of these parameterized endpoint classes for those which expect an object serialized to JSON as their request payload. When writing custom endpoints, do not derive directly from this type. Usually one of the following pre-written endpoint types will be suitable for your use case. If not, pick the one which most closely matches your use-case and derive from that. Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResult> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult> For more information, see the documentation article for using web APIs. Constructors EndpointBase(string, HttpMethod) Initializes a new instance of a type which derives from EndpointBase with a relative URI and an optional HTTP method. protected EndpointBase(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). EndpointBase(Uri, HttpMethod) Initializes a new instance of a type which derives from EndpointBase with a URI and an optional HTTP method. protected EndpointBase(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Properties Name Gets the human-readable name of the current object. public virtual string Name { get; init; } Property Value string Examples For an endpoint implementation which represents a GET request to a user profile API, this property could be overridden so that it includes the user ID of the user which is requested. Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Where it comes to endpoints, it is normal that the human-readable name might be influenced by state which is held within the specific endpoint implementation. In these cases, developers are encouraged to override this property, providing a name which includes the relevant values. Timeout Gets or sets an optional timeout duration for requests built from this endpoint. public TimeSpan? Timeout { get; init; } Property Value TimeSpan? Remarks If this set to a non-null value, then the HTTP client used to make the request will include cancellation after an amount of time (equal to this timespan) has passed. This logic is handled within the MakeWebApiRequests action. If this action is not used then this timeout might not be honoured. The logic for honouring this timeout is contained within the performables which are shipped with this library: SendTheHttpRequest SendTheHttpRequestAndGetTheResponse<TResponse> SendTheHttpRequestAndGetJsonResponse<TResponse> If different performables are used to interact with the current endpoint then they must implement any timeout-related logic themselves, or else this value will not be honoured. Methods GetBaseHttpRequestMessageBuilder() Gets a HttpRequestMessageBuilder from the state of the current instance. protected HttpRequestMessageBuilder GetBaseHttpRequestMessageBuilder() Returns HttpRequestMessageBuilder An HTTP request message builder Remarks Derived types should make use of this method to get the request message builder from the state of this base class. They may then further-customize the message builder according to their own logic. The message builder returned from this method will respect the following state from the endpoint. The request URI specified via the constructor The request method, if specified via the constructor The Name of this endpoint The Timeout for requests to this endpoint, if specified GetBaseHttpRequestMessageBuilder<TResponse>() Gets a HttpRequestMessageBuilder<TResponse> from the state of the current instance, with information about the expected response type. protected HttpRequestMessageBuilder<TResponse> GetBaseHttpRequestMessageBuilder<TResponse>() Returns HttpRequestMessageBuilder<TResponse> An HTTP request message builder Type Parameters TResponse Remarks Derived types which expect a strongly-typed response from the API should make use of this method to get the request message builder from the state of this base class. They may then further-customize the message builder according to their own logic. The message builder returned from this method will respect the following state from the endpoint. The request URI specified via the constructor The request method, if specified via the constructor The Name of this endpoint The Timeout for requests to this endpoint, if specified See Also Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters> ParameterizedEndpoint<TParameters, TResult> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.HttpRequestMessageBuilder-1.html": {
    "href": "api/CSF.Screenplay.WebApis.HttpRequestMessageBuilder-1.html",
    "title": "Class HttpRequestMessageBuilder<TResponse> | Screenplay",
    "summary": "Class HttpRequestMessageBuilder<TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An object which can create an HttpRequestMessage for use with an HTTP client, which is expected to expose a response of a particular type. public record HttpRequestMessageBuilder<TResponse> : HttpRequestMessageBuilder, IHasName, IFormattableValue, IEquatable<HttpRequestMessageBuilder>, IEquatable<HttpRequestMessageBuilder<TResponse>> Type Parameters TResponse The type of the response expected from the endpoint to which this request would be sent. Inheritance object HttpRequestMessageBuilder HttpRequestMessageBuilder<TResponse> Implements IHasName IFormattableValue IEquatable<HttpRequestMessageBuilder> IEquatable<HttpRequestMessageBuilder<TResponse>> Inherited Members HttpRequestMessageBuilder.RequestUri HttpRequestMessageBuilder.Method HttpRequestMessageBuilder.Content HttpRequestMessageBuilder.Version HttpRequestMessageBuilder.Headers HttpRequestMessageBuilder.Name HttpRequestMessageBuilder.Timeout HttpRequestMessageBuilder.VersionPolicy HttpRequestMessageBuilder.Options HttpRequestMessageBuilder.CreateRequestMessage() HttpRequestMessageBuilder.FormatForReport() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Please note that this type differs in form depending upon the .NET version under which it is consumed. If consuming this type from logic which targets .NET Standard 2.0 or .NET Framework 4.6.2 then this type is a class. In that scenario its properties are mutable and the developer should take care to ensure that they do not mutate/alter its state inadvertently. Developers should ensure that they manually copy the state from the current instance into a new instance instead of modifying an existing instance. In these target frameworks, a Clone method has been provided to assist with this. When consuming this from .NET 5 or higher, this type is instead a record and is immutable by design. All properties are init-only. Additionally, in .NET 5+, some additional properties are available, supporting features of HttpRequestMessage which are unavailable in lower .NET versions. When using .NET 5, developers may use nondestructive mutation with the with keyword/expression to create a copy of the current instance but with some differences. This difference between this type and its non-generic counterpart is that this type includes generic information about the expected response type. This can aid subsequent type-safety in consuming logic."
  },
  "api/CSF.Screenplay.WebApis.HttpRequestMessageBuilder.html": {
    "href": "api/CSF.Screenplay.WebApis.HttpRequestMessageBuilder.html",
    "title": "Class HttpRequestMessageBuilder | Screenplay",
    "summary": "Class HttpRequestMessageBuilder Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An object which can create an HttpRequestMessage for use with an HTTP client. public record HttpRequestMessageBuilder : IHasName, IFormattableValue, IEquatable<HttpRequestMessageBuilder> Inheritance object HttpRequestMessageBuilder Implements IHasName IFormattableValue IEquatable<HttpRequestMessageBuilder> Derived HttpRequestMessageBuilder<TResponse> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Please note that this type differs in form depending upon the .NET version under which it is consumed. If consuming this type from logic which targets .NET Standard 2.0 or .NET Framework 4.6.2 then this type is a class. In that scenario its properties are mutable and the developer should take care to ensure that they do not mutate/alter its state inadvertently. Developers should ensure that they manually copy the state from the current instance into a new instance instead of modifying an existing instance. In these target frameworks, a Clone method has been provided to assist with this. When consuming this from .NET 5 or higher, this type is instead a record and is immutable by design. All properties are init-only. Additionally, in .NET 5+, some additional properties are available, supporting features of HttpRequestMessage which are unavailable in lower .NET versions. When using .NET 5, developers may use nondestructive mutation with the with keyword/expression to create a copy of the current instance but with some differences. Properties Content Gets or sets the content which will be sent with the request: the request body. public HttpContent Content { get; init; } Property Value HttpContent Headers Gets or sets the HTTP headers which will be sent with the request, corresponding to Headers. public NameValueRecordCollection<string, string> Headers { get; init; } Property Value NameValueRecordCollection<string, string> Method Gets or sets the HTTP method (aka \"verb\") which shall be used to send the request. public HttpMethod Method { get; init; } Property Value HttpMethod Name Gets the human-readable name of the current object. public string Name { get; init; } Property Value string Remarks null is strongly discouraged here. All types which implement IHasName should return a non-null response from this property. Options Gets or sets the HTTP web request options, corresponding to Options. public NameValueRecordCollection<string, object> Options { get; init; } Property Value NameValueRecordCollection<string, object> Remarks Note that this property is supported only for .NET 5 and above. It is unavailable in lower .NET versions, including .NET Standard and .NET Framework. RequestUri Gets or sets the Uri to which the HTTP request shall be sent. public Uri RequestUri { get; init; } Property Value Uri Timeout Gets or sets an optional timeout duration for requests built from this builder. public TimeSpan? Timeout { get; init; } Property Value TimeSpan? Remarks If this set to a non-null value, then the HTTP client used to make the request will include cancellation after an amount of time (equal to this timespan) has passed. This logic is handled within the MakeWebApiRequests action. If this action is not used then this timeout might not be honoured. Version Gets or sets the HTTP version which shall be used by the message. public Version Version { get; init; } Property Value Version Remarks The documentation for the Version property notes that it would default to 2.0 for .NET Core 2.1 or 2.2, and defaults to 1.1 for all other versions of .NET or .NET Framework. This property will always default to 1.1 regardless of the target framework. VersionPolicy Gets or sets the HTTP version policy, corresponding to VersionPolicy. public HttpVersionPolicy VersionPolicy { get; init; } Property Value HttpVersionPolicy Remarks Note that this property is supported only for .NET 5 and above. It is unavailable in lower .NET versions, including .NET Standard and .NET Framework. Methods CreateRequestMessage() Creates and returns an HTTP request message. public HttpRequestMessage CreateRequestMessage() Returns HttpRequestMessage An HTTP request message Remarks The request message is typically created from the state of the current object instance. Multiple usages of this method must create a new request message each time. Unless some state has been altered between usages, though, each of these messages is likely to have the same data/property values. If the state of the current instance does not specify a Method; IE the method is null, then Get will be used. FormatForReport() Gets a human-readable formatted string which represents the current object instance, suitable to be used in a Screenplay report. public string FormatForReport() Returns string A formatted string which represents the current instance."
  },
  "api/CSF.Screenplay.WebApis.HttpResponseMessageAndResponseType-1.html": {
    "href": "api/CSF.Screenplay.WebApis.HttpResponseMessageAndResponseType-1.html",
    "title": "Class HttpResponseMessageAndResponseType<TResponse> | Screenplay",
    "summary": "Class HttpResponseMessageAndResponseType<TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Wraps an HttpResponseMessage but also provides information about the expected response type from that message. public class HttpResponseMessageAndResponseType<TResponse> Type Parameters TResponse The expected response type. Inheritance object HttpResponseMessageAndResponseType<TResponse> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HttpResponseMessageAndResponseType(HttpResponseMessage) Initializes a new instance of HttpResponseMessageAndResponseType<TResponse>. public HttpResponseMessageAndResponseType(HttpResponseMessage responseMessage) Parameters responseMessage HttpResponseMessage The HTTP response message. Exceptions ArgumentNullException If responseMessage is null. Properties ResponseMessage Gets the HTTP response message. public HttpResponseMessage ResponseMessage { get; } Property Value HttpResponseMessage"
  },
  "api/CSF.Screenplay.WebApis.JsonEndpoint-1.html": {
    "href": "api/CSF.Screenplay.WebApis.JsonEndpoint-1.html",
    "title": "Class JsonEndpoint<TParameters> | Screenplay",
    "summary": "Class JsonEndpoint<TParameters> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Base type for a Web API endpoint which accepts a request payload in the form of a strongly typed object serialized to JSON string, but which is not expected to return a response body. public class JsonEndpoint<TParameters> : ParameterizedEndpoint<TParameters>, IHasName Type Parameters TParameters The type of the parameters object which is required to create an HTTP request message Inheritance object EndpointBase ParameterizedEndpoint<TParameters> JsonEndpoint<TParameters> Implements IHasName Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should override GetHttpRequestMessageBuilder(TParameters) with a method that calls the base implementation and then further manipulates the message builder before returning it. When deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors JsonEndpoint(string, HttpMethod) Initializes a new instance of JsonEndpoint<TParameters> with a relative URI and an optional HTTP method. public JsonEndpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). JsonEndpoint(Uri, HttpMethod) Initializes a new instance of JsonEndpoint<TParameters> with a URI and an optional HTTP method. public JsonEndpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder(TParameters) Gets a HttpRequestMessageBuilder from the state of the current instance and the specified parameters value. public override HttpRequestMessageBuilder GetHttpRequestMessageBuilder(TParameters parameters) Parameters parameters TParameters The parameters required to create an HTTP request builder Returns HttpRequestMessageBuilder An HTTP request message builder Remarks This method serializes the parameters value into a JSON string and sets it into the HTTP request content: Content. See Also EndpointBase Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters, TResult> ParameterizedEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.JsonEndpoint-2.html": {
    "href": "api/CSF.Screenplay.WebApis.JsonEndpoint-2.html",
    "title": "Class JsonEndpoint<TParameters, TResult> | Screenplay",
    "summary": "Class JsonEndpoint<TParameters, TResult> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Base type for a Web API endpoint which accepts a request payload in the form of a strongly typed object serialized to JSON string, and which is expected to return a response body that exposes a strongly-typed object. public class JsonEndpoint<TParameters, TResult> : ParameterizedEndpoint<TParameters, TResult>, IHasName Type Parameters TParameters The type of the parameters object which is required to create an HTTP request message TResult The type of response that the endpoint is expected to return. Inheritance object EndpointBase ParameterizedEndpoint<TParameters, TResult> JsonEndpoint<TParameters, TResult> Implements IHasName Inherited Members ParameterizedEndpoint<TParameters, TResult>.GetHttpRequestMessageBuilder(TParameters) EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. The manner in which this endpoint exposes the strongly typed response object is undefined within the endpoint itself. It is down to a performable implementation to deserialize the result object from the HTTP response content. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should override GetHttpRequestMessageBuilder(TParameters) with a method that calls the base implementation and then further manipulates the message builder before returning it. When deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors JsonEndpoint(string, HttpMethod) Initializes a new instance of JsonEndpoint<TParameters, TResult> with a relative URI and an optional HTTP method. public JsonEndpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). JsonEndpoint(Uri, HttpMethod) Initializes a new instance of JsonEndpoint<TParameters, TResult> with a URI and an optional HTTP method. public JsonEndpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder(TParameters) Gets a HttpRequestMessageBuilder<TResponse> from the state of the current instance and the specified parameters value. public override HttpRequestMessageBuilder<TResult> GetHttpRequestMessageBuilder(TParameters parameters) Parameters parameters TParameters The parameters required to create an HTTP request builder Returns HttpRequestMessageBuilder<TResult> An HTTP request message builder Remarks This method serializes the parameters value into a JSON string and sets it into the HTTP request content: Content. See Also EndpointBase Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters, TResult> ParameterizedEndpoint<TParameters> JsonEndpoint<TParameters>"
  },
  "api/CSF.Screenplay.WebApis.MakeWebApiRequests.html": {
    "href": "api/CSF.Screenplay.WebApis.MakeWebApiRequests.html",
    "title": "Class MakeWebApiRequests | Screenplay",
    "summary": "Class MakeWebApiRequests Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An ability class which allows Actors to make HTTP web API requests using HttpClient. public sealed class MakeWebApiRequests : IDisposable Inheritance object MakeWebApiRequests Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties DefaultClient Gets or sets the HTTP client, for scenarios in which the actor needs to use a single client. public HttpClient DefaultClient { get; set; } Property Value HttpClient Remarks If the actor needs to know about more than one HTTP client, then consider using the indexer instead, which allows storage of more than one client, using arbitrary names. this[string] Gets or sets an HTTP client with a specified name. public HttpClient this[string name] { get; set; } Parameters name string The name of the HTTP client for which this instance is getting or setting. Property Value HttpClient An HTTP client associated with the specified name, or null reference if no HTTP client has been configured for that name. Remarks Use this indexer if an actor needs to manage more than one HTTP client. The key to this index - a name - is completely arbitrary and may mean whatever your needs require. Names must not be null and should not be empty or whitespace-only strings. The name DefaultClient is reserved for the value of DefaultClient. If the actor needs to use only a single HTTP client then yoy may find the DefaultClient property easier to use, instead of this indexer. Exceptions ArgumentNullException If name is null. Methods AddClient(string, string) Adds a new HTTP client to the current instance, with an optional base URI and client name. public void AddClient(string baseUri = null, string clientName = null) Parameters baseUri string Optional, the base URI to which requests should be sent clientName string Optional, the name of the client. If omitted then the new client will be the DefaultClient Remarks This method is a shorthand for adding a new item to either DefaultClient or the class indexer. It allows the convenient configuration of a new HttpClient with just a base URI to which requests should be sent. Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() GetClient(string) Gets an HTTP client with the specified name. public HttpClient GetClient(string clientName = null) Parameters clientName string An optional client name, if omitted then the default client will be returned. Returns HttpClient An HTTP client Remarks If clientName is null then the DefaultClient will be returned. Exceptions InvalidOperationException If clientName is specified & non-null but the current instance has no client of that name."
  },
  "api/CSF.Screenplay.WebApis.NameValueRecordCollection-2.html": {
    "href": "api/CSF.Screenplay.WebApis.NameValueRecordCollection-2.html",
    "title": "Class NameValueRecordCollection<TKey, TValue> | Screenplay",
    "summary": "Class NameValueRecordCollection<TKey, TValue> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll A simple name/value collection with an indexer, backed by a Dictionary<TKey, TValue>. public sealed class NameValueRecordCollection<TKey, TValue> : IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IEquatable<NameValueRecordCollection<TKey, TValue>> where TKey : notnull where TValue : class Type Parameters TKey The key type TValue The value type Inheritance object NameValueRecordCollection<TKey, TValue> Implements IEnumerable<KeyValuePair<TKey, TValue>> IEnumerable IEquatable<NameValueRecordCollection<TKey, TValue>> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Please note that this type differs in form depending upon the .NET version under which it is consumed. If consuming this type from logic which targets .NET Standard 2.0 or .NET Framework 4.6.2 then this type is mutable. In that scenario the developer should take care to ensure that they do not mutate/alter its state inadvertently. Developers should ensure that they manually copy the state from the current instance into a new instance instead of modifying an existing instance. In these target frameworks, a Clone method has been provided to assist with this. When consuming this from .NET 5 or higher, this type is immutable by design; the indexer is init-only. When using .NET 5, developers may use nondestructive mutation by using either the WithItem or WithItems methods to create a copy of the current instance, but with modified items. Constructors NameValueRecordCollection() Initialises a new instance of NameValueRecordCollection<TKey, TValue>. public NameValueRecordCollection() Properties this[TKey] Gets or sets the values within this collection, via an indexer. public TValue? this[TKey key] { get; init; } Parameters key TKey The key Property Value TValue The value Examples In order to set this property, particularly when using .NET 5 or higher (when this type is a record rather than a class, and this indexer is immutable), use the following syntax. var nvr = new NameValueRecordCollection<int,string> { [7] = \"seven\", [9] = \"nine\", [13] = \"thirteen\", } Remarks null may not be stored in this collection as a value. An attempt to store a null value will result in the removal of the item at the specified key. As a type which is intended to be immutable, it goes without saying that ideally both TKey and TValue should ideally also be immutable types. If they are not, developers must be careful to avoid mutating them, as doing so could adulterate the state of the current instance. Methods Equals(NameValueRecordCollection<TKey, TValue>?) Indicates whether the current object is equal to another object of the same type. public bool Equals(NameValueRecordCollection<TKey, TValue>? other) Parameters other NameValueRecordCollection<TKey, TValue> An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetEnumerator() Returns an enumerator that iterates through the collection. public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() Returns IEnumerator<KeyValuePair<TKey, TValue>> An enumerator that can be used to iterate through the collection. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. WithItem(TKey, TValue?) Gets a clone (shallow copy) of the current NameValueRecordCollection<TKey, TValue> containing the same items, as well as the specified item. public NameValueRecordCollection<TKey, TValue> WithItem(TKey key, TValue? value) Parameters key TKey The key at which to add, remove or update an item value TValue The value to store for the item, or null which indicates that the item is to be removed. Returns NameValueRecordCollection<TKey, TValue> A copy of the current instance, with a single item added, removed or altered in that copied instance. Remarks As with the indexer, if the value is null then this will result in the removal of the item in the returned copy. WithItems(IEnumerable<KeyValuePair<TKey, TValue?>>) Gets a clone (shallow copy) of the current NameValueRecordCollection<TKey, TValue> containing the same items, as well as the specified items. public NameValueRecordCollection<TKey, TValue> WithItems(IEnumerable<KeyValuePair<TKey, TValue?>> items) Parameters items IEnumerable<KeyValuePair<TKey, TValue>> A collection of key/value pairs, indicating the keys & values to add, remove or alter in the copied instance. Returns NameValueRecordCollection<TKey, TValue> A copy of the current instance, with the specified items added, removed or altered. Remarks As with indexer, if any value is null then this will result in the removal of the corresponding item in the returned copy."
  },
  "api/CSF.Screenplay.WebApis.ParameterizedEndpoint-1.html": {
    "href": "api/CSF.Screenplay.WebApis.ParameterizedEndpoint-1.html",
    "title": "Class ParameterizedEndpoint<TParameters> | Screenplay",
    "summary": "Class ParameterizedEndpoint<TParameters> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Base type for a Web API endpoint which has a strongly-typed request payload but which is not expected to return a response body. public abstract class ParameterizedEndpoint<TParameters> : EndpointBase, IHasName Type Parameters TParameters The type of the parameters object which is required to create an HTTP request message Inheritance object EndpointBase ParameterizedEndpoint<TParameters> Implements IHasName Derived JsonEndpoint<TParameters> Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should override GetHttpRequestMessageBuilder(TParameters) with a method that calls the base implementation and then further manipulates the message builder before returning it. This particular class may only be used as a base type for specialized implementations. Implementing types must provide an implementation of GetHttpRequestMessageBuilder(TParameters) which includes whatever logic is required to serialize the parameters value into the HTTP request. For an example implementation which serializes the parameters as a JSON string, see JsonEndpoint<TParameters>. When deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors ParameterizedEndpoint(string, HttpMethod) Initializes a new instance of ParameterizedEndpoint<TParameters> with a relative URI and an optional HTTP method. protected ParameterizedEndpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). ParameterizedEndpoint(Uri, HttpMethod) Initializes a new instance of ParameterizedEndpoint<TParameters> with a URI and an optional HTTP method. protected ParameterizedEndpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder(TParameters) Gets a HttpRequestMessageBuilder from the state of the current instance and the specified parameters value. public abstract HttpRequestMessageBuilder GetHttpRequestMessageBuilder(TParameters parameters) Parameters parameters TParameters The parameters required to create an HTTP request builder Returns HttpRequestMessageBuilder An HTTP request message builder Remarks When overriding/implementing this method use GetBaseHttpRequestMessageBuilder() to get a builder from the base class. You should then further customize that builder instance according to the appropriate logic for this implementation, such as to add the parameter value. See Also EndpointBase Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters, TResult> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.ParameterizedEndpoint-2.html": {
    "href": "api/CSF.Screenplay.WebApis.ParameterizedEndpoint-2.html",
    "title": "Class ParameterizedEndpoint<TParameters, TResult> | Screenplay",
    "summary": "Class ParameterizedEndpoint<TParameters, TResult> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll Base type for a Web API endpoint which has a strongly-typed request payload and which is expected to return a response body that exposes a strongly-typed object. public abstract class ParameterizedEndpoint<TParameters, TResult> : EndpointBase, IHasName Type Parameters TParameters The type of the parameters object which is required to create an HTTP request message TResult The type of response that the endpoint is expected to return. Inheritance object EndpointBase ParameterizedEndpoint<TParameters, TResult> Implements IHasName Derived JsonEndpoint<TParameters, TResult> Inherited Members EndpointBase.Name EndpointBase.Timeout EndpointBase.GetBaseHttpRequestMessageBuilder() EndpointBase.GetBaseHttpRequestMessageBuilder<TResponse>() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks There are several concrete types of endpoint available, all of which derive from EndpointBase, for more information about the purpose of endpoints and how they are used, see the documentation for that base type. The manner in which this endpoint exposes the strongly typed response object is undefined within the endpoint itself. It is down to a performable implementation to deserialize the result object from the HTTP response content. Developers are welcome to create specialized derived types based upon this or other subclasses of EndpointBase if they have specific needs. Derived classes should override GetHttpRequestMessageBuilder(TParameters) with a method that calls the base implementation and then further manipulates the message builder before returning it. This particular class may only be used as a base type for specialized implementations. Implementing types must provide an implementation of GetHttpRequestMessageBuilder(TParameters) which includes whatever logic is required to serialize the parameters value into the HTTP request. For an example implementation which serializes the parameters as a JSON string, see JsonEndpoint<TParameters, TResult>. When deriving from this class, developers are strongly encouraged to set the Name property to a human-readable name for this endpoint. This will improve the readability of reports. For more information, see the documentation article for using web APIs. Constructors ParameterizedEndpoint(string, HttpMethod) Initializes a new instance of ParameterizedEndpoint<TParameters, TResult> with a relative URI and an optional HTTP method. protected ParameterizedEndpoint(string relativeUri, HttpMethod method = null) Parameters relativeUri string A relative URI string for the current endpoint. method HttpMethod An optional HTTP method. Remarks When setting the relative URI, avoid a leading forward-slash. Prefer myApp/doSomething over /myApp/doSomething. If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). ParameterizedEndpoint(Uri, HttpMethod) Initializes a new instance of ParameterizedEndpoint<TParameters, TResult> with a URI and an optional HTTP method. protected ParameterizedEndpoint(Uri uri, HttpMethod method = null) Parameters uri Uri A URI for the current endpoint; this may be relative or absolute. method HttpMethod An optional HTTP method. Remarks If you omit the HTTP method, then the created builder will also not specify an HTTP method, which (if used to generate a request) will result in an HTTP GET request. See CreateRequestMessage(). Methods GetHttpRequestMessageBuilder(TParameters) Gets a HttpRequestMessageBuilder<TResponse> from the state of the current instance and the specified parameters value. public abstract HttpRequestMessageBuilder<TResult> GetHttpRequestMessageBuilder(TParameters parameters) Parameters parameters TParameters The parameters required to create an HTTP request builder Returns HttpRequestMessageBuilder<TResult> An HTTP request message builder Remarks When overriding/implementing this method use GetBaseHttpRequestMessageBuilder<TResponse>() to get a builder from the base class. You should then further customize that builder instance according to the appropriate logic for this implementation, such as to add the parameter value. See Also EndpointBase Endpoint Endpoint<TResult> ParameterizedEndpoint<TParameters> JsonEndpoint<TParameters> JsonEndpoint<TParameters, TResult>"
  },
  "api/CSF.Screenplay.WebApis.SendTheHttpRequest.html": {
    "href": "api/CSF.Screenplay.WebApis.SendTheHttpRequest.html",
    "title": "Class SendTheHttpRequest | Screenplay",
    "summary": "Class SendTheHttpRequest Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An action which creates & sends an HTTP request using the specification within an HttpRequestMessageBuilder. public class SendTheHttpRequest : IPerformableWithResult<HttpResponseMessage>, ICanReport Inheritance object SendTheHttpRequest Implements IPerformableWithResult<HttpResponseMessage> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SendTheHttpRequest(HttpRequestMessageBuilder, string) Initializes a new instance of SendTheHttpRequest. public SendTheHttpRequest(HttpRequestMessageBuilder messageBuilder, string clientName = null) Parameters messageBuilder HttpRequestMessageBuilder The HTTP request message builder. clientName string An optional client name, when actors must maintain more than one HTTP client. Exceptions ArgumentNullException If messageBuilder is null. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<HttpResponseMessage> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<HttpResponseMessage> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.WebApis.SendTheHttpRequestAndGetJsonResponse-1.html": {
    "href": "api/CSF.Screenplay.WebApis.SendTheHttpRequestAndGetJsonResponse-1.html",
    "title": "Class SendTheHttpRequestAndGetJsonResponse<TResponse> | Screenplay",
    "summary": "Class SendTheHttpRequestAndGetJsonResponse<TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An action which creates & sends an HTTP request, using the specification within an HttpRequestMessageBuilder<TResponse> and returns a strongly-typed result deserialized from a JSON HTTP response. public class SendTheHttpRequestAndGetJsonResponse<TResponse> : IPerformableWithResult<TResponse>, ICanReport Type Parameters TResponse Inheritance object SendTheHttpRequestAndGetJsonResponse<TResponse> Implements IPerformableWithResult<TResponse> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SendTheHttpRequestAndGetJsonResponse(HttpRequestMessageBuilder<TResponse>, string) Initializes a new instance of SendTheHttpRequestAndGetJsonResponse<TResponse>. public SendTheHttpRequestAndGetJsonResponse(HttpRequestMessageBuilder<TResponse> messageBuilder, string clientName = null) Parameters messageBuilder HttpRequestMessageBuilder<TResponse> The HTTP request message builder. clientName string An optional client name, when actors must maintain more than one HTTP client. Exceptions ArgumentNullException If messageBuilder is null. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<TResponse> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<TResponse> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.WebApis.SendTheHttpRequestAndGetTheResponse-1.html": {
    "href": "api/CSF.Screenplay.WebApis.SendTheHttpRequestAndGetTheResponse-1.html",
    "title": "Class SendTheHttpRequestAndGetTheResponse<TResponse> | Screenplay",
    "summary": "Class SendTheHttpRequestAndGetTheResponse<TResponse> Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll An action which creates & sends an HTTP request using the specification within an HttpRequestMessageBuilder<TResponse> and returns a result which preserves the intended response type. public class SendTheHttpRequestAndGetTheResponse<TResponse> : IPerformableWithResult<HttpResponseMessageAndResponseType<TResponse>>, ICanReport Type Parameters TResponse Inheritance object SendTheHttpRequestAndGetTheResponse<TResponse> Implements IPerformableWithResult<HttpResponseMessageAndResponseType<TResponse>> ICanReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SendTheHttpRequestAndGetTheResponse(HttpRequestMessageBuilder<TResponse>, string) Initializes a new instance of SendTheHttpRequestAndGetTheResponse<TResponse>. public SendTheHttpRequestAndGetTheResponse(HttpRequestMessageBuilder<TResponse> messageBuilder, string clientName = null) Parameters messageBuilder HttpRequestMessageBuilder<TResponse> The HTTP request message builder. clientName string An optional client name, when actors must maintain more than one HTTP client. Exceptions ArgumentNullException If messageBuilder is null. Methods GetReportFragment(Actor, IFormatsReportFragment) Gets a fragment of a Screenplay report, specific to the execution (performables) or gaining (abilities) of the current instance, for the specified actor. public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) Parameters actor Actor An actor for whom to write the report fragment formatter IFormatsReportFragment A report-formatting service Returns ReportFragment A human-readable report fragment. Examples For a performable which clicks a button (where the button itself has been constructor-injected into the performable instance), then a suitable return value might be a formatted string such as {Actor name} clicks {Button}, where the two placeholders indicated by braces: {} are substituted with the actor's Name and a string representation of the button. For a performable which reads the temperature from a thermometer, a suitable return value might be a string in the format {Actor name} reads the temperature. For an ability which allows the actor to wash dishes then a suitable return value might be a string in the format {Actor name} is able to wash the dishes. Remarks Implementers should return a string which indicates that the named actor is performing (present tense) the performable, for types which also implement a performable interface. For types which represent abilities, the implementer should return a string which indicates that the named actor is able to do something. In particular for abilities, to make them easily recognisable in reports, it helps to stick to the convention {Actor name} is able to {Ability summary}. For performables which return a value (Questions, or Tasks which behave like Questions), there is no need to include the returned value within the report fragment. The framework will include the return value in the report and will format it via a different mechanism. Good report fragments are concise. Be aware that report fragments for Tasks (which are composed from other performables) do not need to go into detail about what they do. Users reading Screenplay reports are able to drill-down into Tasks to see what they are composed from, so if the user is curious as to what the task does, it is easy to discover. It is also strongly recommended to avoid periods (full stops) at the end of a report fragment. Whilst report fragments tend to be complete sentences, punctuation like this is distracting and reports are seldom presented as paragraphs of prose. PerformAsAsync(ICanPerform, CancellationToken) Performs the action(s) are represented by the current instance and returns a strongly-typed value. public ValueTask<HttpResponseMessageAndResponseType<TResponse>> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) Parameters actor ICanPerform The actor that is performing. cancellationToken CancellationToken An optional cancellation token by which to abort the performable. Returns ValueTask<HttpResponseMessageAndResponseType<TResponse>> A task which exposes a strongly-typed 'result' value when the performable represented by the current instance is complete."
  },
  "api/CSF.Screenplay.WebApis.WebApiBuilder.html": {
    "href": "api/CSF.Screenplay.WebApis.WebApiBuilder.html",
    "title": "Class WebApiBuilder | Screenplay",
    "summary": "Class WebApiBuilder Namespace CSF.Screenplay.WebApis Assembly CSF.Screenplay.WebApis.dll A builder for the performables SendTheHttpRequest and SendTheHttpRequestAndGetTheResponse<TResponse>. public static class WebApiBuilder Inheritance object WebApiBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetTheJsonResult<TResponse>(Endpoint<TResponse>, string) Gets an instance of SendTheHttpRequestAndGetJsonResponse<TResponse> from an endpoint and optional client name. public static SendTheHttpRequestAndGetJsonResponse<TResponse> GetTheJsonResult<TResponse>(Endpoint<TResponse> endpoint, string clientName = null) Parameters endpoint Endpoint<TResponse> The endpoint from which to get an action. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequestAndGetJsonResponse<TResponse> A performable that will send the HTTP request and await its result and deserialize that result as . Type Parameters TResponse The type of the expected result value GetTheJsonResult<TParameters, TResponse>(ParameterizedEndpoint<TParameters, TResponse>, TParameters, string) Gets an instance of SendTheHttpRequestAndGetJsonResponse<TResponse> from a parameterized endpoint, its parameters and an optional client name. public static SendTheHttpRequestAndGetJsonResponse<TResponse> GetTheJsonResult<TParameters, TResponse>(ParameterizedEndpoint<TParameters, TResponse> endpoint, TParameters parameters, string clientName = null) Parameters endpoint ParameterizedEndpoint<TParameters, TResponse> The endpoint from which to get an action. parameters TParameters The parameters required by the endpoint. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequestAndGetJsonResponse<TResponse> A performable that will send the HTTP request and await its result. Type Parameters TParameters The type of the parameters expected by the endpoint TResponse The type of the expected result value SendTheHttpRequest(Endpoint, string) Gets an instance of SendTheHttpRequest from an endpoint and optional client name. public static SendTheHttpRequest SendTheHttpRequest(Endpoint endpoint, string clientName = null) Parameters endpoint Endpoint The endpoint from which to get an action. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequest A performable that will send the HTTP request and await its result. SendTheHttpRequest<TResponse>(Endpoint<TResponse>, string) Gets an instance of SendTheHttpRequestAndGetTheResponse<TResponse> from an endpoint and optional client name. public static SendTheHttpRequestAndGetTheResponse<TResponse> SendTheHttpRequest<TResponse>(Endpoint<TResponse> endpoint, string clientName = null) Parameters endpoint Endpoint<TResponse> The endpoint from which to get an action. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequestAndGetTheResponse<TResponse> A performable that will send the HTTP request and await its result. Type Parameters TResponse The type of the expected result value SendTheHttpRequest<TParameters>(ParameterizedEndpoint<TParameters>, TParameters, string) Gets an instance of SendTheHttpRequest from a parameterized endpoint, its parameters and an optional client name. public static SendTheHttpRequest SendTheHttpRequest<TParameters>(ParameterizedEndpoint<TParameters> endpoint, TParameters parameters, string clientName = null) Parameters endpoint ParameterizedEndpoint<TParameters> The endpoint from which to get an action. parameters TParameters The parameters required by the endpoint. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequest A performable that will send the HTTP request and await its result. Type Parameters TParameters The type of the parameters expected by the endpoint SendTheHttpRequest<TParameters, TResponse>(ParameterizedEndpoint<TParameters, TResponse>, TParameters, string) Gets an instance of SendTheHttpRequestAndGetTheResponse<TResponse> from a parameterized endpoint, its parameters and an optional client name. public static SendTheHttpRequestAndGetTheResponse<TResponse> SendTheHttpRequest<TParameters, TResponse>(ParameterizedEndpoint<TParameters, TResponse> endpoint, TParameters parameters, string clientName = null) Parameters endpoint ParameterizedEndpoint<TParameters, TResponse> The endpoint from which to get an action. parameters TParameters The parameters required by the endpoint. clientName string An optional client name, for actors who must maintain multiple HTTP clients. Returns SendTheHttpRequestAndGetTheResponse<TResponse> A performable that will send the HTTP request and await its result. Type Parameters TParameters The type of the parameters expected by the endpoint TResponse The type of the expected result value"
  },
  "api/CSF.Screenplay.WebApis.html": {
    "href": "api/CSF.Screenplay.WebApis.html",
    "title": "Namespace CSF.Screenplay.WebApis | Screenplay",
    "summary": "Namespace CSF.Screenplay.WebApis Classes Endpoint A Web API endpoint which has no expected request payload and which is not expected to return a response body. EndpointBase Abstract base class for types which represent web API endpoints. Endpoint<TResult> A Web API endpoint which has no expected request payload and which is expected to return a response body that exposes a strongly-typed object. HttpRequestMessageBuilder An object which can create an HttpRequestMessage for use with an HTTP client. HttpRequestMessageBuilder<TResponse> An object which can create an HttpRequestMessage for use with an HTTP client, which is expected to expose a response of a particular type. HttpResponseMessageAndResponseType<TResponse> Wraps an HttpResponseMessage but also provides information about the expected response type from that message. JsonEndpoint<TParameters> Base type for a Web API endpoint which accepts a request payload in the form of a strongly typed object serialized to JSON string, but which is not expected to return a response body. JsonEndpoint<TParameters, TResult> Base type for a Web API endpoint which accepts a request payload in the form of a strongly typed object serialized to JSON string, and which is expected to return a response body that exposes a strongly-typed object. MakeWebApiRequests An ability class which allows Actors to make HTTP web API requests using HttpClient. NameValueRecordCollection<TKey, TValue> A simple name/value collection with an indexer, backed by a Dictionary<TKey, TValue>. ParameterizedEndpoint<TParameters> Base type for a Web API endpoint which has a strongly-typed request payload but which is not expected to return a response body. ParameterizedEndpoint<TParameters, TResult> Base type for a Web API endpoint which has a strongly-typed request payload and which is expected to return a response body that exposes a strongly-typed object. SendTheHttpRequest An action which creates & sends an HTTP request using the specification within an HttpRequestMessageBuilder. SendTheHttpRequestAndGetJsonResponse<TResponse> An action which creates & sends an HTTP request, using the specification within an HttpRequestMessageBuilder<TResponse> and returns a strongly-typed result deserialized from a JSON HTTP response. SendTheHttpRequestAndGetTheResponse<TResponse> An action which creates & sends an HTTP request using the specification within an HttpRequestMessageBuilder<TResponse> and returns a result which preserves the intended response type. WebApiBuilder A builder for the performables SendTheHttpRequest and SendTheHttpRequestAndGetTheResponse<TResponse>."
  },
  "api/CSF.Screenplay.html": {
    "href": "api/CSF.Screenplay.html",
    "title": "Namespace CSF.Screenplay | Screenplay",
    "summary": "Namespace CSF.Screenplay Classes Actor A representation of an autonomous, or at least seemingly-autonomous, person or system which directs the events of a IPerformance. ActorExtensions Extension methods for actor types CastAdapter An adapter which enables the use of ICast within an NUnit3 test, without needing to parameter-inject the instance as Lazy<ICast>. CastExtensions Extension methods for ICast. EnumerableResolutionAdapter<T> Adapter class which - when added to DI - permits the BoDi DI container to resolve arbitrary IEnumerable<T> of service instances. ObjectContainerExtensions Extension methods for the Reqnroll/SpecFlow \"BoDi\" DI container. Performance Primary implementation type of IPerformance. PerformanceAdapter An adapter which enables the use of IPerformance within an NUnit3 test, without needing to parameter-inject the instance as Lazy<IPerformance>. PerformanceProviderFactory Factory type for instances of PerformanceProvider. PerformanceStarter Helper class for beginning the functionality of a Screenplay IPerformance from your own logic, using a fluent interface ReportFragment A model for a fragment of a report upon a IPerformance. ReportFragmentFormatter Default implementation of IFormatsReportFragment. ScopeAndPerformance A model which contains both an IPerformance and a dependency injection IServiceScope. Screenplay An object which represents a complete execution of Screenplay logic, which should include one or more Performance instances. ScreenplayAssemblyAttribute An attribute used to mark an assembly which contains Screenplay-based tests. ScreenplayAttribute Applied to a test method, indicates that decorated test is a Screenplay test. ScreenplayBinding Reqnroll binding which uses hooks to coordinate the relevant Screenplay & IPerformance event invokers. ScreenplayExtensions Extension methods for the Screenplay type. ScreenplayLocator A small static service locator of sorts, dedicated to getting an appropriate instance of Screenplay for a specified test object. ScreenplayOptions Options model which permits the customization/configuration of Screenplay in DI. ScreenplayPlugin The Screenplay plugin for Reqnroll. ScreenplayServiceCollectionExtensions Extension methods for IServiceCollection relating to Screenplay. ServiceCollectionAdapter Adapter class which allows a Reqnroll/BoDi IObjectContainer to be used as an IServiceCollection. ServiceCollectionExtensions Extension methods for IServiceCollection. ServiceProviderAdapter Adapter class which allows a Reqnroll/BoDi IObjectContainer to be used as an IServiceProvider. StageAdapter An adapter which enables the use of IStage within an NUnit3 test, without needing to parameter-inject the instance as Lazy<IStage>. StageExtensions Extension methods for IStage. TestMethodBuilder Builder class which is used to create NUnit3 test method instances for a Screenplay-based test. Interfaces ICanPerform An actor which may perform in the Screenplay. ICanReport A type which can provide a human-readable report fragment when it is used in a IPerformance. ICast A combined registry and factory for Actor instances, useful when coordinating multiple actors across a IPerformance IFormatsReportFragment A service which produces formatted report fragments from a template and a collection of parameter values. IGetsScreenplay An object which can fully configure and get a Screenplay instance. IHasAbilities An object which has & is able to gain abilities. IHasName A part of a Screenplay performance which has a human-readable name. IHasPerformanceIdentity An object which provides a value which uniquely identifies the currently-executing IPerformance. IHasServiceProvider An object which has an associated IServiceProvider, which resolves services from dependency injection. IHostsPerformance An object which encapsulates the logic of an IPerformance in a standalone Screenplay. IPerformable An object which represents something that a performer (typically an actor) may perform. IPerformableWithResult An object which represents something that a performer (typically an actor) may perform and which returns a result when it completes. IPerformableWithResult<TResult> An object which represents something that a performer (typically an actor) may perform and which returns a strongly-typed result when it completes. IPerformance A Performance corresponds to a self-contained scope of Performables, performed by Actors, which results in success or failure. IPersona A persona is a factory for a commonly-used Actor IStage The stage facilitates a contextual Actor who is 'in the spotlight' - a currently-active actor"
  },
  "docs/Assets.html": {
    "href": "docs/Assets.html",
    "title": "Report assets | Screenplay",
    "summary": "Report assets TODO: Write this docco page; #301"
  },
  "docs/Capabilities.html": {
    "href": "docs/Capabilities.html",
    "title": "Screenplay's capabilities | Screenplay",
    "summary": "Screenplay's capabilities Intuitive, human-readable design Promotes maximum code reuse Produces human-readable reports Integration with testing frameworks Extensibility via plug-in extensions Not just for automated testing Screenplay follows an intuitive design The logic of a Screenplay Performance or Task is obvious, to both programmers and non-programmers alike. Through use of static builders, Screenplay logic forms a fluent interface which is instantly readable. For example, this is a line of Screenplay-based code: await Given(webster).WasAbleTo(AddAProductToTheirCartNamed(\"Blue widget\")); Screenplay promotes code reuse Screenplay ruthlessly follows SOLID design principles, particularly SRP and OCP. The architecture of Performables permits unlimited levels of composition via Tasks. Developers are also encouraged to use Personas to configure and manage the Actors which participate in a Screenplay. Screenplay produces reports Whenever a Screenplay executes, a record of what happened is saved in JSON format. This JSON file is computer-readable, but it may be converted to a human-readable report using the included utility. Screenplay integrates with Testing frameworks If you would like to use Screenplay as a test-authoring framework then you are in luck. Screenplay has integrations with testing frameworks, out of the box: NUnit 3 Reqnroll and the now-retired SpecFlow The community is encouraged to create and contribute additional integrations if they wish. The source code of the existing integrations, and the documentation website for your chosen test framework, are good places to start for writing a new integration. Screenplay is extensible Screenplay has two primary extension points, test-framework integrations (above) and Extensions. Extensions provide Screenplay with the capabilities to interact-with and automate additional technologies. Some extensions are provided already: Selenium WebDriver Web APIs The community is encouraged to create and contribute additional extensions if they wish. Writing an extension is a matter of writing Ability, Action and Question classes, along with any appropriate Builders. The source code for the existing Extensions are a good place to start in learning how to create a new one. Screenplay isn't limited to software testing Whilst Screenplay is a popular pattern for automated testing, particularly web-browser-based testing, it doesn't have to be limited to that use-case. Screenplay may be invoked as a standalone process-automation tool. See the documentation of the ExecuteAsPerformanceAsync<T> method for information and examples for the recommended way to use Screenplay outside of a testing framework."
  },
  "docs/GettingReports.html": {
    "href": "docs/GettingReports.html",
    "title": "Screenplay reports | Screenplay",
    "summary": "Screenplay reports As a Screenplay executes, the framework produces and saves a JSON-format report file, recording each Performance. This file is a machine-readable record of every Actor and every Performable which was included in the performances. It records the results from the performables (where applicable) as well as the details of errors, where they occur. Where the report JSON file is saved Over the course of a Screenplay, the JSON file will be written and saved at a path defined by the ScreenplayOptions.ReportPath option. As the documentation for that option notes, the default if it has not been set is to write the report to a file in the current working directory. The default filename includes a representation of the current timestamp, so each report is likely to have a unique filename. This path may be altered by specifying a different set of options to the AddScreenplay service collection extension method. Converting JSON to a human-readable report JSON is a very good machine-readable format for reports, but it's not a great choice for reading by humans. CSF.Screenplay offers a utility to convert a JSON-format report into a human-readable single-page HTML file, viewable in any modern web browser. This tool is the CSF.Screenplay.JsonToHtmlReport command-line utility. The command-line options to this utility are documented in the class ReportConverterOptions. They should be passed using the dobule-dash syntax, for example CSF.Screenplay.JsonToHtmlReport.exe --ReportPath c:\\path\\subfolder\\screenplay-report.json."
  },
  "docs/bestPractice/SuitabilityAsATestingTool.html": {
    "href": "docs/bestPractice/SuitabilityAsATestingTool.html",
    "title": "Where Screenplay is suitable for testing | Screenplay",
    "summary": "Where Screenplay is suitable for testing The Screenplay pattern is a recommended tool for writing automated tests for application software. Unlike NUnit or Reqnroll (or many others) Screenplay is not a complete testing framework. Rather, Screenplay integrates with your chosen testing framework to assist in the writing of test logic. Screenplay is not a silver bullet; some kinds of tests could benefit from Screenplay and others will not. Some testing scenarios are listed below, along with a brief consideration as to whether Screenplay is likely to be relevant. Terminology can differ between developers, so each type of test begins with a short definition. Ideal: System tests Also known as \"end-to-end tests\"; this kind of test exercises and tests the full deployed application without the use of any test fakes. The application might be set up/configured in a controlled environment but it runs and is exercised in the same way it would in production. System tests are an ideal candidate for the use of Screenplay. System tests are often written from a user's perspective and test meaningful, observable behaviour of the application, such as a complete user story. Screenplay excels in this area of test design. Unsuitable: Unit tests Unit tests test the functionality of a small unit of code in isolation. Typically this is a single class or function. Anything external to the tested unit is replaced with a test fake or a mock. Screenplay is not recommended for use in unit testing. Unit tests are rarely written from an end-user's perspective and often do not test complete application behaviour, such as a user story. A unit test will only test only a small aspect of some functionality. When this aspect is considered in isolation it may be meaningless, or too abstract to comprehend for an end-user. Additionally: The steps involved in unit tests should be short & simple, with minimal need for code reuse or composition The steps are typically difficult to describe in the application's 'behaviour domain', only with language that a software developer would understand Perhaps useful: Integration tests Integration tests live at a point in the spectrum of testing between unit & system tests. Like unit tests, they execute logic via its programming API instead of testing the deployed application. Unlike unit tests, each integration test exercises logic across many units of code/classes. Thus, it is common for integration tests to test high-level APIs which represent complete user stories. Integration tests might include some test fakes. Usually these are limited to things which are difficult or expensive to control. Asynchronous web services & databases are typically replaced with test fakes in integration tests. For integration tests, we recommend that you evaluate for yourself whether Screenplay is useful. In some projects/applications, Screenplay will be excellent for integration tests. In others it might not. You will find Screenplay most useful if your integration tests test complete user stories. This is particularly true if the test/sample scenarios would be recognisable to end users, even if described in an abstract manner, for example without reference to a user interface. Recommended: Use BDD-style tests Screenplay is a great tool when used alongside Behaviour Driven Development (BDD). Whilst the use of a BDD framework such as Reqnroll is not at all mandatory, those familiar with BDD will quickly see the synergies with Screenplay."
  },
  "docs/bestPractice/WritingTests.html": {
    "href": "docs/bestPractice/WritingTests.html",
    "title": "Advice for writing tests with Screenplay | Screenplay",
    "summary": "Advice for writing tests with Screenplay Whichever testing integration you choose to use, there are some general pieces of advice and best practice which apply. Use high-level tasks Avoid the use of too many tasks/performables in each test. Too many performables in a single test makes it hard to comprehend at-a-glance and forces the reader to commit too much detail to memory. Rather than using many performables at the top-level of your tests, create high-level tasks which compose and simplify some of that detail into a single logical step. When using a method-driven testing framework, such as NUnit, five performables in a single test method is a reasonable number. More than approximately ten performables is too many. When using a binding-driven testing framework like Reqnroll, each binding should ideally correspond to at-most one performable. Use the Performance Starter Your top-level test logic should consume its performables via the class PerformanceStarter. This provides for a clear given/when/then appearance to your top-level test logic. Consider a fluent-style assertions library Depending upon the testing framework you have chosen, you may or may not have access to fluent-style assertions functionality. NUnit, for example, provides assertions based upon the constraint model, which is an extensible fluent-style syntax. If your chosen testing framework does not provide easy-to-read assertions, consider an external assertion library. Assertion libraries to consider include Shouldly and Fluent Assertions. Do not include assertions in performables It might be tempting to include assertion syntax within performables such as tasks. This is not recommended. Where assertions appear within performables: They reduce the reusability of the performables They create a dependency between your performables and your testing framework/assertion library They can make test logic harder to read and understand It is recommended to keep your performables/tasks free from assertions. In your test code, use questions or question-like tasks to get values/data from the system under test. Write your assertions in your main test logic, asserting that the values retrieved are as-expected."
  },
  "docs/builderPattern/ConsumingBuilders.html": {
    "href": "docs/builderPattern/ConsumingBuilders.html",
    "title": "Consuming builders | Screenplay",
    "summary": "Consuming builders Core to a Screenplay Performance are Performables. Getting these performables is easiest when using a builder. This results in clear, human-readable code inside your performance. The entry point to most builders is a static class which exposes factory methods for the performables which it supports. These are easiest to consume with a using static directive, such as: using static MyNamespace.Builders.MyBuilderEntryPoint; This means that the methods of the static entry point class may be used in the positions where a performable is required, such as the following. using static DrinksNamespace.DrinksBuilder; await actor.PerformAsync(MakeACupOf(\"Coffee\"), cancellationToken); In the example above, the fictitious MakeACupOf method is a static method of the fictitious DrinksBuilder static entry-point class."
  },
  "docs/builderPattern/WritingBuilders.html": {
    "href": "docs/builderPattern/WritingBuilders.html",
    "title": "Writing builders | Screenplay",
    "summary": "Writing builders The first step toward writing builders for Screenplay Performables is to create a static class. This static class will act as the entry point to building performables and is typically consumed via a using static directive. Such a class may have many methods, each representing a different use case. Normally, it would be bad practice to fill a class with a large number of methods. Because (as shown below) the methods tend to be very short - typically only one line - and because of the convenience, consider using one static class for all related builders/performables in a logical package. Performables with no parameters To build a performable which requires no parameters, only the static method is required. Good names for such a static method begin with a verb, which indicates that it does something. Here is an example for a fictitious MakeACupOfTea performable. public static IPerformble MakeTheTea() => new MakeACupOfTea(); Substitute the performable interface (the return type) as applicable. Performables with one parameter If a performable requires one constructor-injected parameter then it is often possible to work this into the method name of a simple static method, similar to above. Consider this fictitious example. public static IPerformble MakeACupOf(string hotDrink) => new MakeACupOfHotDrink(hotDrink); This might be consumed as MakeACupOf(\"Coffee\"), for example. This is still very readable. Performables with many parameters Where it comes to performables which have more than one parameter then it is often best for the static entry point method to instead return a specialised builder for that performable. That specialised builder type exposes further methods which may be used to provide the other parameters in a human-readable manner. Particularly if one or more of the parameters is optional, consider writing an implicit conversion operator overload for your specialised builder type. The return type of such an operator should be the appropriate concrete performable type. Such an operator would allow the use of the builder to get the performable without needing an explicit .Build() method. Tip Beware of writing performables with too many parameters; this can make them difficult to consume. Consider writing high-level performables with fewer parameters, representing actual use cases. Example Here is an example of a fictitious builder. public class MakeAHotDrinkBuilder { readonly string drinkType; string whitener; int sugars; public MakeAHotDrinkBuilder WithMilk() { whitener = \"Milk\"; return this; } public MakeAHotDrinkBuilder WithCream() { whitener = \"Cream\"; return this; } public MakeAHotDrinkBuilder WithSugars(int howMany) { sugars = howMany; return this; } public MakeAHotDrinkBuilder(string drinkType) { this.drinkType = drinkType; } public static implicit operator MakeACupOfHotDrink(MakeAHotDrinkBuilder builder) => new MakeACupOfHotDrink(builder.drinkType, builder.whitener, sugars); } // Separately, in a static entry-point class: public static MakeAHotDrinkBuilder MakeACupOf(string drinkType) => new MakeAHotDrinkBuilder(drinkType); The above example might be consumed from a Task in the following manner: await actor.PerformAsync(MakeACupOf(\"Tea\").WithMilk().WithSugars(2), cancellationToken);"
  },
  "docs/builderPattern/index.html": {
    "href": "docs/builderPattern/index.html",
    "title": "The builder pattern | Screenplay",
    "summary": "The builder pattern As noted elsewhere, Performables are stateful objects which are not resolved from dependency injection. The state/dependencies which should be provided to a performable object should be parameter values. For example, a performable which adds a product to a shopping cart might need two pieces of state: Which product to add The quantity Recall that any external dependencies should come from the performing actor's Abilities. It is possible to create instances of performable types with just the new keyword. The state could be provided using constructor-injected parameter values or via property setters. Whilst the techniques above will work, neither are as attractive or easy to read and comprehend as the builder pattern. Writing builders for Screenplay Consuming builders to create performables"
  },
  "docs/concepts/HowScreenplayAndPerformanceRelate.html": {
    "href": "docs/concepts/HowScreenplayAndPerformanceRelate.html",
    "title": "How Screenplay logic executes | Screenplay",
    "summary": "How Screenplay logic executes A Screenplay is always begun by some consuming logic. That consuming logic might be a Test Integration if Screenplay is being used for automated tests. The consuming logic might alternatively be hand-written code if Screenplay is being used for process automation and not for testing. The consuming logic When using Screenplay for automated testing, the test integration library code takes care of all the responsibilities of the consuming logic; developers need only write their tests using Screenplay syntax. Each test/scenario corresponds to a Performance. If Screenplay is not being used for testing, then the consuming logic has the following responsibilities for the use of Screenplay: Create the Screenplay object using the Create method Execute BeginScreenplay before starting the first Performance Execute each performance, such as via ExecuteAsPerformanceAsync<TPerformance> or ExecuteAsPerformance, or one of their overloads Execute CompleteScreenplay after the last Performance has completed Performances & lifetimes The logic of each Performance is executed within its own dependency injection scope. The lifetime of this DI scope is matched with the lifetime of the Performance. The diagram below illustrates the information in this article. It shows how the consuming logic creates and uses a Screenplay object and how this relates to Performances, Actors and Performables. sequenceDiagram accDescr { A single instance of Screenplay runs each Performance. Each Performance contains scripts for one or more Actors. Within the Performance, the Actor(s) perform one or more Performables. The lifetime of a single performance is shown, to illustrate the DI lifetime scope. } participant Consumer participant Screenplay Consumer->>Screenplay: Create activate Screenplay Screenplay-->>Consumer: Screenplay instance Consumer->>Screenplay: BeginScreenplay loop For each Performance Consumer-)Screenplay: Execute performance note over Performance: DI scope lifetime =<br>Performance lifetime Screenplay-)Performance: Runs actor A as Actor activate Performance Performance-)A: Contains scripts for<br>one or more A-)Performable: Performs one<br>or more Performable--)A: Complete A--)Performance: Complete Performance--)Screenplay: Complete Screenplay--)Consumer: Done deactivate Performance end Consumer->>Screenplay: CompleteScreenplay deactivate Screenplay"
  },
  "docs/concepts/MakeupOfAScreenplay.html": {
    "href": "docs/concepts/MakeupOfAScreenplay.html",
    "title": "Makeup of a Screenplay | Screenplay",
    "summary": "Makeup of a Screenplay A Screenplay conceptually refers to a complete execution screenplay-based logic, written using this framework. As .NET code, Screenplay is a class which coordinates the scope & execution of that logic. A Screenplay is comprised at least one Performance, typically lots of them. A Performance is made from Actors performing Performables, of which there are Tasks, Actions and Questions. The logic of Actions and/or Questions almost always requires the use of an Ability. The diagram below shows the architecture of how these concepts relate to one another. block-beta columns 3 Screenplay:3 Performance[\"Performance<br>(each Screenplay may contain many)\"]:3 Actor(\"Actors\") space block:Perf columns 3 space Task[\"Tasks\"] space Action[\"Actions\"] space Question[\"Questions\"] end space:3 Ability[\"Abilities\"] Actor -- \"Perform\" --> Perf Ability -- \"Has\" --> Actor Action -- \"Use\" --> Ability Question -- \"Use\" --> Ability style Perf fill:#E0E0F0,stroke:#C0C0E0"
  },
  "docs/concepts/ScreenplayInTheTestingStack.html": {
    "href": "docs/concepts/ScreenplayInTheTestingStack.html",
    "title": "Screenplay in the testing stack | Screenplay",
    "summary": "Screenplay in the testing stack Screenplay is often used as a tool for writing automated tests. It is not a complete testing framework, though. It serves as an extension/plugin to existing testing frameworks, enhancing them with Screenplay syntax and logic. The diagram below shows where Screenplay lies within the technology stack, when it is used as a tool for testing. The dark yellow/light brown blocks show the Screenplay-specific components. The explanation below uses the NUnit test framework as an example, but this could be substituted for counterparts applicable to any test framework. block-beta columns 2 Runner[\"Test runner\"]:2 FW[\"Test framework\"]:2 Int[\"Test integration\"]:2 Test Logic[\"Screenplay test logic\"] classDef sp fill:#f0f0bb,stroke:#cc7 class Int,Logic sp The test runner This is the executable tool which runs tests. Applied to NUnit, this could be the nunit3-console.exe application. The test framework All testing framework contain some framework-specific logic of their own, which provide the basis for writing tests. Applied to NUnit, this is the NUnit.Framework.dll which is included in the NUnit NuGet package. The Test integration The Test Integration is the extension to the test framework (above) which enables the use of Screenplay-based logic in tests. Each testing framework has its own test integration, as it must be developed for the test framework's syntax and extension points. Tests The tests are normal tests written for the chosen test framework. Whilst they might be decorated with additional Screenplay-specific attributes or use Screenplay syntax, they are normal tests in the context of the test framework. Applied to NUnit, this would be your methods which look similar to: [Test] public void MyFunctionShouldReturnTrueWhenItIsTuesday() { // Test logic omitted } Screenplay test logic The logic within tests (above) which use Screenplay will be written using Screenplay's test syntax. That it, it will use Actors, Abilities and Performables. In this context, each test is a Screenplay Performance."
  },
  "docs/dependencyInjection/AddingServices.html": {
    "href": "docs/dependencyInjection/AddingServices.html",
    "title": "Adding dependency services to Screenplay | Screenplay",
    "summary": "Adding dependency services to Screenplay There are two techniques to add dependency services to Screenplay. You may either integrate Screenplay into an existing container for your application or tests or you may add additional services via the static Create factory method. Integrating with an existing container When using an existing IServiceCollection for you application, either using Screenplay standalone or with a test framework that integrates with dependency injection, then adding services is simple. Just add your services to the container (the service collection) as normal; they will be available to resolve and inject over the course of the Screenplay. Using the static Create factory If you do not wish to integrate Screenplay into an existing dependency injection container then the simplest way to create an instance of Screenplay is to use the static Screenplay.Create factory method. This method offers an optional parameter to provide an Action<IServiceCollection>. If you do so, then you may provide a customization action which adds additional services to the container. These services will be integrated into the self-contained service collection which the Create method creates for Screenplay. var screenplay = Screenplay.Create(services => { services.AddTransient<MyCustomService>(); // ... and anything further you want here }); A reminder on lifetime scopes Remember that Screenplay imposes some requirements upon service lifetime: The Screenplay object is always a singleton Each Performance is always executed within its own lifetime scope Add your own services to dependency injection accordingly."
  },
  "docs/dependencyInjection/ConstructorInjectIntoThePersona.html": {
    "href": "docs/dependencyInjection/ConstructorInjectIntoThePersona.html",
    "title": "Injecting services into Personas | Screenplay",
    "summary": "Injecting services into Personas Types which derive from IPersona support constructor-injected dependencies. Personas are typically used by either the cast or the stage to get an Actor. The technique in which they are used means that they are resolved, along with their constructor-injected dependencies, from DI. Use constructor-injected dependencies in persona classes to provide access to the APIs required to resolve Abilities that the actor is to be granted."
  },
  "docs/dependencyInjection/ConstructorInjectionForBindings.html": {
    "href": "docs/dependencyInjection/ConstructorInjectionForBindings.html",
    "title": "Constructor injection for bindings | Screenplay",
    "summary": "Constructor injection for bindings For frameworks which are based on binding classes such as Reqnroll, services are constructor-injected into binding classes. Use dependencies injected in this way to get access to commonly-used Screenplay services and anything else required at the root level of your test logic. Example This is an example of a Reqnroll-style binding class with a constructor-injected dependency. This would require installing the Reqnroll test integration to run. Take note of the stage parameter in the primary constructor. [Binding] public class SampleSteps(IStage stage) { [Given(\"Simon shows a sample step\")] public async Task GivenSimonShowsASampleStep() { var simon = stage.Spotlight<Simon>(); // ... use the actor with some performables, then make assertions etc } }"
  },
  "docs/dependencyInjection/DependencyInjectionScope.html": {
    "href": "docs/dependencyInjection/DependencyInjectionScope.html",
    "title": "Dependency injection scope | Screenplay",
    "summary": "Dependency injection scope Developers familiar with dependency injection are likely to be familiar with the concept of DI Scopes. Screenplay uses this concept; a number of its services are added to the container with a per-scope lifetime. Screenplay creates a new DI scope per Performance. As you can see on the diagram of how Actors, Abilities and Performables relate to one another, each Screenplay contains and executes many performances. This scope-creation is handled automatically by the Screenplay framework logic. Within a performance, when any of the scoped services (listed below) are injected, each point of injection will receive the same shared instance of that service. Instances are independent per-performance; each performance gets its own shared instance of each of the listed services. List of scoped services The following services are added to DI \"per lifetime scope\". The Cast The Stage The current performance List of singleton services The following services are added to DI as singletons. There is only ever a single instance of these services per Screenplay. The Screenplay The event bus This includes its interfaces The Screenplay options The report builder The reporter implementation The implementation resolved depends upon whether reporting is enabled"
  },
  "docs/dependencyInjection/InjectableServices.html": {
    "href": "docs/dependencyInjection/InjectableServices.html",
    "title": "Injectable services | Screenplay",
    "summary": "Injectable services Screenplay explicitly supports dependency-injection of the following services from the Screenplay architecture into your performance logic. These are in addition to any services you may have configured yourself within DI. Whilst it may be possible to inject other services from Screenplay's architecture, these are explicitly supported throughout all integrations. The Stage Inject the IStage into your performance logic to get and work with Actors. This is the recommended way to manage any actors involved in a performance. The stage provides all the functionality of the Cast (below) as well as control of the spotlight, should you wish to use it. The Cast The ICast is available for dependency injection into your performance logic as an alternative mechanism by which to work with Actors. It is recommended to inject the Stage (above) instead of the Cast. The Cast is reachable from the Stage should you need it, via the Cast property. The Performance You may inject an instance of IPerformance to gain direct access to the current performance object, from within your performance logic. Whilst supported, it is usually not required (or recommended) to inject this object into your performance logic."
  },
  "docs/dependencyInjection/InjectingServices.html": {
    "href": "docs/dependencyInjection/InjectingServices.html",
    "title": "Injecting services | Screenplay",
    "summary": "Injecting services The table below summarises how to get services, from various contexts. In the first column are contexts/situations in which a developer could require services from DI. The second column indicates and links to the appropriate technique for that scenario. All but one of these techniques (the last) provides full access to the services which are added to the container. Context Technique NUnit style test method Parameter inject into the test method Reqnroll style binding class Constructor inject into the binding class Standalone Screenplay: ExecuteAsPerformanceAsync Create a performance host, or use the service provider Persona class Constructor inject into the Persona class Performable class, such as a Task Use the actor's abilities"
  },
  "docs/dependencyInjection/InjectionForStandaloneScreenplay.html": {
    "href": "docs/dependencyInjection/InjectionForStandaloneScreenplay.html",
    "title": "Dependency injection for standalone Screenplay | Screenplay",
    "summary": "Dependency injection for standalone Screenplay If you are using Screenplay standalone then you are likely using the method Screenplay.ExecuteAsPerformanceAsync or one of its overloads. Recommended: Use IHostsPerformance Developers are urged to consider encapsulating their performance logic in a class which derives from IHostsPerformance. Through an overload (extension method) named ExecuteAsPerformanceAsync<T>, developers may specify the concrete implementation type of that class as a generic type parameter. This overload of ExecuteAsPerformanceAsync will resolve your class which derives from IHostsPerformance from dependency injection (remember to add it to the container!). This resolution will include all the class' dependencies which are constructor-injected and leads to very clean code. The service provider is never exposed, thus removing the temptation to use the service locator anti-pattern. Example of the performance host technique This example is functionally identical to the example below. public class MyPerformance(ICast cast) : IHostsPerformance { public Task<bool?> ExecutePerformanceAsync(CancellationToken cancellationToken) { var aaron = cast.GetActor<Aaron>(); // Further performance logic ... } } // To consume the above: await screenplay.ExecuteAsPerformanceAsync<MyPerformance>(); Alternative: Use a function The original Screenplay.ExecuteAsPerformanceAsync overload accepts up to three parameters, the first of which is a function. That function should contain the logic which makes up the performance. The function (which drives the performance logic) provides two parameters itself: An IServiceProvider A CancellationToken The serivce provider may be used to resolve services which may be used by the performance logic. Example of the function-based technique This example is functionally identical to the example above. await screenplay.ExecuteAsPerformanceAsync((services, cancellationToken) => { var cast = services.GetRequiredService<ICast>(); var aaron = cast.GetActor<Aaron>(); // Further performance logic ... });"
  },
  "docs/dependencyInjection/ParameterInjectionForTests.html": {
    "href": "docs/dependencyInjection/ParameterInjectionForTests.html",
    "title": "Parameter injection for tests | Screenplay",
    "summary": "Parameter injection for tests For testing frameworks which are based on test methods such as NUnit, services are injected via method parameter injection. This is performed directly into each test method which is decorated with the [Screenplay] attribute. Use dependencies injected in this way to get access to commonly-used Screenplay services and anything else required at the root level of your test logic. If Screenplay were to be extended to work with frameworks such as xUnit or MSTest, then this same technique would be used. Example This is an example of an NUnit-style test method with a parameter-injected dependency. This would require installing the NUnit test integration to run. Take note of the Screenplay attribute and the cast parameter. [Test, Screenplay] public async Task TheSampleTestShouldBeInformative(ICast cast) { var janeSmith = cast.GetActor<JaneSmith>(); // ... use the actor with some performables, then make assertions etc }"
  },
  "docs/dependencyInjection/Performables.html": {
    "href": "docs/dependencyInjection/Performables.html",
    "title": "How Performables get their dependencies | Screenplay",
    "summary": "How Performables get their dependencies Importantly, Performable types do not participate in dependency injection from the container. This means that dependency services cannot be constructor-injected into performable types. Performables' state represents parameters Performables are created using the builder pattern and do not hold references to any dependency services. Instead, the state of the performable (and thus their constructor parameters) represent the parameters for the performable's behaviour. This state should be set via constructor parameters and should be immutable. An example For example, a Task which adds an item to the user's shopping basket might accept a constructor parameter representing the unique ID of the product to be added to the basket. That unique ID would be stored within the performable instance, in a readonly field. When the relevant ExecuteAsync method is executed, the unique ID stored in the performable instance is used to conduct whatever logic is appropriate. Use abilities to get dependencies Performables, specifcally Actions and Questions, should access their dependencies via the Actor's Abilities by using the GetAbility<T> method or similar. In this sense, Abilities are a form of dependency injection or service locator (for a specific use case). Whilst service locators are usually considered an anti-pattern, the benefits in this specific case outweigh the disadvantages. The primary benefit is the ability to create performables from static builders. Generally-speaking, Tasks should not make use of Abilities. Only Actions and Questions should use Abilities."
  },
  "docs/dependencyInjection/index.html": {
    "href": "docs/dependencyInjection/index.html",
    "title": "Dependency injection | Screenplay",
    "summary": "Dependency injection The Screenplay design pattern is fundamentally compatible with and based upon dependency injection, aka DI. You may add Screenplay to an existing container if you wish, via the AddScreenplay extension method. Alternatively you may create an instance of Screenplay which uses its own self-contained DI container with the static Screenplay.Create helper method. Learn more about DI in Screenplay How to add services to the container Which services are injectable Getting/injecting services DI scopes"
  },
  "docs/extendingScreenplay/EventHandlers.html": {
    "href": "docs/extendingScreenplay/EventHandlers.html",
    "title": "Writing new Event handlers | Screenplay",
    "summary": "Writing new Event handlers A Screenplay is an architecture for directing a series of steps, organised into groups named Performances. Within that architecture is an event model, which allows arbitrary logic to subscribe to the progress of a Screenplay and react accordingly. This is one of the natural extension points within the Screenplay library. How to subscribe to events Within the CSF.Screenplay.Abstractions library/NuGet package is the type IHasPerformanceEvents. An instance of this type is available to resolve via dependency injection whilst a Screenplay is in-progress. Within DI, this object is a singleton which will emit when any significant Screenplay-related event occurs. Take a look at the API of the interface and its documentation to read about the available events and their meaning. If you wish to extend Screenplay you may subscribe to these from your own logic as you please."
  },
  "docs/extendingScreenplay/ReportFormtters.html": {
    "href": "docs/extendingScreenplay/ReportFormtters.html",
    "title": "Writing new Report value formtters | Screenplay",
    "summary": "Writing new Report value formtters To get the best results when Screenplay writes a report, the wording in the reports should be human-readable and avoid language that relates to .NET. Reports are built from report fragments, accumulated during each performance. Baseline reporting functionality It's strongly recommended that all performables and all abilities implement the ICanReport interface. This allows these types to generate report fragments when they are performed-by or granted-to to Actors. Performables and abilities which do not implement ICanReport will use a default/fallback report template which is likely to produce sub-optimal results. Formatting values As noted in the documentation for report fragments, they are written using template strings which include a placeholder syntax. Values must be inserted into these placeholders to get the final report; this is performed by IFormatsReportFragment. There are a few mechanisms by which IFormatsReportFragments converts values to human-readable strings; you are encouraged to pick the most suitable for each scenario. You may extend Screenplay with new implementations of IHasName, IFormattableValue and/or IValueFormatter. Objects with names Actors and some other types implement the interface IHasName. This is suitable for objects which would always appear the same in any report. For example, the Actor \"Joe\" is always \"Joe\"; there's nothing more to their name than that. Self-formattable values Types which implement IFormattableValue have a FormatForReport() method which returns a human-readable formatted representation of that object, suitable for appearance in reports. Use this if the object's state must be used to get the reporting representation, but does not require any external dependencies or services. Obviously, you must have control over the type - the ability to add IFormattableValue to its interfaces - in order to use this technique. Value formatters Value formatters are external objects which are able to format objects, without needing to make any changes to the object-to-be-formatted. Value formatters implement the interface IValueFormatter and must be added to dependency injection, as well as registered with the IFormatterRegistry. The easiest way to perform both of these is to add the Type of the value formatter implementation to ScreenplayOptions.ValueFormatters when creating the Screenplay. Any types added here will automatically be included in the formatter registry and added to DI when the Screenplay is built. Use this technique when either you require external services from dependendency injection to format the object, or if you are unable/unwilling to have the type to be formatted implement IFormattableValue. Use ToString() The least optimal mechanism of formatting values in a report is to rely on the built-in (or an overridden) Object.ToString() method. Whilst this will work in reports, it is intended as fallback functionality for types which are not covered by any of the techniques above. The results of the ToString() method are often a very poor choice for reports."
  },
  "docs/extendingScreenplay/ScreenplayExtensions.html": {
    "href": "docs/extendingScreenplay/ScreenplayExtensions.html",
    "title": "Writing Screenplay Extensions | Screenplay",
    "summary": "Writing Screenplay Extensions Screenplay ships with a small number of Abilities and performables but it is designed to be extended with new ones. New Abilities, Actions and Questions extend Screenplay by allowing Actors to interact with new APIs, services and libraries. Broadly-speaking to extend Screenplay in this way you must: Write one or more new ability types which provide access to the API of the service or library with which you'd like to interact Write one or more Action and/or Question Performables which make use of that ability Writing abilities Recall that Abilities represent capabilities & dependencies granted to or associated with Actors. It is normal for developers to want to write new Ability classes in order to provide capabilities/dependencies which are not yet catered-for. Ability classes do not need to derive from any particular base type, although it is strongly recommended that they implement ICanReport. Ability classes may constructor-inject dependencies and should declare whatever API is appropriate. Writing Actions and/or Questions Hand-in-hand with writing new ability classes, comes writing new Action and/or Question performables. These classes must derive from an appropriate Performable interface and should also implement ICanReport. These actions/questions should interact with the ability and make use of its functionality or return a value accordingly. Recall that actions & questions should be as granular as reasonably possible, accepting whatever parameters are appropriate for the usage of the ability. Continue to follow best practice for performables, though."
  },
  "docs/extendingScreenplay/TestIntegrations.html": {
    "href": "docs/extendingScreenplay/TestIntegrations.html",
    "title": "Writing new Test framework integrations | Screenplay",
    "summary": "Writing new Test framework integrations A way in which Screenplay is available for extension is the integration of Screenplay with other Test frameworks. Screenplay currently ships with integrations for NUnit and Reqnroll but developers are free to integrate it into other frameworks if they wish. Developers who are interested in this may use the source code to these two integrations as inspiration. Requirements To integrate with a test framework, the minimum requirements are as follows. Requirements which must be fulfilled are crucial to the operation of Screenplay; the integration will malfunction if they are not satisfied. Requirements which should be fulfilled are not crucial, but are strongly recommended for a good developer experience when using the integration. Terminologies differ between testing frameworks; the word Scenario is used to refer to the individual tests that the testing framework executes. The test framework must create an instance of Screenplay before it runs any Scenarios If the test framework uses dependency injection then it is advantageous to integrate Screenplay with that, via AddScreenplay If not then consider the Create factory method Consider permitting extensibility here, using the IGetsScreenplay interface Before any Scenarios run, the framework must execute BeginScreenplay() from the Screenplay instance After all Scenarios have completed it must execute CompleteScreenplay() from the Screenplay instance Each Scenario in the test framework must have its own Performance, within its own a DI lifetime scope Consider using the CreateScopedPerformance method to achieve this The Performance associated with each Scenario should have its NamingHierarchy set according to the name of the Scenario Typically this is done via parameter when creating the Performance It may alternatively be updated after creation Test frameworks have different conventions, so the precise semantics of this name is up to the framework itself The purpose of setting this is to clearly match the Performance to the Scenario to which it relates, when reading reports; if missing then the information will not be present in the report Before the logic of each Scenario starts, the BeginPerformance() method must be executed from the corresponding Performance After the logic of each Scenario ends, the FinishPerformance(bool?) method must be executed from the corresponding Performance After the logic of each Scenario ends, the dependency injection scope associated with the Performance should be disposed Failure to do this could lead to memory leaks or unnecesarily high resource usage whilst the Screenplay is in-progress The test framework must provide access to at least the ICast and IStage, resolved from the Scenario's dependency injection scope, to the Scenario logic The manner of doing this depends entirely on the test framework By way of example, in NUnit this is performed by providing the values of parameters to the test method, in Reqnroll this is performed by resolving step bindng classes from that same DI scope, allowing constructor injection"
  },
  "docs/extendingScreenplay/index.html": {
    "href": "docs/extendingScreenplay/index.html",
    "title": "Extending Screenplay | Screenplay",
    "summary": "Extending Screenplay Screenplay has numerous extension points available for developers to add their own functionality. Screenplay extensions Dependency services Event handlers Report value formatters Test integrations"
  },
  "docs/extensions/index.html": {
    "href": "docs/extensions/index.html",
    "title": "Screenplay extensions | Screenplay",
    "summary": "Screenplay extensions This page lists the officially-supported Screenplay Extensions. Selenium: remote control Web Browsers using Selenium Web Driver Web APIs: communicate with Web APIs with an HTTP Client"
  },
  "docs/extensions/selenium/Actions.html": {
    "href": "docs/extensions/selenium/Actions.html",
    "title": "Selenium actions | Screenplay",
    "summary": "Selenium actions The Selenium extension for Screenplay provides numerous Actions, each of which represents one of the smallest possible interactions with a web browser/page. Broadly, these actions fall into the following categories: Actions which work with HTML elements (targets), such as \"click on a specified element\" or \"type some keys into an input box\". These actions will always require a target as a parameter. Actions which interact directly with the web browser, such as \"take a screenshot\" or \"clear the cookies for the current domain\". Actions which represent waiting for something, such as \"wait until the progress bar reaches 100%\" or \"wait until the shopping cart items are visible\". Recall that Screenplay Actions do something without getting any result. To interrogate a web page (to observe it in some manner), use one of the Selenium extension's Questions. Below is a summary of each of these actions' usage, with a link to their detailed documentation page. Actions that work with targets Action Usage ClearTheContents Remove/clear all text from the specified element, such as an <input> Click Click on the specified element DeselectByIndex Deselect an option from the specified <select> element by its index DeselectByText Deselect an option from the specified <select> element by its displayed text DeselectByValue Deselect an option from the specified <select> element by its underlying value DeselectAll Deselects every option from the specified <select> element SelectByIndex Select an option from the specified <select> element by its index SelectByText Select an option from the specified <select> element by its displayed text SelectByValue Select an option from the specified <select> element by its underlying value SendKeys Type text (send keystrokes) whilst a specified element has focus Actions which work with the browser Action Usage ClearCookies Clear the web browser cookies for the current site (domain) ClearLocalStorage Clear the web browser local storage for the current site (domain) DeleteTheCookie Delete a single named cookie ExecuteJavaScript Executes a JavaScript directly in the browser OpenUrl Directs the browser to open a specified URL SaveScreenshot Saves a screenshot to a file Actions which wait Action Usage Wait Pauses the Performance until a condition is true WaitForSomeTime Pauses the Performance for an arbitrary amount of time"
  },
  "docs/extensions/selenium/NamedScripts.html": {
    "href": "docs/extensions/selenium/NamedScripts.html",
    "title": "Named JavaScripts | Screenplay",
    "summary": "Named JavaScripts Sometimes it is neccesary to execute JavaScript in the web browser. This might be to work around a limitation in a WebDriver implementation, such as web browsers which cannot enter values into date fields. At other times, JavaScript might be used to perform large-scale operations which would perform very poorly if conducted through many WebDriver interactions. This is particularly relevant where a Remote WebDriver is being used, in which each individual interaction suffers the latency and overhead of a remote network request/response. Named scripts provide a mechanism by which developers may build a library of reusable pre-defined scripts and give them human-readable names. This way, when those scripts are used, they produce clear and concise entries in the Screenplay report. Additionally, named scripts provide .NET type safety via generic type parameters. The classes There are many script classes available, differing primarily in the number of paramaters which they accept. Here is a table listing them all. Pick the one which returns/does not return a result and which has the correct number of parameters for your script. Params No result With result 0 NamedScript NamedScriptWithResult<TResult> 1 NamedScript<T1> NamedScriptWithResult<T1,TResult> 2 NamedScript<T1,T2> NamedScriptWithResult<T1,T2,TResult> 3 NamedScript<T1,T2,T3> NamedScriptWithResult<T1,T2,T3,TResult> 4 NamedScript<T1,T2,T3,T4> NamedScriptWithResult<T1,T2,T3,T4,TResult> 5 NamedScript<T1,T2,T3,T4,T5> NamedScriptWithResult<T1,T2,T3,T4,T5,TResult> 6 NamedScript<T1,T2,T3,T4,T5,T6> NamedScriptWithResult<T1,T2,T3,T4,T5,T6,TResult> 7 NamedScript<T1,T2,T3,T4,T5,T6,T7> NamedScriptWithResult<T1,T2,T3,T4,T5,T6,T7,TResult> Using a script Execute scripts within your performables using the builder method PerformableBuilder.ExecuteAScript or one of its many same-named overloads. Generic type inference will offer the appropriate number and types of parameters and will expose a strongly-typed result if applicable. Within the JavaScript body, the parameters are accessible via an arguments object. Each parameter is assigned to this object using a zero-based index. So, the first parameter value is arguments[0], the second arguments[1] and so on."
  },
  "docs/extensions/selenium/Queries.html": {
    "href": "docs/extensions/selenium/Queries.html",
    "title": "Queries | Screenplay",
    "summary": "Queries Queries are a unified mechanism by which Elements are interrogated/observed. Queries broadly serve two purposes, as described below. Observing the state of elements Queries are used directly by the SingleElementQuery<TResult> and ElementCollectionQuery<TResult> questions which are included in the Selenium extension for Screenplay. In this usage, the query indicates which piece of state is to be retrieved from the element(s) and returned to the consuming performable. Specifying criteria A mechanism which parallels queries is present in the class QueryPredicatePrototypeBuilder. This mechanism uses the combination of a query and a predicate to specify criteria by which element(s) may be matched. This applies to two use-cases: The methods of TargetExtensions may be used to build instances of the Wait action. Together, the query and predicate specify the condition for the wait to end. The query prototype builder is also used by one of the overloads of the ForThoseWhich builder method. This builder may be used to create the FilterElements question, to specify the criteria by which to match elements which should be accepted by the filter. List of queries The available queries are best found by reading the list of methods available on two classes. For usages of queries to observe/read a piece of information, see the functionality present upon the QuestionQueryBuilder class. For usages relating the the creation of criteria, see the members of the QueryPredicatePrototypeBuilder class. Recall, each query reads a piece of information from an HTML element (or elements in a collection), or it creates a criteria for matching either one or a collection of elements."
  },
  "docs/extensions/selenium/Questions.html": {
    "href": "docs/extensions/selenium/Questions.html",
    "title": "Selenium questions | Screenplay",
    "summary": "Selenium questions The Selenium extension for Screenplay provides Questions, each of which observes the web browser and its current contents in some manner, returning a result. There are three broad categories of questions in the Selenium extension: Questions which read something from a specified element or elements, such as \"get the text of the username label\" or \"get the color of each of the status indicators\". Questions which find or query-for HTML elements, such as find all checkboxes in the to-do list which are checked or get the first status label which has a red background. Questions which interact directly with the web browser. What is common to all Screenplay Questions is that they get information, or a result object. They do not make changes to the state of the application/web browser. To interact with the web page in a way which could change its state, use one of the Selenium extension's Actions. Below is a summary of each of these questions' usage, with a link to their detailed documentation page. Questions which query the state of elements Questions which read-from or observe HTML elements operate using a common mechamism, named Queries. Queries provide a builder-friendly manner by which to read state from either one or a collection of elements. Each of the Questions listed below makes use of a Query to identify the state which is to be read from the element. Question Usage SingleElementQuery<TResult> Reads the state from a target representing a single element ElementCollectionQuery<TResult> Reads the state from a target representing a collection of elements Questions which find or filter elements There are many ways to use these questions, chosen by the way in which you use the relevant builder(s). The possibilities are explained in detail on the questions' detailed documentation pages. Question Usage FindElement Gets an element which matches a Locator FindElements Gets a collection of elements which match a Locator FilterElements Filters a collection of elements for those which match a query Questions for the web browser These questions don't neccesarily involve elements, instead they query the web browser directly. Question Usage ExecuteJavaScriptAndGetResult<TResult> Executes a JavaScript directly in the browser and reads the result GetWindowTitle Reads the text of the Window/Tab title TakeScreenshot Takes a Screenshot of the browser window"
  },
  "docs/extensions/selenium/Targets.html": {
    "href": "docs/extensions/selenium/Targets.html",
    "title": "Targets and elements | Screenplay",
    "summary": "Targets and elements Many of the Selenium Actions, Questions and Tasks in this extension interact with or inspect HTML elements. Elements on a web page are named Targets in Screenplay (you might say \"The target for this action\"). All targets derive from the interface ITarget. Elements and locators Broadly, there are two kinds of target; Elements represent concrete references to elements on a web page. The only way to get an element is to use the WebDriver to retrieve it, such as with the questions FindElement or FindElements. The SeleniumElement and SeleniumElementCollection classes are Elements and these contain instances of the underlying Selenium IWebElement type. Locators, on the other hand, describe or identify elements without being concrete references. The ElementId, ClassName, CssSelector and XPath classes are all Locators. All these types derive from ITarget, so that any of these may be used as the parameter for the Selenium extension's performables. Naming targets Every type which derives from ITarget offers a mechanism by which the target may be named. This is a human-readable name for the target by which it would be recognised. For Locators, this is a constructor parameter, for Elements there is an opportunity to name the element as it is being retrieved. The target name is displayed in the Screenplay Report when it is produced, making easy reading. For example, a single line of a report might read \"John clicks on the Buy Now button\". That would be a report for an actor named John using the Click action upon a target which is named the Buy Now button. Tip Always provide human-readable names for your targets, it makes your reports far more informative. Defining Locators As you will see from their documentation, the Locator classes are easily created, reusable and immutable. This makes them ideal to store in a shared library of locators, organised according to the web application. The recommended way to organise locators (and named URIs) is all that remains of the Page Object pattern, for which the Screenplay pattern is an iteration. A library of URIs and locators might be a series of static classs and static readonly fields. Consider the following. public static sealed class ShoppingCart { public static readonly NamedUri MyCart = new NamedUri(\"https://example.com/user/shopping_cart\", \"my shopping cart\"); public static readonly Locator Items = new CssSelector(\"#shoppingCart ul.items_list li\", \"the items in the cart\"), BuyNow = new ElementId(\"buy_now\", \"the Buy Now button\"); } This provides a URI by which to reach the shopping cart page and two targets for relevant parts of the page. As with the Page Object pattern, the class does not need represent an entire web page. Common components, shared between many pages, may have their own classes. The important difference between libraries of locators and/or named URIs and the original Page Object pattern is that libraries contain no functionality. It is the Screenplay Performables which contain the logic, independently of the targets and URIs. These performables may be parameterised with the targets and/or URIs, or they may consume targets/URIs directly from within the performable logic. The choice is up to the developer writing them, allowing flexibility between both approaches. Tip Store your locators and named URIs in libraries (for example static classes, as shown above). Organise these in however best makes sense for your application, perhaps by page or by component. Do not include any functionality/performable logic in these libraries."
  },
  "docs/extensions/selenium/Tasks.html": {
    "href": "docs/extensions/selenium/Tasks.html",
    "title": "Selenium tasks | Screenplay",
    "summary": "Selenium tasks As noted in their glossary definition, Tasks are a kind of performable which composes other performables. The Selenium extension for Screenplay provides a small number of Tasks, which simplify some common WebDriver processes. The table below serves as a list, along with a brief summary of the purpose of each. Task Usage ClickAndWaitForDocumentReady Clicks a link which navigates to a new page, waiting until it is ready EnterTheDate Enters a value into an <input type=\"date\"> in a cross-browser manner OpenUrlRespectingBase Navigates to a URL, using a base URL provided by the UseABaseUri ability SetTheElementValue Sets the value of an element with JavaScript, emulating updating it interactively TakeAndSaveScreenshot Convenience task to combine the taking & saving of a browser screenshot"
  },
  "docs/extensions/selenium/index.html": {
    "href": "docs/extensions/selenium/index.html",
    "title": "CSF.Screenplay.Selenium Extension | Screenplay",
    "summary": "CSF.Screenplay.Selenium Extension The Selenium extension allows Actors to control web browsers using Selenium WebDriver technology. The control of web browsers in this manner is the origin of the Screenplay pattern, in which it was an improvement and thorough refactoring of the older Page Object pattern. Core contents of this extension Like many extensions, the Selenium extension provides: The Ability BrowseTheWeb, which provides access to the WebDriver API Several Actions, which allow an actor to interact with the web page Several Questions, which allow an actor to read or observe the web page Tasks, for commonly-performed combinations of actions & questions Models representing the UI, URLs and areas of the page The NamedUri class is used to navigate to specific pages Types which provide references to HTML elements on the page, deriving from ITarget Many of the Performables provided by this extension operate in the format \"Actor performs X vaction upon Y element\". A core benefit of Screenplay (over Page Object pattern) is the separation of the functionality (the logic of the interaction) and the UI elements (the target of the interaction). This improves reusability and composability. Additional contents The types listed above are the core of the Selenium plugin, but there's more available. This extension integrates with the Browser Quirks feature of CSF.Extensions.WebDriver. That allows it to provide integrated workarounds for the quirks of some browsers. These workarounds are amongst the Tasks noted above. This extension provides a Color struct which provides a cross-browser way of describing sRGB color and testing for equality. For occasions on which JavaScript must be sent to the browser, this extension provides Named Script classes which offer a type-safe mechanism to refer to those scripts from .NET code. If the default wait timeout of 5 seconds is unsuitable, the ability UseADefaultWaitTime may be used to specify a default timeout suitable for your use-case."
  },
  "docs/extensions/webApis/ChoosingEndpointsAndRequests.html": {
    "href": "docs/extensions/webApis/ChoosingEndpointsAndRequests.html",
    "title": "Common combinations of requests and endpoints | Screenplay",
    "summary": "Common combinations of requests and endpoints The appropriate combination of Request action type and Endpoint type depends upon your use case. Common use cases are summarised in the table below. Information about reading this table follows. Request payload Response type Endpoint type Request action type None None Endpoint SendTheHttpRequest None Deserialized with custom logic Endpoint<TResult> SendTheHttpRequestAndGetTheResponse<T> None Deserialized from JSON Endpoint<TResult> SendTheHttpRequestAndGetJsonResponse<T> Serialized with custom logic None Derive from ParameterizedEndpoint<TParameters> SendTheHttpRequest Serialized with custom logic Deserialized with custom logic Derive from ParameterizedEndpoint<TParameters,TResult> SendTheHttpRequestAndGetTheResponse<T> Serialized with custom logic Deserialized from JSON Derive from ParameterizedEndpoint<TParameters,TResult> SendTheHttpRequestAndGetJsonResponse<T> Serialized with JSON None JsonEndpoint<TParameters> SendTheHttpRequest Serialized with JSON Deserialized with custom logic JsonEndpoint<TParameters,TResult> SendTheHttpRequestAndGetTheResponse<T> Serialized with JSON Deserialized from JSON JsonEndpoint<TParameters,TResult> SendTheHttpRequestAndGetJsonResponse<T> Tip To decide which types of endpoint & performable: Choose the endpoint type based upon the needs of the request, adding an extra generic type parameter if the response is to be strongly-typed. Choose the action type based upon the technical details of reading the response. The first two columns The first two columns indicate: The kind of request payload which will be sent These are the parameters to the API function described by the endpoint The type of the expected response body Where an API function returns a response, this is the .NET type which will be used to represent that response Where None is listed in either column this means \"not applicable\". For example, an API function which uses no parameters will have no request payload. In the case of responses, None might mean that the response body will be ignored. The second two columns The second two columns indicate the Endpoint type and Request action type which are recommended in this scenario."
  },
  "docs/extensions/webApis/Endpoints.html": {
    "href": "docs/extensions/webApis/Endpoints.html",
    "title": "Endpoints | Screenplay",
    "summary": "Endpoints Endpoints are fundamental to this extension; they are .NET class instances which describe a piece of API functionality which may be consumed. The single most important (and obvious) piece of information stored in an endpoint object is the URL (route) which is used to communicate with the API function. Endpoint classes The WebAPIs Screenplay extension provides a number of classes by which to describe endpoints. Developers using this extension are encouraged to create 'libraries' of Endpoints within their own logic. Such a library might be as simple as a static class which contains public static get-only properties, each of which returns a named endpoint. Every endpoint class derives from a base class named EndpointBase. The endpoint classes available are listed below. There is also an article indicating how to choose an appropriate combination of Endpoint and Request action. Endpoint Endpoint<TResponse> ParameterizedEndpoint<TParameters> - intended to be used as a base class ParameterizedEndpoint<TParameters,TResponse> - intended to be used as a base class JsonEndpoint<TParameters> JsonEndpoint<TParameters,TResponse> Common to all endpoints All endpoints describe: The URL pattern to reach the endpoint The HTTP method used with the endpoint A human-readable name for the endpoint An optional timeout for the endpoint"
  },
  "docs/extensions/webApis/Requests.html": {
    "href": "docs/extensions/webApis/Requests.html",
    "title": "Request actions | Screenplay",
    "summary": "Request actions Sending an HTTP request to an API is accomplished using a Screenplay Action. There are three action types available; which to use depends upon the expected response from the API. This article helps you choose the appropriate combination of Request Action and Endpoint types. The three action types As might be evident from their names, each request action type is used for a different kind of expected response message. In the case of SendTheHttpRequest, there is no response expected (or the response will be ignored). The other two types are for either a JSON response or a response which requires custom deserialization. SendTheHttpRequest SendTheHttpRequestAndGetJsonResponse<TResponse> SendTheHttpRequestAndGetTheResponse<TResponse> Use WebApiBuilder to simplify usage A builder/helper class is available to simplify getting the appropriate Request action; this is WebApiBuilder. The recommended way to consume this is to add using static CSF.Screenplay.WebApis.WebApiBuilder; to the source file for any Performable you write which consumes Web APIs via this extension. When an approproate Endpoint type has been used, the WebApiBuilder class will make it very easy to select the correct action, via type inference. To get a request for an API function which is expected to return a JSON-formatted response, use the method GetTheJsonResult. To get a request for any other API function, use the method SendTheHttpRequest. Both of these methods have several overloads, for each type of endpoint which could use them."
  },
  "docs/extensions/webApis/Responses.html": {
    "href": "docs/extensions/webApis/Responses.html",
    "title": "Responses | Screenplay",
    "summary": "Responses The WebAPIs extension for Screenplay supports two kinds of responses. JSON For JSON-based endpoints, use the SendTheHttpRequestAndGetJsonResponse<TResponse> request action type and the response from the API function will automatically be deserialized into an instance of the TResponse type. Other response types For other endpoints with non-JSON responses, it is up to the consumer to deserialize the response using whatever logic is appropriate. In this case, using the SendTheHttpRequestAndGetTheResponse<TResponse> request action type, the returned value from PerformAsAsync is an instance of HttpResponseMessageAndResponseType<TResponse>. This model object includes the raw/original HttpResponseMessage which was returned from the HTTP Client, but the class is generic for the intended type of the response. This should provide sufficient information to deserialize the response accordingly."
  },
  "docs/extensions/webApis/index.html": {
    "href": "docs/extensions/webApis/index.html",
    "title": "CSF.Screenplay.WebApis Extension | Screenplay",
    "summary": "CSF.Screenplay.WebApis Extension The Web APIs Extension allows Actors to communicate with HTTP web API endpoints within a Screenplay Performance. Overview The fundamentals of this Screenplay extension are shown in the diagram below. The concepts of the Actor and Ability (the ability is named MakeWebApiRequests) are explained in Screenplay's core documentation. Other concepts are explained below. This extension provides Actions which allow the Actor to build and send HTTP requests based upon Endpoint definitions. These requests are sent via the HTTP client which is exposed by the MakeWebApiRequests Ability, to a live API server. The server returns an HTTP Response, which the extension formats into a result object. flowchart Ability -- \"Has ability\" --> Actor Actor -- \"Makes requests\" --> Request Endpoint -- \"Requests target\" --> Request Request --> api[\"Live API\"] Ability -- \"Facilitates request\" --> api api --> Response style api fill:#ee9,stroke:#bb6 Note that the Live API in this diagram is not a part of Screenplay or this extension. The Live API represents an actual HTTP(S) web server which hosts the API with which Screenplay is communicating. Usage example Here is a brief usage example for using a JSON API with a defined endpoint, identified by URL and HTTP method. The endpoint expects a parameter of a PersonId (a fictitious class, which accepts a person's name as a constructor parameter). The endpoint returns a JSON-formatted response which is a representation of an Animal (another fictitious class, which has a string Name property). using static CSF.Screenplay.WebApis.WebApiBuilder; static readonly JsonEndpoint<PersonId,Animal> getFavouriteAnimal = new (\"https://api.example.com/person/getFavouriteAnimal\", HttpMethod.Post); // this method would appear as part of a custom-written Task class, // deriving from IPerformableWithResult<string> public async ValueTask<string> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken) { var animal = await actor.PerformAsync(GetTheJsonResult(getFavouriteAnimal, new(\"Jane Doe\")), cancellationToken); return animal.Name; }"
  },
  "docs/gettingStarted/nonTesting/index.html": {
    "href": "docs/gettingStarted/nonTesting/index.html",
    "title": "Using Screenplay for process automation | Screenplay",
    "summary": "Using Screenplay for process automation Screenplay is often used as a tool for automating software tests, but it is not limited to only this usage. Screenplay may be added to any application or library, via dependency injection. This is as simple as installing the CSF.Screenplay NuGet package and adding Screenplay to your service collection. For more information, see the documentation for ScreenplayServiceCollectionExtensions. using CSF.Screenplay; // IServiceCollection services; services.AddScreenplay(); // ... then, after the service collection is built: // IServiceProvider serviceProvider; var screenplay = serviceProvider.GetService<Screenplay>(); // Or you may constructor-inject an instance of Screenplay into // any type which was resolved from the service provider Once Screenplay has been added to your DI, you may resolve and use Screenplay-related services from dependency injection. To execute some logic in the scope of a Performance, consider using the method Screenplay.ExecuteAsPerformanceAsync. Abstractions package If your solution is separated into multiple projects/assemblies then only your entry-point project needs the full CSF.Screenplay NuGet package. Once Screenplay has been added to DI, other projects in the solution may consume its logic, only requiring the CSF.Screenplay.Abstractions package."
  },
  "docs/gettingStarted/nunit3/index.html": {
    "href": "docs/gettingStarted/nunit3/index.html",
    "title": "Screenplay & NUnit tutorial | Screenplay",
    "summary": "Screenplay & NUnit tutorial Begin writing NUnit tests using Screenplay by following these steps. Further detail is provided below. Ensure that your test project uses NUnit version 3.6.0 or higher Install the NuGet package CSF.Screenplay.NUnit to your test project Write a class which implements IGetsScreenplay Decorate your test assembly with ScreenplayAssemblyAttribute, referencing your implementation of IGetsScreenplay Write your tests, decorating each test method with ScreenplayAttribute Add parameters to your test methods to access the Screenplay architecture Tip Developers are encouraged to read these best practices for writing tests which use Screenplay. Decorating your test assembly with [ScreenplayAssembly] So that your tests may make use of a Screenplay, you must install the Screenplay extension to the NUnit testing framework. This is steps 3 & 4 in the list above. This is achieved using the ScreenplayAssemblyAttribute. Place a line of code somewhere in your test project, outside of any type definition like this: [assembly: CSF.Screenplay.ScreenplayAssembly(typeof(MyScreenplayFactory))] There is one other thing you must do, and that is to write a screenplay factory class, which configures how the Screenplay should be created for your tests. A screenplay factory is a class which must implement IGetsScreenplay. Consider the example below as a starting point for writing your own. using CSF.Screenplay; public class MyScreenplayFactory : IGetsScreenplay { public Screenplay GetScreenplay() { return Screenplay.Create(services => { // Add your own dependency injection service descriptors to the service collection here // For example, services which will be used by Screenplay Abilities. }); } } Important When using NUnit with Screenplay, every Screenplay-using test within a test assembly (thus, within a .NET project) must share the same instance of Screenplay. This is not expected to be problematic, as all the Screenplay object does is set-up the Screenplay architecture and dependency injection for the tests. Writing test methods When writing test methods, the test methods must be decorated with ScreenplayAttribute, which activates Screenplay for that particular test method. NUnit test methods which are decorated with [Screenplay] may have test parameters; these parameters will be provided by dependency injection. This covers steps 5 & 6 in the list above. Here is an example of an NUnit test method which is written using Screenplay; it assumes that the assembly has been decorated with ScreenplayAssemblyAttribute, as noted above. Tip The ability, performables and DishwashingBuilder used in this test, related to washing dishes, are all fictitious. See the documentation for writing performables to learn about how these could be written. using CSF.Screenplay; using static CSF.Screenplay.PerformanceStarter; using static WashingTheDishes.DishwashingBuilder; [Test, Screenplay] public async Task TheDishesShouldBeCleanAfterJoeWashesThem(ICast cast, IDishWashingAbility washTheDishes) { var joe = cast.GetActor(\"Joe\"); joe.IsAbleTo(washTheDishes); await Given(joe).WasAbleTo(GetSomeDirtyDishes()); await When(joe).AttemptsTo(WashTheDishes()); var dishesCondition = await Then(joe).Should(LookAtTheDishesCondition()); Assert.That(dishesCondition, Is.EqualTo(\"Clean\")); }"
  },
  "docs/gettingStarted/reqnroll/index.html": {
    "href": "docs/gettingStarted/reqnroll/index.html",
    "title": "Screenplay & Reqnroll tutorial | Screenplay",
    "summary": "Screenplay & Reqnroll tutorial Tip Are you using the legacy SpecFlow? Reqnroll is the maintained fork of SpecFlow, so it's recommended you upgrade your projects ASAP. For now, CSF.Screenplay continues to support SpecFlow. Use the CSF.Screenplay.SpecFlow package and SpecFlow v3.4.3 or higher instead. The remainder of the instructions below work for either Reqnroll or SpecFlow. Begin writing Reqnroll tests using Screenplay by following these steps. Further detail is provided below. Ensure that your test project uses Reqnroll version 2.0.0 or higher Install the NuGet package CSF.Screenplay.Reqnroll to the project which will contain your .feature files Optional: Add services to dependency injection which will be required by the Abilities you intend to use. If required, use Reqnroll context injection & hooks to add these to the DI container. Write step binding classes which dependency-inject and use Screenplay's architecture Writing step bindings Important When using Reqnroll with Screenplay, every Screenplay-using test within a test assembly (thus, within a .NET project) must share the same instance of Screenplay. This is not expected to be problematic, as all the Screenplay object does is set-up the Screenplay architecture and dependency injection for the tests. When using Screenplay with Reqnroll, .feature files are written as normal. The only difference in writing your tests is that Step Binding classes should inject Screenplay architecture and use it within the bindings. The recommended services to inject into your step binding classes are either IStage or ICast. If you are using Personas, which are the recommended way to get Actors for your performances, then most step binding classes will need only one of the two services above. If you are not using Personas to get actors, then you might also need to inject some services which relate to the Abilities that you wish to grant actors. Example Tip The implied ability, the performables, persona and DishwashingBuilder used in this test, related to washing dishes, are all fictitious. See the documentation for writing performables to learn about how these could be written. This example assumes that Reqnroll is writting using the NUnit runner, and thus it makes use of NUnit-style assertions. Feel free to replace the assertion with whichever assertion library you wish to use. using CSF.Screenplay; using static CSF.Screenplay.PerformanceStarter; using static WashingTheDishes.DishwashingBuilder; [Binding] public class WashTheDishesSteps(IStage stage) { [Given(@\"^Joe was able to get some dirty dishes$\")] public async Task GetDirtyDishes() { var joe = stage.Spotlight<Joe>(); await Given(joe).WasAbleTo(GetSomeDirtyDishes()); } [When(@\"^(?:he|she|they) attempts? to wash the dishes$\")] public async Task WashTheDishes() { var actor = stage.GetSpotlitActor(); await When(actor).AttemptsTo(WashTheDishes()); } [Then(@\"^(?:he|she|they) should see that the dishes are clean$\")] public async Task GetDirtyDishes() { var actor = stage.GetSpotlitActor(); var condition = await Then(actor).Should(LookAtTheDishesCondition()); Assert.That(condition, Is.EqualTo(\"Clean\")); } }"
  },
  "docs/index.html": {
    "href": "docs/index.html",
    "title": "Get started with Screenplay | Screenplay",
    "summary": "Get started with Screenplay 1. Install Screenplay The first step is to decide how you'd like to use it: As a testing tool, with NUnit 3 As a testing tool, with Reqnroll Users of the retired SpecFlow should follow the Reqnroll guide As a process automation library, not as a testing tool 2. Pick extensions To get the most from Screenplay you should install one or more extensions. These give Screenplay the capability to interact with and control other systems. Here is a list of the extensions which are authored alongside Screenplay's core. If you'd like, you are also encouraged to write your own extension, adding new capabilities to Screenplay."
  },
  "docs/introduction/Performances.html": {
    "href": "docs/introduction/Performances.html",
    "title": "Performances in more detail | Screenplay",
    "summary": "Performances in more detail As noted in the previous article, a Performance is a scope (beginning and end) of some logic which is written using the Screenplay Framework. A Screenplay may have as many Performances as it needs. Let's revisit the diagram from the previous article, looking in more detail at the makeup of a Performance. The diagram below omits the Screenplay and consuming logic. On the other hand, it includes some concepts which were omitted from the previous diagram. block-beta columns 4 Performance:4 Actors Performables:3 space Tasks:3 space:4 Abilities Actions Questions otherTasks[\"Other Tasks\"] space:4 ext[\"Screenplay extension\"]:3 style ext fill:#EE9,stroke:#AA4 Abilities -- \"Provide\\ncapabilities\" --> Actors Actions -- \"Compose\" --> Tasks Questions -- \"Compose\" --> Tasks otherTasks -- \"Compose\" --> Tasks ext -- \"Provide\" --> Abilities ext -- \"Provide\" --> Actions ext -- \"Provide\" --> Questions The three kinds of performable All performables will fall into one of three categories. Recall that a performable is a reusable piece of logic. In C# or VB.NET, each performable is a class. Actions are the smallest possible piece of logic to do something; they make a single, granular change Questions are the smallest possible piece of logic to query, get or read something; they do not change things Tasks are higher-level pieces of logic which are composed from any of Actions, Questions or other Tasks Note that these three 'kinds' do not correspond directly to .NET types, such as interfaces. By coincidence, there are three base interfaces for performables; these do not correspond to Actions, Questions and Tasks. Actions and Questions are usually provided by a Screenplay Extension. Most performables are Tasks; developers using Screenplay will write their own tasks, which make use of the Actions and Questions and compose them into pieces of logic which are relevant to their application. Abilities provide capabilities to Actors Abilities are classes which provide capabilities to Actors who 'have' that ability. Abilities are usually provided by a Screenplay Extension and each typically enables the Actor to use Actions & Questions which interact with a specific technology. An example of an ability is one named BrowseTheWeb, which is provided by the CSF.Screenplay.Selenium extension. The BrowseTheWeb ability grants the Actor the capability to make use of a Selenium WebDriver, to control desktop web browsers from .NET code. Screenplay extensions: Bundles of Abilities, Actions & Questions This brings us along to what a Screenplay Extension is. Each Extension provides a set of Abilities, Actions and Questions which deal with a specific technology. Two examples are: CSF.Screenplay.Selenium - provides an ability to control desktop Web Browsers along with Actions & Questions representing each fine-grained interaction with the browser CSF.Screenplay.WebApis - provides an ability, actions and questions to make requests to web API endpoints Next: What's it like using Screenplay? Read page 3, where we take a deep dive into the code of two sample Performances."
  },
  "docs/introduction/SamplePerformances.html": {
    "href": "docs/introduction/SamplePerformances.html",
    "title": "Sample performances | Screenplay",
    "summary": "Sample performances Let's take a look at what a Performance looks like. The following is written in C#, as a test, using the NUnit syntax, using the CSF.Screenplay.Selenium extension. This was selected to demonstrate a variety of Screenplay's features, used in a manner that's close to a real-world scenario. NUnit is a popular testing framework, recognisable to most .NET developers. using static CSF.Screenplay.PerformanceStarter; using static MyAppNamespace.ShoppingCartBuilder; [Test, Screenplay] public async Task TheQuantityOfAnItemShouldBeIncrementedAfterAddingAnother(ICast cast) { var webster = cast.GetActor<Webster>(); await Given(webster).WasAbleTo(OpenTheAppWithAnEmptyShoppingCart()); await Given(webster).WasAbleTo(AddAProductToTheirCartNamed(\"Blue widget\")); await When(webster).AttemptsTo(AddAProductToTheirCartNamed(\"Blue widget\")); var quantity = await Then(webster).Should(ReadTheQuantityOfItemsInTheirCartNamed(\"Blue widget\")); Assert.That(quantity, Is.EqualTo(2)); } [Test, Screenplay] public async Task TheTotalValueOfTheCartShouldEqualTheQuantityMultipliedByUnitPrice(ICast cast) { var admira = cast.GetActor<Admira>(); var webster = cast.GetActor<Webster>(); await Given(admira).WasAbleTo(SetThePriceOfAProduct(\"Blue widget\", \"$4.99\")); await Given(webster).WasAbleTo(OpenTheAppWithAnEmptyShoppingCart()); await Given(webster).WasAbleTo(AddAProductToTheirCartNamed(\"Blue widget\")); await When(webster).AttemptsTo(AddAProductToTheirCartNamed(\"Blue widget\")); var quantity = await Then(webster).Should(ReadTheTotalValueOfTheirCart()); Assert.That(quantity, Is.EqualTo(\"$9.98\")); } Notable features Let's look a little more deeply into these two performances. The headings below point out how they differ from normal NUnit tests; these differences are the features of Screenplay. Static usings for builders At the very beginning of the code listing are two using static declarations. Screenplay relies heavily on the builder pattern, including static builders, in order to provide a fluent interface. The static builder PerformanceStarter is common to Screenplay when using tests; the second is fictious. ShoppingCartBuilder is provided as an example of a builder that the author of these tests might have written for their own performables. The [Screenplay] attribute When using Screenplay with NUnit, each test method must have the [Screenplay] attribute. This requirement is specific to the NUnit integration for Screenplay. The ICast parameter The Cast is one of the mechanisms by which the Performance logic may access Actors. Just like in a real-life theater performance, the Cast is a collection of the Actors who are involved. Part of the role of the [Screenplay] attribute (above) is to provide an appropriate implementation of the Cast object to NUnit, so that it may be 'parameter injected' into tests as shown here. The strongly-typed Actors Notice how when the cast is used to get actors, it uses a class with the actor's name as the generic type parameter to GetActor? This is a technique called a Persona; personas are the best way to define Actors. The logic which grants/configures the Actors' Abilities is contained within a reusable Persona class. This way the same-named actor has the same abilities across every Performance in the Screenplay, making them easy to recognise and understand. Good Personas/Actors have names which remind you of their role in the Performance. In this case Admira is an Administrator, who can edit the prices of items for sale in the app. Webster is someone browsing the web, who is otherwise unremarkable. The Given/When/Then methods When writing a test, Given/When/Then (aka Arrange/Act/Assert) is a popular way to organise test logic. This is available in Screenplay and (if using it for tests) developers are encouraged to use it to separate set-up logic, the logic which conducts the test, and logic which leads to an assertion. These three methods (which take an Actor as a parameter) are followed-up with either a WasAbleTo, AttemptsTo or Should method. These three follow-up methods are synomymous and none have any limitations or functionality different from the others. They are named differently only to improve the readability of the test logic. The performables There are a number of Performables used in these two performances. All the performables listed above would be Tasks, because they are high-level verbs which are written in terms of the application being tested. To use syntax like this, it is assumed that there are some static factory/builder methods on a (fictitious) class named ShoppingCartBuilder, accessible without the class name via the using static declaration (above). The Performables included in these tests are: OpenTheAppWithAnEmptyShoppingCart AddAProductToTheirCartNamed ReadTheQuantityOfItemsInTheirCartNamed SetThePriceOfAProduct ReadTheTotalValueOfTheirCart Just by reading the code, we can already see that: Some of these Performables can accept parameters Some of these Performables can return results Notice how each of these tasks is named in a manner which makes it very clear and obvious what they accomplish. Each name begins with a verb, and their name would make sense to both developers and non-developers alike, assuming they are at least familiar with the application/domain of logic in question. The assertions Notice that the assertions at the end of each test is a normal NUnit assertion. When writing tests using Screenplay it is best practice to place any assertions outside of any Performables; write it at the end of the Performance (end of the test) just like any other test. Next: Let's see some of those Tasks Read page 4, in which we take two of the Tasks from this example and examine their code"
  },
  "docs/introduction/SampleTasks.html": {
    "href": "docs/introduction/SampleTasks.html",
    "title": "Sample tasks | Screenplay",
    "summary": "Sample tasks This introductory documentation continues the example from the previous page. On that page we looked at two sample Performances and what their code might look like. In this page we consider the logic of two Task classes. Recall, a Task is a piece of performable logic which may compose any of Actions, Questions and/or other Tasks. Adding an item to the shopping cart The first task we will consider is the Task which was named AddAProductToTheirCartNamed on the previous page. public static class SitewideUi { public static readonly Locator ProductSearchTextbox = ElementId(\"product-search\", \"the product search\"); public static readonly Locator ProductSearchNowButton = ElementId(\"execute-product-search\", \"the search button\"); } public static class ProductSearchResultsPage { public static readonly Locator AddToCartButtonForProductNamed(string productName) => CssSelector($\"ol.search-results li[data-productName='{productName}'] .addToCart\"); } public class AddAProductToTheirCartNamed(string productName) : IPerformable, ICanReport { public async ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { await actor.PerformAsync(EnterTheText(productName).Into(SitewideUi.ProductSearchTextbox), cancellationToken); await actor.PerformAsync(ClickOn(SitewideUi.ProductSearchNowButton), cancellationToken); var addToCartButton = ProductSearchResultsPage.AddToCartButtonForProductNamed(productName); await actor.PerformAsync(ClickOn(addToCartButton), cancellationToken); } public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) => formatter.Format(\"{Actor} searches for '{ProductName}' and adds one to their cart\", actor, productName); } Reading the cart's total value Now let's consider some code which might form the logic of the Task named ReadTheTotalValueOfTheirCart. public static class ShoppingCartPage { public static readonly Locator TotalCartValue = ElementId(\"cart-value\", \"the total cart value\"); } public class ReadTheTotalValueOfTheirCart : IPerformableWithResult<string>, ICanReport { public async ValueTask<string> PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken = default) { await actor.PerformAsync(NavigateToTheirShoppingCart(), cancellationToken); return await actor.PerformAsync(ReadFromTheElement(ShoppingCartPage.TotalCartValue).TheText(), cancellationToken); } public ReportFragment GetReportFragment(Actor actor, IFormatsReportFragment formatter) => formatter.Format(\"{Actor} reads the total value of their cart\", actor, productName); } Inspecting these two Tasks Now, we will disect the code of these two sample Tasks, to see what we can learn from them. Tasks coordinate other Performables Common to both tasks is that they make prolific use of actor.PerformAsync. This is the mechanism by which Task classes compose other Performables, which may include any or all of Actions, Questions or other Tasks. These consumed Performables are built in the same manner, using the same builders and/or static factories, as if they were being used directly from the Performance logic. As a side-note, the first of these sample Tasks is built using only Actions. The EnterTheText and ClickOn builder methods create Actions, which are built into the CSF.Screenplay.Selenium Extension. The second sample Task makes use of a Question from the same Extension. ReadFromTheElement followed by TheText gets a Question which reads text from the web browser screen. On the other hand, the second sample Task makes use of (a fictitious) Task as well: NavigateToTheirShoppingCart. If this were a real project then the developer would have written that Task also, including whatever logic is required to navigate the current user to their shopping cart screen. Note The same PerformAsync method is used to consume Actions, Questions or Tasks. So, Tasks may consume any kind of Performable. Always implement ICanReport, if you can Notice how each of the Task classes also implements ICanReport? One of the features/benefits of Screenplay which we have not yet touched upon is its ability to produce detailed human-readable Reports of the Performances. By implementing ICanReport, you may decide upon the human-readable report text that the current Task emits to describe itself. Tasks may be built on assumptions Notice that in the Performance in which it was used, the AddAProductToTheirCartNamed task was preceded by a task named OpenTheAppWithAnEmptyShoppingCart. You might infer from this that - if the current Actor had not already navigated to the web application, the Add a Product task would not function correctly. If you did, that's completely correct. The Add a Product task assumes that the current Actor (a user of the shopping web app) already has their browser open somewhere on the app. Note It's perfectly reasonable, recommended in fact, for Tasks to use implicit assumptions about the state of the application. It's encouraged to document these, to aid reusability. Well-known parameters are held in static classes Notice the static classes which are used alongside these tasks. Each provides some Locators which specify some HTML elements on the screen. Locators and HTML elements are specific to the CSF.Screenplay.Selenium Extension, but the principle is the same regardless of the extension. If there's a well-known value, a URL, a file system path, etc, then represent this value in your code. This way it may be referenced by builders and the fluent design of Screenplay Performables. Next: Try Screenplay out for yourself This concludes the introduction to Screenplay. The next step is to try using Screenplay for yourself!"
  },
  "docs/introduction/index.html": {
    "href": "docs/introduction/index.html",
    "title": "Introduction to Screenplay | Screenplay",
    "summary": "Introduction to Screenplay Screenplay is a software design pattern for scripting processes which are made from a series of steps, executed in order. It is particularly useful when many of those steps have a lot in common, making them reuseable. This has seen Screenplay become popular for writing the logic of Behavior-driven development tests. Despite this, Screenplay is not limited to just testing logic. How Screenplay fits into an architecture This diagram provides a very high-level look at where Screenplay lies within the architecture of your software. block-beta columns 3 consumer[\"Screenplay consumer\"]:2 yours[\"Your app, or\\na test framework\"] screenplay[\"Screenplay framework\\nand extensions\"]:2 space Performances:2 script[\"Each is a script\\nwith a beginning & end\"] Actors Performables reusable[\"Reusable\\nbuilding blocks\"] classDef label fill:transparent,stroke:transparent classDef screenplayCode fill:#EE9,stroke:#AA4 class screenplay screenplayCode class yours,script,reusable label The Screenplay consumer The Screenplay consumer is whatever software is using Screenplay. If you are using Screenplay for testing then this is likely a software testing framework such as NUnit or Reqnroll (formerly SpecFlow, until it was discontinued). As noted above, Screenplay can be used by any .NET logic, not just testing frameworks. Screenplay framework and extensions The Screenplay framework is the library/NuGet package CSF.Screenplay. This provides the 'engine' by which the Performances (below) may be executed. Screenplay alone is just an extensible engine, it's not capable of very much on its own. Screenplay extensions provide you with pre-written Performables. Performables shipped with extensions are low-level building blocks which interact with a specific technology. Once you have installed an extension, you may go on to write your own higher-level Performances, using those which are shipped with the extension. Performances A performance is a script; a multi-step process to follow, with a beginning and an end. An app or test framework using Screenplay may have as many performances as it needs. A performance should have a name which a non-developer can understand, so long as they are familiar with your software. If you are using Screenplay as a BDD testing tool then each performance corresponds directly to one test scenario; the name of the performance is the name of the test. Actors Screenplay logic, within each performance, is written from the perspective of Actors. Actors often represent human users of your software, particularly when using Screenplay for testing. An actor might also represent an automated process which is external to the software which Screenplay is controlling. Performables Each performable is a reusable building block of .NET logic; a performable is something that an actor may do. It's completely normal, encouraged even, for performables to be made-of (composed-from) other performables. This way, writing a new performance which is a variation upon an existing performance benefits from maximum code-reuse, minimising code copy-pasting. Next: Introduction to Performances Read page 2 to learn more about the makeup of a Performance."
  },
  "docs/performables/index.html": {
    "href": "docs/performables/index.html",
    "title": "Performables | Screenplay",
    "summary": "Performables Screenplay comes with a few pre-created Abilities, Performables and Builders, for common tasks. Some of these require the installation of additional NuGet packages. Using a Stopwatch When an actor needs to keep precise track of time, you may give them the UseAStopwatch ability. Actors with this ability may use Actions and Questions which relate to use of the stopwatch. These are all accessible from the builder class StopwatchBuilder. TimeSpan builder The TimeSpanBuilder<TOtherBuilder> is not a complete performable builder; it is intended to supplement other builders such as those of your own design. It handles a commonly-used aspect of building performables in a reusable manner."
  },
  "docs/writingPerformables/AllowCooperativeCancellation.html": {
    "href": "docs/writingPerformables/AllowCooperativeCancellation.html",
    "title": "Allow cooperative cancellation | Screenplay",
    "summary": "Allow cooperative cancellation All Performables implement one of three interfaces and each of these interfaces exposes a PerformAsAsync method which accepts a CancellationToken as a parameter. This cancellation token is to facilitate cooperative cancellation, so that a Performance may be cancelled/terminated gracefully. If an Action or Question makes use of an asynchronous method from an Ability then pass the cancellation token as a parameter to the Ability method that is used. Any time a Performance or Task executes a performable, pass the cancellation token down to the consumed performable as a parameter. Consider the strategies below for dealing with long-running synchronous methods, which do not natively participate in cooperative cancellation. There is no need for every performable (particularly tasks) to execute ThrowIfCancellationRequested() as a matter of course. Many performables complete their logic in microseconds or less, so excess cancellation-checking will bloat the logic for no perceivable gain. So long as the cancellation token is passed from 'the top of the Performance' downwards, and any Actions or Questions which perform async or long-running logic are cancellation-enabled, cancellation should work in a timely fashion. Dealing with long-running synchronous methods Sometimes an Action or Question will need to make use of functionality from an Ability which does not support cooperative cancellation. If such functionality is long-running then this can interfere with cancellation. It can lead to performances which take a long time to respond to cancellation of/when it is requested. Perhaps it's legacy code which predates the asynchronous programming model Perhaps it doesn't conform to best practice and doesn't accept a cancellation token parameter Here are two suggestions to deal with this. Throw if cancellation requested Cancellation token objects have a method ThrowIfCancellationRequested() which will interrupt and throw an exception if cancellation has been requested. You may use this method directly before executing a long-running synchronous (non-cancelable) Ability method. This won't cancel the long-running method if cancellation is requested after it has started its work, but it will prevent it from being started if cancellation is already requested. Use this technique if it's more important that the long-running method is not interrupted than it is to support timely cancellation. Use Task.Wait to make the long-running method interruptible An alternative strategy for dealing with long-running synchronous methods is to wrap the method execution in a new Task and use Task.Wait() to interrupt the task if cancellation is requested. Here's an example of that technique in action, applied to the PerformAsAsync method of a performable. public ValueTask PerformAsAsync(ICanPerform actor, CancellationToken cancellationToken) { Task.Run(() => LongRunningMethod()).Wait(cancellationToken); return default; } Use this technique if it's acceptable to send the long-running method into a separate thread and to 'give up waiting' for it to complete if cancellation has been requested. This technique might provide better responsiveness to cancellation than the one above, albeit it is the most likely to produce unexpected impact on the behaviour of the performable. Note that, as is standard for usage of Task.Wait(), cancelling the wait does not abort the execution of the long-running method. The thread which is executing that logic will usually continue and run to completion. Interrupting the wait just means that the main performance thread stops waiting for the other thread to complete."
  },
  "docs/writingPerformables/AvoidBranchingLogic.html": {
    "href": "docs/writingPerformables/AvoidBranchingLogic.html",
    "title": "Avoid branching logic | Screenplay",
    "summary": "Avoid branching logic Performances are written a lot like scripts. Where possible, Performables should avoid branching or looping logic. This is particularly true when Screenplay is being used as a tool for testing. Good test logic has a cyclomatic complexity of precisely one. Sometimes looping logic is unavoidable and desirable in a Screenplay, imagine a performable which has an Actor repeat a process N times. This is acceptable if used judiciously. Performables should always avoid branching logic like if or switch though, and should never contain such logic when being used for tests. If more than one mode of operation is required then write more than one performable. The path through a Performance should be completely deterministic, short of an unexpected error or failure."
  },
  "docs/writingPerformables/DoNotUseDiFrameworks.html": {
    "href": "docs/writingPerformables/DoNotUseDiFrameworks.html",
    "title": "Do not resolve performables from DI | Screenplay",
    "summary": "Do not resolve performables from DI Dependency Injection using DI frameworks is usually a recommended best practice in modern software. Screenplay recommends the resolution of many services from DI, including Personas, the Cast, Stage and Abilities. It is not a good idea to resolve Performable object instances from DI, though. Because performables should be immutable but stateful, this requires all of their state to be set at the time of their construction, such as via constructor parameters or properties with init setters. Unfortunately, this state represents the configuration of how the performable will be used, so it will be entirely down to the particular usage of the performable. This would make the use of DI quite cumbersome, as many arbitrary parameter values must be passed to the resolution. What's more, performables should not depend upon anything which is resolved from DI. At most, Actions and Questions may depend upon an Actor's Abilities but they should access these from the first parameter of the PerformAsAsync method; the ICanPerform parameter (the actor). Instead, it is far better to use the builder pattern to create instances of performables."
  },
  "docs/writingPerformables/ImplementICanReport.html": {
    "href": "docs/writingPerformables/ImplementICanReport.html",
    "title": "Implement ICanReport | Screenplay",
    "summary": "Implement ICanReport When writing a Performable class, implement the ICanReport interface a well as the relevant performable interface. This enables a performable to emit a formatted, human-readable fragment of a report for the current performable. If you plan to redistribute your performables as a library then consider making your report fragments localizable strings, so that they may be translated for other locales."
  },
  "docs/writingPerformables/ImplementOnePerformableInterface.html": {
    "href": "docs/writingPerformables/ImplementOnePerformableInterface.html",
    "title": "Implementing the performable interface | Screenplay",
    "summary": "Implementing the performable interface A Performable is a class which implements one of the three performable interfaces: IPerformable IPerformableWithResult IPerformableWithResult<TResult> Performables must implement precisely one of these interfaces. Implementing more than one upon a single performable is not recommended or supported. Doing so is liable to cause difficulties. If you wish to share code then move the reusable logic into a Task and consume that from separate performable classes."
  },
  "docs/writingPerformables/ParameterizeLowLevelPerformables.html": {
    "href": "docs/writingPerformables/ParameterizeLowLevelPerformables.html",
    "title": "Parameterize low-level Performables | Screenplay",
    "summary": "Parameterize low-level Performables When writing low-level Performables, these classes should expose parameters which allow the consumer to provide as many of the variables as make sense. This is especially important for Actions and/or Questions but also relevant for lower-level/reusable Tasks. Parameters should be accepted via the class' public constructor, the values to these parameters should then be held readonly. Accept as many parameters as are reasonable, although avoid going so far that parameterisation makes a Performable unclear as to what it does. An example Imagine we are writing a Task which makes a cup of coffee, ready to serve. It would make sense to include parameters which decide the strength of the coffee, how much milk and sweetener to add and similar. It would usually be a mistake to create a Task which can make any hot drink, where the parameters provided decide which hot drink to make. The processes for making various hot drinks are often fundamentally different; consider the process for making coffee and then that for brewing tea. In the most extreme case, where such a Task is required, separate the logic of making of each hot drink into Tasks of their own, and consume/execute the relevant one of these from the any hot drink Task."
  },
  "docs/writingPerformables/PureFunctionalTasks.html": {
    "href": "docs/writingPerformables/PureFunctionalTasks.html",
    "title": "'Pure functional' tasks | Screenplay",
    "summary": "'Pure functional' tasks To maximise their reusability, developers are advised to write Tasks in a way which either: Changes the application's state Gets information from the application without changing its state This draws from the lessons that writing pure functions teaches us. If 'getting some information' has unwanted or unexpected side-effects then the task becomes less reusable. If a task must have side effects then consider separating the parts of it which do not require those side-effects into a lower-level task which is reusable without the side-effects. That lower-level task would then be consumed by a higher-level task which does include the side-effects."
  },
  "docs/writingPerformables/StatefulButImmutable.html": {
    "href": "docs/writingPerformables/StatefulButImmutable.html",
    "title": "Performables are stateful, but immutable | Screenplay",
    "summary": "Performables are stateful, but immutable Instances of Performable classes are not intended to be reused. A single class may have many instances created, but each instance should be used only once. This is because the 'parameter values' for each performable are provided into that performable object instance. Parameters should ideally be provided into the performable class' public constructor. Another viable technique could be init-only property setters. Once these values are set, they should be readonly so that they may not be changed. Performable classes should also avoid the use of mutable class-level data such as fields or properties. Any temporary state should be scoped only to the relevant PerformAsAsync method."
  },
  "docs/writingPerformables/TasksDoNotUseAbilities.html": {
    "href": "docs/writingPerformables/TasksDoNotUseAbilities.html",
    "title": "Tasks should not use abilities | Screenplay",
    "summary": "Tasks should not use abilities The logic of Task classes should not interact with the actor's Abilities. Logic which interacts with abilities should be limited to Action and/or Question classes. Move logic which needs to interact with Abilities into Action/Question classes and ensure that they are appropriately parameterized. Consume such actions or questions from your custom Task class."
  },
  "docs/writingPerformables/WriteABuilder.html": {
    "href": "docs/writingPerformables/WriteABuilder.html",
    "title": "Write builders for your performables | Screenplay",
    "summary": "Write builders for your performables If you write a new performable class, it is strongly recommended to write a static builder for it. Benefits include: Ensuring that the performable may only be created in a valid state Making your performance logic more human-readable, almost like a domain specific language"
  },
  "docs/writingPerformables/index.html": {
    "href": "docs/writingPerformables/index.html",
    "title": "Writing Performables | Screenplay",
    "summary": "Writing Performables Screenplay and add-on libraries will ship with pre-created Actions and Questions, two of the three types of Performable. Developers making use of Screenplay might not need to write new Actions or Questions, because they may use and compose the existing ones. On the other hand, it is very likely that developers will need to write Tasks, which are the kind of Performable which composes Actions, Questions and/or other Tasks. A sample Task Here is an annotated example of a Task which makes use of a fictitious Action and a fictitious Question. TODO: Write this docco Guidelines for writing performables The following list shows some guidelines for writing new performables. These apply equally across ask if the three types of performables, even though developers are mainly expected to be writing tasks. Implement precisely one performable interface Implement ICanReport Parameterize low-level performables Avoid branching logic Performables should be stateful but immutable Allow cooperative cancellation Write a builder Do not rely on a DI framework Aim for Pure Functional tasks Do not interact with Abilities from Tasks"
  },
  "glossary/Ability.html": {
    "href": "glossary/Ability.html",
    "title": "Ability | Screenplay",
    "summary": "Ability An ability is an arbitrary object which may be granted to Actors in order to allow them to interact with the application as part of a Performance. Unlike many other Screenplay object-types, there is no particular interface which Abilities must implement, as their functionality, capabilities and very nature are specific to them alone. That said - it is recommended for Abilities to implement ICanReport if possible, as this allows for the production of a more pleasant human-readable report. Actions and/or Questions may interact directly with an actor's abilities in order to perform their functionality. Tasks, on the other hand, should not. The purpose of abilities Abilities typically have one (or more) of the following purposes. They provide a Gateway or Faade to external functionality They provide access to dependency services They provide a model of data, such as: Secrets/access tokens for an API to be consumed by abilities Contextual per-performance state Abilities are intended to be used by Actions and/or Questions, not Tasks. Abilities provide the dependencies that those performables require, because performables cannot participate in constructor-injected dependency injection. Abilities can receive constructor-injected dependencies from DI, making them an ideal technique to provide dependencies to performables."
  },
  "glossary/Action.html": {
    "href": "glossary/Action.html",
    "title": "Action | Screenplay",
    "summary": "Action An Action is a kind of Performable in which an Actor does something or interacts with the application in such as way as to change its state. Specifically, an action should be the smallest, most granular change or interaction possible; something which cannot reasonably be split into constituent parts. In an application of Screenplay which controls a web browser, an action might be a single mouse click, or entering some specified text into an input field. To create higher-level interactions, use Tasks to compose actions. Out of the kinds of performable, actions are the smallest building blocks available. Actions don't have a direct representation in Screenplay code because they are really just an arbitrary category of performable. Actions most commonly implement the IPerformable interface though, as they usually do not return any results. Generally, the logic of actions interacts directly with the actor's Abilities in order to provide the functionality required to perform the action."
  },
  "glossary/Asset.html": {
    "href": "glossary/Asset.html",
    "title": "Asset | Screenplay",
    "summary": "Asset An Asset forms part of a Screenplay Report. Assets are files which are generated during the course of Performances, which are saved to the filesystem. These assets are saved alongside the report, and should be kept with it. Assets may be any type of file system file, in any format conceivable. Their usage/content is somewhat open-ended but they are best-used for files which help a reader understand the report of the Screenplay's performances. Assets are not intended for cases when Screenplay is used to actually generate output which will be used outside of reading the report. Indeed, asset files must not be created or saved if reporting is disabled. Learn more about Assets Further information about working with Assets is available in the documentation."
  },
  "glossary/Extension.html": {
    "href": "glossary/Extension.html",
    "title": "Extension | Screenplay",
    "summary": "Extension The Screenplay library doesn't do much on its own. The packages CSF.Screenplay.Abstractions and CSF.Screenplay offer very little in the way of Abilities, Actions or Questions. Since these are the building blocks for writing Tasks and Performances, developers won't get very far without installing one or more extensions. There are a few extensions available which are maintained by the authors of CSF.Screenplay. Can't see what you need? Developers are encouraged to write new extensions if they would like; it's not difficult. See the extending Screenplay documentation for more information."
  },
  "glossary/Feature.html": {
    "href": "glossary/Feature.html",
    "title": "Feature | Screenplay",
    "summary": "Feature A Feature is a concept which is relevant when the Screenplay library is being used to perform automated tests. Each feature is a logical group of one or more related Scenarios. In Screenplay, features exist only for organising scenarios. They have no first-class representation in the code; their only appearance is within Reports. Everything related to features is handled automatically when consuming Screenplay from an appropriate Integration. Depending upon the testing framework in use, features might alternatively be named \"test fixture\" or \"test class\"."
  },
  "glossary/Integration.html": {
    "href": "glossary/Integration.html",
    "title": "Integration | Screenplay",
    "summary": "Integration An Integration refers to an integration library between the Screenplay library and a framework for performing automated tests. The integration library performs the necessary scaffolding to ensure that supported Screenplay types are available for dependency injection. It also deals with the association of Scenarios with Performances and the lifetime of the whole Screenplay, culminating with the production of the Report."
  },
  "glossary/Performable.html": {
    "href": "glossary/Performable.html",
    "title": "Performable | Screenplay",
    "summary": "Performable A 'performable' is a verb in the language of Screenplay; performables are things that Actors do. Performables are logically grouped into one of the following three kinds. Do not be mistaken in believing that these three kinds of performable correspond to the three interfaces which are listed later on this page. This is entirely coincidental and there is no direct equivalence. Actions are the most granular of individual interactions with the application, composable to form higher-order interactions Questions are granular, like actions, but read the application's state to get information instead of making changes Tasks are higher-order interactions which are formed by composing actions, questions and/or other tasks Performables are reusable As noted above, Tasks may use any of Actions, Questions or other Tasks. There is no limit to this composition/reusability. It's perfectly normal to write a task which makes use of several tasks, which thesmevles make use of several other tasks and so on. Each higher-level task composes lower-level tasks. At the very end of the composition will of course be Actions/Questions but there is no limit to the number of 'layers' of tasks. Performable instances are not reusable Types which implement the performable interfaces (below) are stateful objects which are often mutable. Their state defines their configuration, as such, instances of any performable type must not be reused. Typically, performables are created using a builder which configures their state. Each performable object is used precisely once by an actor and then discarded. Even if you would like to perform the same operation twice, do not attempt to reuse an object instance; use the builder twice to create two (identical) instances of the same performable type. Developers using Screenplay will typically be writing Tasks Actions & Questions are the smallest/low-level building blocks of a Screenplay Performance. They are parameterized and should make as few assumptions as possible. As such, they should be highly reusable. Actions & Questions rarely need to be written by developers who are using Screenplay. That is because most likely, the Action, Question and corresponding Ability classes will have been provided in a library, such as a NuGet package. On the other hand, Tasks are higher-level performables which may compose Actions, Questions and/or other lower-level Tasks. Developers using Screenplay should write as many Tasks as they need. Tasks may represent any of the - possibly complex - interactions performed by the Actor. Actions & Questions should interact directly with the Actor's Abilities to perform their logic; in most cases Tasks should not directly use any Abilities. When writing your own performables, consider these best practices for the best results. The three performable interfaces, and ICanReport In Screenplay code, a Performance is a script of sorts, written from at least one performable, usually several. All performables must implement one of the following three interfaces, but it's also strongly recommended to implement ICanReport as well. As noted above, it is coincidence alone that there are three kinds of performable and three interfaces for performables. There is no direct correlation between these interfaces and the kinds of performable. IPerformable IPerformableWithResult IPerformableWithResult<TResult>"
  },
  "glossary/Persona.html": {
    "href": "glossary/Persona.html",
    "title": "Persona | Screenplay",
    "summary": "Persona A Persona is a class which serves as a factory for a specific Actor. In Screenplay, it is strongly recommended to create and re-use well-known Actors across your Performances. That is, if an actor with a specified Name has a certain set of Abilities in one Performance, then ideally all actors of the same name should have that same set of abilities in other performances. This leads to the creation of well-known Actors which are well-understood by the team who are working with Screenplay. Personas help facilitate that by providing a reusable location at which to set the actor's name and to assign & configure their abilities. Personas in Screenplay are classes which implement the IPersona interface."
  },
  "glossary/Question.html": {
    "href": "glossary/Question.html",
    "title": "Question | Screenplay",
    "summary": "Question A Question is a kind of Performable in which an Actor gets or reads some information from the application, ideally in such a way that does not change the application's state. Similar to Actions, questions should be as small in their scope as possible, to make them as reusable and composable as possible. In code, questions get a value and return it to the consuming logic, so they will always implement one of IPerformableWithResult<TResult> or its non-generic counterpart IPerformableWithResult. In an application of Screenplay which controls a web browser, a questions might represent reading the text from a single HTML element, or reading the enabled/disabled state of a button. To create higher-level questions with broader scope, compose them with Tasks. Generally, the logic of questions interacts directly with the actor's Abilities in order to provide the functionality required to get the requested information."
  },
  "glossary/Report.html": {
    "href": "glossary/Report.html",
    "title": "Report | Screenplay",
    "summary": "Report After a Screenplay has completed, the Screenplay software may produce a machine-readable report of what occurred. This report may be read, processed, stored or transformed into an alternative format as desired. The report is hierarchical; at its topmost level are Features and within are Scenarios. The scenario directly corresponds to a single Performance, and within are contained all of the Performables for that performance. Performables in a report are also included hierarchically. This means that high-level Tasks contain information about the performables from which they are composed. Reports are useful to document what has been performed in a Screenplay. They help developers diagnose and debug issues when they arise."
  },
  "glossary/Scenario.html": {
    "href": "glossary/Scenario.html",
    "title": "Scenario | Screenplay",
    "summary": "Scenario A Scenario is a single test within a testing framework. Testing frameworks differ between one another in the terminology that they use to name their individual tests. Screenplay uses the name \"Scenario\" because this matches the name used in Cucumber. Scenarios are only relevant when Screenplay is used in conjunction with a test framework integration. The concept of a Scenario is irrelevant when using Screenplay standalone. A Scenario represents the lifetime of each individual test; when using Screenplay as a testing tool, the lifetime of the Scenario corresponds very closely to the lifetime of a Performance. When using Screenplay, each Performance (and thus Scenario) is executed within its own Dependency Injection Lifetime Scope. Every scenario is typically contained within a Feature. The structure of scenarios-within-features may be represented in the Performance using the NamingHierarchy. Other names for Scenarios Various testing frameworks have established different naming conventions for what is - fundamentally - the same thing. Here are some other names which you might see in different testing frameworks. Test Test case Theory Example"
  },
  "glossary/Spotlight.html": {
    "href": "glossary/Spotlight.html",
    "title": "Spotlight | Screenplay",
    "summary": "Spotlight When the Stage is used to get an Actor, that actor is placed in the Spotlight. That same actor remains in the spotlight until a different actor is placed there. Note, though, that a Stage and thus its corresponding Spotlight is scoped to the current Performance. A different performance has a completely independent Stage and Spotlight. A stage may be used at any time to get the actor who is currently in the spotlight. Thus, it is possible to infer an actor in Performance logic without needing to use their name. See the documentation for the Stage for more information."
  },
  "glossary/Task.html": {
    "href": "glossary/Task.html",
    "title": "Task | Screenplay",
    "summary": "Task A Task is a kind of Performable which represents a high-level interaction with the application. Where Actions or Questions are highly granular for maximum reusability, tasks may be as specific as the use-case warrants. Action & question classes are often shipped with Screenplay frameworks. Tasks are typically written by the developer who is making use of Screenplay. In practice, tasks are just compositions of actions, questions or other lower-level tasks. In a Screenplay which controls a web application, an example of a task is the completion of a registration form which involves entering data into multiple input fields. Writing tasks Tasks may implement any of the three performable interfaces. Developers are encouraged to follow these best practices when writing Task classes."
  },
  "glossary/index.html": {
    "href": "glossary/index.html",
    "title": "Glossary | Screenplay",
    "summary": "Glossary Following is a glossary of Screenplay terminology; each term is a link to its own documentation. Many of these terms are implemented directly as .NET types in the Screenplay architecture. Where applicable, the glossary item links directly to the relevant type within the API documentation. Term Summary Ability Something that an actor is able to do or has; provides the dependencies for actions/questions Action A kind of peformable; the lowest-level interaction that changes the state of the application Actor Typically a human user of the application, directs the use of performables Asset A file which is saved to disk during a Performance, accessible from the Report Cast A factory & registry for actors which facilitates managing multiple actors in a performance Extension An add-on library providing new Abilities, Actions & Questions for controlling a specific technology Feature A logical group of related scenarios, this is a test class or test fixture in some testing frameworks Integration A consumer of the Screenplay framework, such as a testing framework Performable A Screenplay verb; something that an actor can do Performance A single end-to-end script of performables Persona A factory or template for consistently creating reusable, well-known actors Question A kind of peformable; the lowest-level interrogation that reads application state Report An output which details every performance/scenario and the outcomes of theie performables Scenario Typically similar to a performance, this is a single test within a testing framework Screenplay A complete execution of the Screenplay software Spotlight The currently active actor, facilitated by the stage Stage Provides situational context; a concept of 'the currently active actor' Task A composition of actions, questions and/or other tasks to create higher-level performables"
  },
  "index.html": {
    "href": "index.html",
    "title": "Screenplay pattern for .NET | Screenplay",
    "summary": "Screenplay pattern for .NET var webster = stage.Spotlight<Webster>(); await Given(webster).WasAbleTo(OpenTheUrl(shoppingCartPage)); await When(webster).AttemptsTo(RemoveTheItemFromTheirCartNamed(\"Widgets\")); await When(webster).AttemptsTo(SaveTheirShoppingCart()); var total = await Then(webster).Should(ReadTheTotalValueOfTheirCart()); Screenplay is a software design pattern to script the automation of complex processes. It is popular for writing BDD-style tests. CSF.Screenplay is a library and framework for the Screenplay pattern. What is Screenplay? What can Screenplay do? How do I use Screenplay?"
  }
}